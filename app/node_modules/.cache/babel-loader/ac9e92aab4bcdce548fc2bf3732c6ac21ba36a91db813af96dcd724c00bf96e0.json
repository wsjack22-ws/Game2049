{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { Duplex } from 'readable-stream';\nimport { EventEmitter } from 'events';\nimport stringify from 'fast-safe-stringify';\nimport { serializeError, rpcErrors } from '@metamask/rpc-errors';\nimport eos from 'end-of-stream';\nimport once from 'once';\nimport pump from 'pump';\nfunction noop() {\n  return undefined;\n}\nconst SYN = \"SYN\";\nconst ACK = \"ACK\";\nconst BRK = \"BRK\";\nclass BasePostMessageStream extends Duplex {\n  constructor(_ref) {\n    let {\n      name,\n      target,\n      targetWindow = window,\n      targetOrigin = \"*\"\n    } = _ref;\n    super({\n      objectMode: true\n    });\n    _defineProperty(this, \"_init\", void 0);\n    _defineProperty(this, \"_haveSyn\", void 0);\n    _defineProperty(this, \"_name\", void 0);\n    _defineProperty(this, \"_target\", void 0);\n    _defineProperty(this, \"_targetWindow\", void 0);\n    _defineProperty(this, \"_targetOrigin\", void 0);\n    _defineProperty(this, \"_onMessage\", void 0);\n    _defineProperty(this, \"_synIntervalId\", void 0);\n    if (!name || !target) {\n      throw new Error(\"Invalid input.\");\n    }\n    this._init = false;\n    this._haveSyn = false;\n    this._name = name;\n    this._target = target; // target origin\n    this._targetWindow = targetWindow;\n    this._targetOrigin = targetOrigin;\n    this._onMessage = this.onMessage.bind(this);\n    this._synIntervalId = null;\n    window.addEventListener(\"message\", this._onMessage, false);\n    this._handShake();\n  }\n  _break() {\n    this.cork();\n    this._write(BRK, null, noop);\n    this._haveSyn = false;\n    this._init = false;\n  }\n  _handShake() {\n    this._write(SYN, null, noop);\n    this.cork();\n  }\n  _onData(data) {\n    if (!this._init) {\n      // listen for handshake\n      if (data === SYN) {\n        this._haveSyn = true;\n        this._write(ACK, null, noop);\n      } else if (data === ACK) {\n        this._init = true;\n        if (!this._haveSyn) {\n          this._write(ACK, null, noop);\n        }\n        this.uncork();\n      }\n    } else if (data === BRK) {\n      this._break();\n    } else {\n      // forward message\n      try {\n        this.push(data);\n      } catch (err) {\n        this.emit(\"error\", err);\n      }\n    }\n  }\n  _postMessage(data) {\n    const originConstraint = this._targetOrigin;\n    this._targetWindow.postMessage({\n      target: this._target,\n      data\n    }, originConstraint);\n  }\n  onMessage(event) {\n    const message = event.data;\n    // validate message\n    if (this._targetOrigin !== \"*\" && event.origin !== this._targetOrigin || event.source !== this._targetWindow || typeof message !== \"object\" || message.target !== this._name || !message.data) {\n      return;\n    }\n    this._onData(message.data);\n  }\n  _read() {\n    return undefined;\n  }\n  _write(data, _, cb) {\n    this._postMessage(data);\n    cb();\n  }\n  _destroy() {\n    window.removeEventListener(\"message\", this._onMessage, false);\n  }\n}\nfunction safeApply(handler, context, args) {\n  try {\n    Reflect.apply(handler, context, args);\n  } catch (err) {\n    // Throw error after timeout so as not to interrupt the stack\n    setTimeout(() => {\n      throw err;\n    });\n  }\n}\nfunction arrayClone(arr) {\n  const n = arr.length;\n  const copy = new Array(n);\n  for (let i = 0; i < n; i += 1) {\n    copy[i] = arr[i];\n  }\n  return copy;\n}\nclass SafeEventEmitter extends EventEmitter {\n  emit(type) {\n    let doError = type === \"error\";\n    const events = this._events;\n    if (events !== undefined) {\n      doError = doError && events.error === undefined;\n    } else if (!doError) {\n      return false;\n    }\n    // If there is no 'error' event listener then throw.\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    if (doError) {\n      let er;\n      if (args.length > 0) {\n        [er] = args;\n      }\n      if (er instanceof Error) {\n        // Note: The comments on the `throw` lines are intentional, they show\n        // up in Node's output if this results in an unhandled exception.\n        throw er; // Unhandled 'error' event\n      }\n      // At least give some kind of context to the user\n      const err = new Error(`Unhandled error.${er ? ` (${er.message})` : \"\"}`);\n      err.context = er;\n      throw err; // Unhandled 'error' event\n    }\n\n    const handler = events[type];\n    if (handler === undefined) {\n      return false;\n    }\n    if (typeof handler === \"function\") {\n      safeApply(handler, this, args);\n    } else {\n      const len = handler.length;\n      const listeners = arrayClone(handler);\n      for (let i = 0; i < len; i += 1) {\n        safeApply(listeners[i], this, args);\n      }\n    }\n    return true;\n  }\n}\nclass SerializableError extends Error {\n  constructor(_ref) {\n    let {\n      code,\n      message,\n      data\n    } = _ref;\n    if (!Number.isInteger(code)) {\n      throw new Error(\"code must be an integer\");\n    }\n    if (!message || typeof message !== \"string\") {\n      throw new Error(\"message must be string\");\n    }\n    super(message);\n    _defineProperty(this, \"code\", void 0);\n    _defineProperty(this, \"data\", void 0);\n    this.code = code;\n    if (data !== undefined) {\n      this.data = data;\n    }\n  }\n  toString() {\n    return stringify({\n      code: this.code,\n      message: this.message,\n      data: this.data,\n      stack: this.stack\n    });\n  }\n}\nconst getRpcPromiseCallback = function (resolve, reject) {\n  let unwrapResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  return (error, response) => {\n    if (error || response.error) {\n      reject(error || response.error);\n    } else if (!unwrapResult || Array.isArray(response)) {\n      resolve(response);\n    } else {\n      resolve(response.result);\n    }\n  };\n};\nfunction createErrorMiddleware(log) {\n  return (req, res, next, end) => {\n    try {\n      // json-rpc-engine will terminate the request when it notices this error\n      if (typeof req.method !== \"string\" || !req.method) {\n        res.error = new SerializableError({\n          code: -32603,\n          message: \"invalid method\"\n        });\n        end();\n        return;\n      }\n      next(done => {\n        const {\n          error\n        } = res;\n        if (!error) {\n          return done();\n        }\n        log.error(`OpenLogin - RPC Error: ${error.message}`, error);\n        return done();\n      });\n    } catch (error) {\n      log.error(`OpenLogin - RPC Error thrown: ${error.message}`, error);\n      res.error = new SerializableError({\n        code: -32603,\n        message: error.message\n      });\n      end();\n    }\n  };\n}\nfunction createStreamMiddleware() {\n  const idMap = {};\n  function readNoop() {\n    return false;\n  }\n  const events = new SafeEventEmitter();\n  function processResponse(res) {\n    const context = idMap[res.id];\n    if (!context) {\n      throw new Error(`StreamMiddleware - Unknown response id \"${res.id}\"`);\n    }\n    delete idMap[res.id];\n    // copy whole res onto original res\n    Object.assign(context.res, res);\n    // run callback on empty stack,\n    // prevent internal stream-handler from catching errors\n    setTimeout(context.end);\n  }\n  function processNotification(res) {\n    events.emit(\"notification\", res);\n  }\n  function processMessage(res, _encoding, cb) {\n    let err;\n    try {\n      const isNotification = !res.id;\n      if (isNotification) {\n        processNotification(res);\n      } else {\n        processResponse(res);\n      }\n    } catch (_err) {\n      err = _err;\n    }\n    // continue processing stream\n    cb(err);\n  }\n  const stream = new Duplex({\n    objectMode: true,\n    read: readNoop,\n    write: processMessage\n  });\n  const middleware = (req, res, next, end) => {\n    // write req to stream\n    stream.push(req);\n    // register request on id map\n    idMap[req.id] = {\n      req,\n      res,\n      next,\n      end\n    };\n  };\n  return {\n    events,\n    middleware,\n    stream\n  };\n}\nfunction createScaffoldMiddleware(handlers) {\n  return (req, res, next, end) => {\n    const handler = handlers[req.method];\n    // if no handler, return\n    if (handler === undefined) {\n      return next();\n    }\n    // if handler is fn, call as middleware\n    if (typeof handler === \"function\") {\n      return handler(req, res, next, end);\n    }\n    // if handler is some other value, use as result\n    res.result = handler;\n    return end();\n  };\n}\nfunction createIdRemapMiddleware() {\n  return (req, res, next, _end) => {\n    const originalId = req.id;\n    const newId = Math.random().toString(36).slice(2);\n    req.id = newId;\n    res.id = newId;\n    next(done => {\n      req.id = originalId;\n      res.id = originalId;\n      done();\n    });\n  };\n}\nfunction createLoggerMiddleware(logger) {\n  return (req, res, next, _) => {\n    logger.debug(\"REQ\", req, \"RES\", res);\n    next();\n  };\n}\nfunction createAsyncMiddleware(asyncMiddleware) {\n  return async (req, res, next, end) => {\n    // nextPromise is the key to the implementation\n    // it is resolved by the return handler passed to the\n    // \"next\" function\n    let resolveNextPromise;\n    const nextPromise = new Promise(resolve => {\n      resolveNextPromise = resolve;\n    });\n    let returnHandlerCallback = null;\n    let nextWasCalled = false;\n    // This will be called by the consumer's async middleware.\n    const asyncNext = async () => {\n      nextWasCalled = true;\n      // We pass a return handler to next(). When it is called by the engine,\n      // the consumer's async middleware will resume executing.\n      next(runReturnHandlersCallback => {\n        // This callback comes from JRPCEngine._runReturnHandlers\n        returnHandlerCallback = runReturnHandlersCallback;\n        resolveNextPromise();\n      });\n      await nextPromise;\n    };\n    try {\n      await asyncMiddleware(req, res, asyncNext);\n      if (nextWasCalled) {\n        await nextPromise; // we must wait until the return handler is called\n        returnHandlerCallback(null);\n      } else {\n        end(null);\n      }\n    } catch (error) {\n      if (returnHandlerCallback) {\n        returnHandlerCallback(error);\n      } else {\n        end(error);\n      }\n    }\n  };\n}\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\n/**\n * A JSON-RPC request and response processor.\n * Give it a stack of middleware, pass it requests, and get back responses.\n */\nclass JRPCEngine extends SafeEventEmitter {\n  constructor() {\n    super();\n    _defineProperty(this, \"_middleware\", void 0);\n    this._middleware = [];\n  }\n  /**\n   * Serially executes the given stack of middleware.\n   *\n   * @returns An array of any error encountered during middleware execution,\n   * a boolean indicating whether the request was completed, and an array of\n   * middleware-defined return handlers.\n   */\n  static async _runAllMiddleware(req, res, middlewareStack) {\n    const returnHandlers = [];\n    let error = null;\n    let isComplete = false;\n    // Go down stack of middleware, call and collect optional returnHandlers\n    for (const middleware of middlewareStack) {\n      [error, isComplete] = await JRPCEngine._runMiddleware(req, res, middleware, returnHandlers);\n      if (isComplete) {\n        break;\n      }\n    }\n    return [error, isComplete, returnHandlers.reverse()];\n  }\n  /**\n   * Runs an individual middleware.\n   *\n   * @returns An array of any error encountered during middleware exection,\n   * and a boolean indicating whether the request should end.\n   */\n  static _runMiddleware(req, res, middleware, returnHandlers) {\n    return new Promise(resolve => {\n      const end = err => {\n        const error = err || res.error;\n        if (error) {\n          res.error = serializeError(error);\n        }\n        // True indicates that the request should end\n        resolve([error, true]);\n      };\n      const next = returnHandler => {\n        if (res.error) {\n          end(res.error);\n        } else {\n          if (returnHandler) {\n            if (typeof returnHandler !== \"function\") {\n              end(new SerializableError({\n                code: -32603,\n                message: \"JRPCEngine: 'next' return handlers must be functions\"\n              }));\n            }\n            returnHandlers.push(returnHandler);\n          }\n          // False indicates that the request should not end\n          resolve([null, false]);\n        }\n      };\n      try {\n        middleware(req, res, next, end);\n      } catch (error) {\n        end(error);\n      }\n    });\n  }\n  /**\n   * Serially executes array of return handlers. The request and response are\n   * assumed to be in their scope.\n   */\n  static async _runReturnHandlers(handlers) {\n    for (const handler of handlers) {\n      await new Promise((resolve, reject) => {\n        handler(err => err ? reject(err) : resolve());\n      });\n    }\n  }\n  /**\n   * Throws an error if the response has neither a result nor an error, or if\n   * the \"isComplete\" flag is falsy.\n   */\n  static _checkForCompletion(req, res, isComplete) {\n    if (!(\"result\" in res) && !(\"error\" in res)) {\n      throw new SerializableError({\n        code: -32603,\n        message: \"Response has no error or result for request\"\n      });\n    }\n    if (!isComplete) {\n      throw new SerializableError({\n        code: -32603,\n        message: \"Nothing ended request\"\n      });\n    }\n  }\n  /**\n   * Add a middleware function to the engine's middleware stack.\n   *\n   * @param middleware - The middleware function to add.\n   */\n  push(middleware) {\n    this._middleware.push(middleware);\n  }\n  handle(req, cb) {\n    if (cb && typeof cb !== \"function\") {\n      throw new Error('\"callback\" must be a function if provided.');\n    }\n    if (Array.isArray(req)) {\n      if (cb) {\n        return this._handleBatch(req, cb);\n      }\n      return this._handleBatch(req);\n    }\n    if (cb) {\n      return this._handle(req, cb);\n    }\n    return this._promiseHandle(req);\n  }\n  /**\n   * Returns this engine as a middleware function that can be pushed to other\n   * engines.\n   *\n   * @returns This engine as a middleware function.\n   */\n  asMiddleware() {\n    return async (req, res, next, end) => {\n      try {\n        const [middlewareError, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);\n        if (isComplete) {\n          await JRPCEngine._runReturnHandlers(returnHandlers);\n          return end(middlewareError);\n        }\n        return next(async handlerCallback => {\n          try {\n            await JRPCEngine._runReturnHandlers(returnHandlers);\n          } catch (error) {\n            return handlerCallback(error);\n          }\n          return handlerCallback();\n        });\n      } catch (error) {\n        return end(error);\n      }\n    };\n  }\n  async _handleBatch(reqs, cb) {\n    // The order here is important\n    try {\n      // 2. Wait for all requests to finish, or throw on some kind of fatal\n      // error\n      const responses = await Promise.all(\n      // 1. Begin executing each request in the order received\n      reqs.map(this._promiseHandle.bind(this)));\n      // 3. Return batch response\n      if (cb) {\n        return cb(null, responses);\n      }\n      return responses;\n    } catch (error) {\n      if (cb) {\n        return cb(error);\n      }\n      throw error;\n    }\n  }\n  /**\n   * A promise-wrapped _handle.\n   */\n  _promiseHandle(req) {\n    return new Promise(resolve => {\n      this._handle(req, (_err, res) => {\n        // There will always be a response, and it will always have any error\n        // that is caught and propagated.\n        resolve(res);\n      });\n    });\n  }\n  /**\n   * Ensures that the request object is valid, processes it, and passes any\n   * error and the response object to the given callback.\n   *\n   * Does not reject.\n   */\n  async _handle(callerReq, cb) {\n    if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== \"object\") {\n      const error = new SerializableError({\n        code: -32603,\n        message: \"request must be plain object\"\n      });\n      return cb(error, {\n        id: undefined,\n        jsonrpc: \"2.0\",\n        error\n      });\n    }\n    if (typeof callerReq.method !== \"string\") {\n      const error = new SerializableError({\n        code: -32603,\n        message: \"method must be string\"\n      });\n      return cb(error, {\n        id: callerReq.id,\n        jsonrpc: \"2.0\",\n        error\n      });\n    }\n    const req = _objectSpread$1({}, callerReq);\n    const res = {\n      id: req.id,\n      jsonrpc: req.jsonrpc\n    };\n    let error = null;\n    try {\n      await this._processRequest(req, res);\n    } catch (_error) {\n      // A request handler error, a re-thrown middleware error, or something\n      // unexpected.\n      error = _error;\n    }\n    if (error) {\n      // Ensure no result is present on an errored response\n      delete res.result;\n      if (!res.error) {\n        res.error = serializeError(error);\n      }\n    }\n    return cb(error, res);\n  }\n  /**\n   * For the given request and response, runs all middleware and their return\n   * handlers, if any, and ensures that internal request processing semantics\n   * are satisfied.\n   */\n  async _processRequest(req, res) {\n    const [error, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);\n    // Throw if \"end\" was not called, or if the response has neither a result\n    // nor an error.\n    JRPCEngine._checkForCompletion(req, res, isComplete);\n    // The return handlers should run even if an error was encountered during\n    // middleware processing.\n    await JRPCEngine._runReturnHandlers(returnHandlers);\n    // Now we re-throw the middleware processing error, if any, to catch it\n    // further up the call chain.\n    if (error) {\n      throw error;\n    }\n  }\n}\nfunction mergeMiddleware(middlewareStack) {\n  const engine = new JRPCEngine();\n  middlewareStack.forEach(middleware => engine.push(middleware));\n  return engine.asMiddleware();\n}\nfunction createEngineStream(opts) {\n  if (!opts || !opts.engine) {\n    throw new Error(\"Missing engine parameter!\");\n  }\n  const {\n    engine\n  } = opts;\n  // eslint-disable-next-line prefer-const\n  let stream;\n  function read() {\n    return undefined;\n  }\n  function write(req, _encoding, cb) {\n    engine.handle(req, (_err, res) => {\n      stream.push(res);\n    });\n    cb();\n  }\n  stream = new Duplex({\n    objectMode: true,\n    read,\n    write\n  });\n  // forward notifications\n  if (engine.on) {\n    engine.on(\"notification\", message => {\n      stream.push(message);\n    });\n  }\n  return stream;\n}\nfunction providerFromEngine(engine) {\n  const provider = new SafeEventEmitter();\n  // handle both rpc send methods\n  provider.sendAsync = async req => {\n    const res = await engine.handle(req);\n    if (res.error) {\n      var _res$error, _res$error2;\n      const err = serializeError(res.error, {\n        fallbackError: {\n          message: ((_res$error = res.error) === null || _res$error === void 0 ? void 0 : _res$error.message) || res.error.toString(),\n          code: ((_res$error2 = res.error) === null || _res$error2 === void 0 ? void 0 : _res$error2.code) || -32603\n        }\n      });\n      throw rpcErrors.internal(err);\n    }\n    return res.result;\n  };\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  provider.send = (req, callback) => {\n    if (typeof callback !== \"function\") {\n      throw new Error('Must provide callback to \"send\" method.');\n    }\n    engine.handle(req, callback);\n  };\n  // forward notifications\n  if (engine.on) {\n    engine.on(\"notification\", message => {\n      provider.emit(\"data\", null, message);\n    });\n  }\n  provider.request = async args => {\n    const req = _objectSpread$1(_objectSpread$1({}, args), {}, {\n      id: Math.random().toString(36).slice(2),\n      jsonrpc: \"2.0\"\n    });\n    const res = await provider.sendAsync(req);\n    return res;\n  };\n  return provider;\n}\nfunction providerFromMiddleware(middleware) {\n  const engine = new JRPCEngine();\n  engine.push(middleware);\n  const provider = providerFromEngine(engine);\n  return provider;\n}\nfunction providerAsMiddleware(provider) {\n  return async (req, res, _next, end) => {\n    // send request to provider\n    try {\n      const providerRes = await provider.sendAsync(req);\n      res.result = providerRes;\n      return end();\n    } catch (error) {\n      return end(error.message);\n    }\n  };\n}\nclass Substream extends Duplex {\n  constructor(_ref) {\n    let {\n      parent,\n      name\n    } = _ref;\n    super({\n      objectMode: true\n    });\n    _defineProperty(this, \"_parent\", void 0);\n    _defineProperty(this, \"_name\", void 0);\n    this._parent = parent;\n    this._name = name;\n  }\n  /**\n   * Explicitly sets read operations to a no-op.\n   */\n  _read() {\n    return undefined;\n  }\n  /**\n   * Called when data should be written to this writable stream.\n   *\n   * @param chunk - Arbitrary object to write\n   * @param encoding - Encoding to use when writing payload\n   * @param callback - Called when writing is complete or an error occurs\n   */\n  _write(chunk, _encoding, callback) {\n    this._parent.push({\n      name: this._name,\n      data: chunk\n    });\n    callback();\n  }\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nconst IGNORE_SUBSTREAM = Symbol(\"IGNORE_SUBSTREAM\");\nclass ObjectMultiplex extends Duplex {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(_objectSpread(_objectSpread({}, opts), {}, {\n      objectMode: true\n    }));\n    _defineProperty(this, \"_substreams\", void 0);\n    _defineProperty(this, \"getStream\", void 0);\n    this._substreams = {};\n  }\n  createStream(name) {\n    // validate name\n    if (!name) {\n      throw new Error(\"ObjectMultiplex - name must not be empty\");\n    }\n    if (this._substreams[name]) {\n      throw new Error(`ObjectMultiplex - Substream for name \"${name}\" already exists`);\n    }\n    // create substream\n    const substream = new Substream({\n      parent: this,\n      name\n    });\n    this._substreams[name] = substream;\n    // listen for parent stream to end\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    anyStreamEnd(this, _error => substream.destroy(_error || undefined));\n    return substream;\n  }\n  // ignore streams (dont display orphaned data warning)\n  ignoreStream(name) {\n    // validate name\n    if (!name) {\n      throw new Error(\"ObjectMultiplex - name must not be empty\");\n    }\n    if (this._substreams[name]) {\n      throw new Error(`ObjectMultiplex - Substream for name \"${name}\" already exists`);\n    }\n    // set\n    this._substreams[name] = IGNORE_SUBSTREAM;\n  }\n  _read() {\n    return undefined;\n  }\n  _write(chunk, _encoding, callback) {\n    const {\n      name,\n      data\n    } = chunk;\n    if (!name) {\n      window.console.warn(`ObjectMultiplex - malformed chunk without name \"${chunk}\"`);\n      return callback();\n    }\n    // get corresponding substream\n    const substream = this._substreams[name];\n    if (!substream) {\n      window.console.warn(`ObjectMultiplex - orphaned data for stream \"${name}\"`);\n      return callback();\n    }\n    // push data into substream\n    if (substream !== IGNORE_SUBSTREAM) {\n      substream.push(data);\n    }\n    return callback();\n  }\n}\n// util\nfunction anyStreamEnd(stream, _cb) {\n  const cb = once(_cb);\n  eos(stream, {\n    readable: false\n  }, cb);\n  eos(stream, {\n    writable: false\n  }, cb);\n}\nfunction setupMultiplex(stream) {\n  const mux = new ObjectMultiplex();\n  mux.getStream = function streamHelper(name) {\n    if (this._substreams[name]) {\n      return this._substreams[name];\n    }\n    return this.createStream(name);\n  };\n  pump(stream, mux, stream, err => {\n    if (err) window.console.error(err);\n  });\n  return mux;\n}\nclass PostMessageStream extends BasePostMessageStream {\n  _postMessage(data) {\n    let originConstraint = this._targetOrigin;\n    if (typeof data === \"object\") {\n      const dataObj = data;\n      if (typeof dataObj.data === \"object\") {\n        const dataObjData = dataObj.data;\n        if (Array.isArray(dataObjData.params) && dataObjData.params.length > 0) {\n          const dataObjDataParam = dataObjData.params[0];\n          if (dataObjDataParam._origin) {\n            originConstraint = dataObjDataParam._origin;\n          }\n          // add a constraint for the response\n          dataObjDataParam._origin = window.location.origin;\n        }\n      }\n    }\n    this._targetWindow.postMessage({\n      target: this._target,\n      data\n    }, originConstraint);\n  }\n}\nexport { BasePostMessageStream, IGNORE_SUBSTREAM, JRPCEngine, ObjectMultiplex, PostMessageStream, SafeEventEmitter, SerializableError, Substream, createAsyncMiddleware, createEngineStream, createErrorMiddleware, createIdRemapMiddleware, createLoggerMiddleware, createScaffoldMiddleware, createStreamMiddleware, getRpcPromiseCallback, mergeMiddleware, providerAsMiddleware, providerFromEngine, providerFromMiddleware, setupMultiplex };","map":{"version":3,"names":["noop","undefined","SYN","ACK","BRK","BasePostMessageStream","Duplex","constructor","_ref","name","target","targetWindow","window","targetOrigin","objectMode","_defineProperty","Error","_init","_haveSyn","_name","_target","_targetWindow","_targetOrigin","_onMessage","onMessage","bind","_synIntervalId","addEventListener","_handShake","_break","cork","_write","_onData","data","uncork","push","err","emit","_postMessage","originConstraint","postMessage","event","message","origin","source","_read","_","cb","_destroy","removeEventListener","safeApply","handler","context","args","Reflect","apply","setTimeout","arrayClone","arr","n","length","copy","Array","i","SafeEventEmitter","EventEmitter","type","doError","events","_events","error","_len","arguments","_key","er","len","listeners","SerializableError","code","Number","isInteger","toString","stringify","stack","getRpcPromiseCallback","resolve","reject","unwrapResult","response","isArray","result","createErrorMiddleware","log","req","res","next","end","method","done","createStreamMiddleware","idMap","readNoop","processResponse","id","Object","assign","processNotification","processMessage","_encoding","isNotification","_err","stream","read","write","middleware","createScaffoldMiddleware","handlers","createIdRemapMiddleware","_end","originalId","newId","Math","random","slice","createLoggerMiddleware","logger","debug","createAsyncMiddleware","asyncMiddleware","resolveNextPromise","nextPromise","Promise","returnHandlerCallback","nextWasCalled","asyncNext","runReturnHandlersCallback","JRPCEngine","_middleware","_runAllMiddleware","middlewareStack","returnHandlers","isComplete","_runMiddleware","reverse","serializeError","returnHandler","_runReturnHandlers","_checkForCompletion","handle","_handleBatch","_handle","_promiseHandle","asMiddleware","middlewareError","handlerCallback","reqs","responses","all","map","callerReq","jsonrpc","_objectSpread$1","_processRequest","_error","mergeMiddleware","engine","forEach","createEngineStream","opts","on","providerFromEngine","provider","sendAsync","_res$error","_res$error2","fallbackError","rpcErrors","internal","send","callback","request","providerFromMiddleware","providerAsMiddleware","_next","providerRes","Substream","parent","_parent","chunk","IGNORE_SUBSTREAM","Symbol","ObjectMultiplex","_objectSpread","_substreams","createStream","substream","anyStreamEnd","destroy","ignoreStream","console","warn","_cb","once","eos","readable","writable","setupMultiplex","mux","getStream","streamHelper","pump","PostMessageStream","dataObj","dataObjData","params","dataObjDataParam","_origin","location"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@toruslabs/base-controllers/node_modules/@toruslabs/openlogin-jrpc/src/basePostMessageStream.ts","/Users/wuhuan/gif-portal-starter/node_modules/@toruslabs/base-controllers/node_modules/@toruslabs/openlogin-jrpc/src/safeEventEmitter.ts","/Users/wuhuan/gif-portal-starter/node_modules/@toruslabs/base-controllers/node_modules/@toruslabs/openlogin-jrpc/src/serializableError.ts","/Users/wuhuan/gif-portal-starter/node_modules/@toruslabs/base-controllers/node_modules/@toruslabs/openlogin-jrpc/src/jrpc.ts","/Users/wuhuan/gif-portal-starter/node_modules/@toruslabs/base-controllers/node_modules/@toruslabs/openlogin-jrpc/src/jrpcEngine.ts","/Users/wuhuan/gif-portal-starter/node_modules/@toruslabs/base-controllers/node_modules/@toruslabs/openlogin-jrpc/src/substream.ts","/Users/wuhuan/gif-portal-starter/node_modules/@toruslabs/base-controllers/node_modules/@toruslabs/openlogin-jrpc/src/mux.ts","/Users/wuhuan/gif-portal-starter/node_modules/@toruslabs/base-controllers/node_modules/@toruslabs/openlogin-jrpc/src/postMessageStream.ts"],"sourcesContent":["import { Duplex } from \"readable-stream\";\n\nfunction noop(): void {\n  return undefined;\n}\n\nconst SYN = \"SYN\";\nconst ACK = \"ACK\";\nconst BRK = \"BRK\";\n\nexport default class BasePostMessageStream extends Duplex {\n  _init: boolean;\n\n  _haveSyn: boolean;\n\n  _name: string;\n\n  _target: string;\n\n  _targetWindow: Window;\n\n  _targetOrigin: string;\n\n  _onMessage: any;\n\n  _synIntervalId: number;\n\n  constructor({\n    name,\n    target,\n    targetWindow = window,\n    targetOrigin = \"*\",\n  }: {\n    name: string;\n    target: string;\n    targetWindow?: Window;\n    targetOrigin?: string;\n  }) {\n    super({\n      objectMode: true,\n    });\n    if (!name || !target) {\n      throw new Error(\"Invalid input.\");\n    }\n    this._init = false;\n    this._haveSyn = false;\n    this._name = name;\n    this._target = target; // target origin\n    this._targetWindow = targetWindow;\n    this._targetOrigin = targetOrigin;\n    this._onMessage = this.onMessage.bind(this);\n    this._synIntervalId = null;\n\n    window.addEventListener(\"message\", this._onMessage, false);\n    this._handShake();\n  }\n\n  _break(): void {\n    this.cork();\n    this._write(BRK, null, noop);\n    this._haveSyn = false;\n    this._init = false;\n  }\n\n  _handShake(): void {\n    this._write(SYN, null, noop);\n    this.cork();\n  }\n\n  _onData(data: unknown): void {\n    if (!this._init) {\n      // listen for handshake\n      if (data === SYN) {\n        this._haveSyn = true;\n        this._write(ACK, null, noop);\n      } else if (data === ACK) {\n        this._init = true;\n        if (!this._haveSyn) {\n          this._write(ACK, null, noop);\n        }\n        this.uncork();\n      }\n    } else if (data === BRK) {\n      this._break();\n    } else {\n      // forward message\n      try {\n        this.push(data);\n      } catch (err) {\n        this.emit(\"error\", err);\n      }\n    }\n  }\n\n  _postMessage(data: unknown): void {\n    const originConstraint = this._targetOrigin;\n    this._targetWindow.postMessage(\n      {\n        target: this._target,\n        data,\n      },\n      originConstraint\n    );\n  }\n\n  onMessage(event: MessageEvent): void {\n    const message = event.data;\n\n    // validate message\n    if (\n      (this._targetOrigin !== \"*\" && event.origin !== this._targetOrigin) ||\n      event.source !== this._targetWindow ||\n      typeof message !== \"object\" ||\n      message.target !== this._name ||\n      !message.data\n    ) {\n      return;\n    }\n\n    this._onData(message.data);\n  }\n\n  _read(): void {\n    return undefined;\n  }\n\n  _write(data: unknown, _, cb: () => void): void {\n    this._postMessage(data);\n    cb();\n  }\n\n  _destroy(): void {\n    window.removeEventListener(\"message\", this._onMessage, false);\n  }\n}\n","import { EventEmitter } from \"events\";\n\ntype Handler = (...args: any[]) => void;\ninterface EventMap {\n  [k: string]: Handler | Handler[] | undefined;\n}\n\nfunction safeApply<T, A extends any[]>(handler: (this: T, ...handlerArgs: A) => void, context: T, args: A): void {\n  try {\n    Reflect.apply(handler, context, args);\n  } catch (err) {\n    // Throw error after timeout so as not to interrupt the stack\n    setTimeout(() => {\n      throw err;\n    });\n  }\n}\n\nfunction arrayClone<T>(arr: T[]): T[] {\n  const n = arr.length;\n  const copy = new Array(n);\n  for (let i = 0; i < n; i += 1) {\n    copy[i] = arr[i];\n  }\n  return copy;\n}\n\nexport default class SafeEventEmitter extends EventEmitter {\n  emit(type: string, ...args: any[]): boolean {\n    let doError = type === \"error\";\n\n    const events: EventMap = (this as any)._events;\n    if (events !== undefined) {\n      doError = doError && events.error === undefined;\n    } else if (!doError) {\n      return false;\n    }\n\n    // If there is no 'error' event listener then throw.\n    if (doError) {\n      let er;\n      if (args.length > 0) {\n        [er] = args;\n      }\n      if (er instanceof Error) {\n        // Note: The comments on the `throw` lines are intentional, they show\n        // up in Node's output if this results in an unhandled exception.\n        throw er; // Unhandled 'error' event\n      }\n      // At least give some kind of context to the user\n      const err = new Error(`Unhandled error.${er ? ` (${er.message})` : \"\"}`);\n      (err as any).context = er;\n      throw err; // Unhandled 'error' event\n    }\n\n    const handler = events[type];\n\n    if (handler === undefined) {\n      return false;\n    }\n\n    if (typeof handler === \"function\") {\n      safeApply(handler, this, args);\n    } else {\n      const len = handler.length;\n      const listeners = arrayClone(handler);\n      for (let i = 0; i < len; i += 1) {\n        safeApply(listeners[i], this, args);\n      }\n    }\n\n    return true;\n  }\n}\n","import stringify from \"fast-safe-stringify\";\n\nexport default class SerializableError<T> extends Error {\n  public code: number;\n\n  public data: T;\n\n  constructor({ code, message, data }: { code: number; message: string; data?: T }) {\n    if (!Number.isInteger(code)) {\n      throw new Error(\"code must be an integer\");\n    }\n    if (!message || typeof message !== \"string\") {\n      throw new Error(\"message must be string\");\n    }\n\n    super(message);\n    this.code = code;\n    if (data !== undefined) {\n      this.data = data;\n    }\n  }\n\n  toString(): string {\n    return stringify({\n      code: this.code,\n      message: this.message,\n      data: this.data,\n      stack: this.stack,\n    });\n  }\n}\n","import { Duplex } from \"readable-stream\";\n\nimport { AsyncJRPCMiddleware, ConsoleLike, IdMap, JRPCMiddleware, JRPCRequest, JRPCResponse, Json, ReturnHandlerCallback } from \"./interfaces\";\nimport SafeEventEmitter from \"./safeEventEmitter\";\nimport SerializableError from \"./serializableError\";\n\nexport const getRpcPromiseCallback =\n  (resolve: (value?: any) => void, reject: (error?: Error) => void, unwrapResult = true) =>\n  (error: Error, response: JRPCResponse<unknown>): void => {\n    if (error || response.error) {\n      reject(error || response.error);\n    } else if (!unwrapResult || Array.isArray(response)) {\n      resolve(response);\n    } else {\n      resolve(response.result);\n    }\n  };\n\nexport function createErrorMiddleware(log: ConsoleLike): JRPCMiddleware<unknown, unknown> {\n  return (req, res, next, end) => {\n    try {\n      // json-rpc-engine will terminate the request when it notices this error\n      if (typeof req.method !== \"string\" || !req.method) {\n        res.error = new SerializableError({ code: -32603, message: \"invalid method\" });\n        end();\n        return;\n      }\n      next((done) => {\n        const { error } = res;\n        if (!error) {\n          return done();\n        }\n        log.error(`OpenLogin - RPC Error: ${error.message}`, error);\n        return done();\n      });\n    } catch (error) {\n      log.error(`OpenLogin - RPC Error thrown: ${error.message}`, error);\n      res.error = new SerializableError({ code: -32603, message: error.message });\n      end();\n    }\n  };\n}\n\nexport function createStreamMiddleware(): { events: SafeEventEmitter; middleware: JRPCMiddleware<unknown, unknown>; stream: Duplex } {\n  const idMap: IdMap = {};\n\n  function readNoop() {\n    return false;\n  }\n\n  const events = new SafeEventEmitter();\n\n  function processResponse(res: JRPCResponse<unknown>) {\n    const context = idMap[res.id as unknown as string];\n    if (!context) {\n      throw new Error(`StreamMiddleware - Unknown response id \"${res.id}\"`);\n    }\n\n    delete idMap[res.id as unknown as string];\n    // copy whole res onto original res\n    Object.assign(context.res, res);\n    // run callback on empty stack,\n    // prevent internal stream-handler from catching errors\n    setTimeout(context.end);\n  }\n\n  function processNotification(res: JRPCRequest<unknown>) {\n    events.emit(\"notification\", res);\n  }\n\n  function processMessage(res: JRPCResponse<unknown>, _encoding: unknown, cb: (error?: Error | null) => void) {\n    let err;\n    try {\n      const isNotification = !res.id;\n      if (isNotification) {\n        processNotification(res as unknown as JRPCRequest<unknown>);\n      } else {\n        processResponse(res);\n      }\n    } catch (_err) {\n      err = _err;\n    }\n    // continue processing stream\n    cb(err);\n  }\n\n  const stream = new Duplex({\n    objectMode: true,\n    read: readNoop,\n    write: processMessage,\n  });\n\n  const middleware: JRPCMiddleware<unknown, unknown> = (req, res, next, end) => {\n    // write req to stream\n    stream.push(req);\n    // register request on id map\n    idMap[req.id as unknown as string] = { req, res, next, end };\n  };\n\n  return { events, middleware, stream };\n}\n\ntype ScaffoldMiddlewareHandler<T, U> = JRPCMiddleware<T, U> | Json;\n\nexport function createScaffoldMiddleware(handlers: {\n  [methodName: string]: ScaffoldMiddlewareHandler<unknown, unknown>;\n}): JRPCMiddleware<unknown, unknown> {\n  return (req, res, next, end) => {\n    const handler = handlers[req.method];\n    // if no handler, return\n    if (handler === undefined) {\n      return next();\n    }\n    // if handler is fn, call as middleware\n    if (typeof handler === \"function\") {\n      return handler(req, res, next, end);\n    }\n    // if handler is some other value, use as result\n    res.result = handler;\n    return end();\n  };\n}\n\nexport function createIdRemapMiddleware(): JRPCMiddleware<unknown, unknown> {\n  return (req, res, next, _end) => {\n    const originalId = req.id;\n    const newId = Math.random().toString(36).slice(2);\n    req.id = newId;\n    res.id = newId;\n    next((done) => {\n      req.id = originalId;\n      res.id = originalId;\n      done();\n    });\n  };\n}\n\nexport function createLoggerMiddleware(logger: ConsoleLike): JRPCMiddleware<unknown, unknown> {\n  return (req, res, next, _) => {\n    logger.debug(\"REQ\", req, \"RES\", res);\n    next();\n  };\n}\n\nexport function createAsyncMiddleware<T, U>(asyncMiddleware: AsyncJRPCMiddleware<T, U>): JRPCMiddleware<T, U> {\n  return async (req, res, next, end) => {\n    // nextPromise is the key to the implementation\n    // it is resolved by the return handler passed to the\n    // \"next\" function\n    let resolveNextPromise: () => void;\n    const nextPromise = new Promise<void>((resolve) => {\n      resolveNextPromise = resolve;\n    });\n\n    let returnHandlerCallback: unknown = null;\n    let nextWasCalled = false;\n\n    // This will be called by the consumer's async middleware.\n    const asyncNext = async () => {\n      nextWasCalled = true;\n\n      // We pass a return handler to next(). When it is called by the engine,\n      // the consumer's async middleware will resume executing.\n\n      next((runReturnHandlersCallback) => {\n        // This callback comes from JRPCEngine._runReturnHandlers\n        returnHandlerCallback = runReturnHandlersCallback;\n        resolveNextPromise();\n      });\n      await nextPromise;\n    };\n\n    try {\n      await asyncMiddleware(req, res, asyncNext);\n\n      if (nextWasCalled) {\n        await nextPromise; // we must wait until the return handler is called\n        (returnHandlerCallback as ReturnHandlerCallback)(null);\n      } else {\n        end(null);\n      }\n    } catch (error) {\n      if (returnHandlerCallback) {\n        (returnHandlerCallback as ReturnHandlerCallback)(error);\n      } else {\n        end(error);\n      }\n    }\n  };\n}\n","import { rpcErrors, serializeError } from \"@metamask/rpc-errors\";\nimport { Duplex } from \"readable-stream\";\n\nimport {\n  JRPCEngineEndCallback,\n  JRPCEngineNextCallback,\n  JRPCEngineReturnHandler,\n  JRPCMiddleware,\n  JRPCRequest,\n  JRPCResponse,\n  Maybe,\n  RequestArguments,\n  SendCallBack,\n} from \"./interfaces\";\nimport SafeEventEmitter from \"./safeEventEmitter\";\nimport SerializableError from \"./serializableError\";\n\n/**\n * A JSON-RPC request and response processor.\n * Give it a stack of middleware, pass it requests, and get back responses.\n */\nexport class JRPCEngine extends SafeEventEmitter {\n  private _middleware: JRPCMiddleware<unknown, unknown>[];\n\n  constructor() {\n    super();\n    this._middleware = [];\n  }\n\n  /**\n   * Serially executes the given stack of middleware.\n   *\n   * @returns An array of any error encountered during middleware execution,\n   * a boolean indicating whether the request was completed, and an array of\n   * middleware-defined return handlers.\n   */\n  private static async _runAllMiddleware(\n    req: JRPCRequest<unknown>,\n    res: JRPCResponse<unknown>,\n    middlewareStack: JRPCMiddleware<unknown, unknown>[]\n  ): Promise<\n    [\n      unknown, // error\n      boolean, // isComplete\n      JRPCEngineReturnHandler[]\n    ]\n  > {\n    const returnHandlers: JRPCEngineReturnHandler[] = [];\n    let error = null;\n    let isComplete = false;\n\n    // Go down stack of middleware, call and collect optional returnHandlers\n    for (const middleware of middlewareStack) {\n      [error, isComplete] = await JRPCEngine._runMiddleware(req, res, middleware, returnHandlers);\n      if (isComplete) {\n        break;\n      }\n    }\n    return [error, isComplete, returnHandlers.reverse()];\n  }\n\n  /**\n   * Runs an individual middleware.\n   *\n   * @returns An array of any error encountered during middleware exection,\n   * and a boolean indicating whether the request should end.\n   */\n  private static _runMiddleware(\n    req: JRPCRequest<unknown>,\n    res: JRPCResponse<unknown>,\n    middleware: JRPCMiddleware<unknown, unknown>,\n    returnHandlers: JRPCEngineReturnHandler[]\n  ): Promise<[unknown, boolean]> {\n    return new Promise((resolve) => {\n      const end: JRPCEngineEndCallback = (err?: unknown) => {\n        const error = err || res.error;\n        if (error) {\n          res.error = serializeError(error);\n        }\n        // True indicates that the request should end\n        resolve([error, true]);\n      };\n\n      const next: JRPCEngineNextCallback = (returnHandler?: JRPCEngineReturnHandler) => {\n        if (res.error) {\n          end(res.error);\n        } else {\n          if (returnHandler) {\n            if (typeof returnHandler !== \"function\") {\n              end(new SerializableError({ code: -32603, message: \"JRPCEngine: 'next' return handlers must be functions\" }));\n            }\n            returnHandlers.push(returnHandler);\n          }\n\n          // False indicates that the request should not end\n          resolve([null, false]);\n        }\n      };\n\n      try {\n        middleware(req, res, next, end);\n      } catch (error) {\n        end(error);\n      }\n    });\n  }\n\n  /**\n   * Serially executes array of return handlers. The request and response are\n   * assumed to be in their scope.\n   */\n  private static async _runReturnHandlers(handlers: JRPCEngineReturnHandler[]): Promise<void> {\n    for (const handler of handlers) {\n      await new Promise<void>((resolve, reject) => {\n        handler((err) => (err ? reject(err) : resolve()));\n      });\n    }\n  }\n\n  /**\n   * Throws an error if the response has neither a result nor an error, or if\n   * the \"isComplete\" flag is falsy.\n   */\n  private static _checkForCompletion(req: JRPCRequest<unknown>, res: JRPCResponse<unknown>, isComplete: boolean): void {\n    if (!(\"result\" in res) && !(\"error\" in res)) {\n      throw new SerializableError({ code: -32603, message: \"Response has no error or result for request\" });\n    }\n    if (!isComplete) {\n      throw new SerializableError({ code: -32603, message: \"Nothing ended request\" });\n    }\n  }\n\n  /**\n   * Add a middleware function to the engine's middleware stack.\n   *\n   * @param middleware - The middleware function to add.\n   */\n  push<T, U>(middleware: JRPCMiddleware<T, U>): void {\n    this._middleware.push(middleware as JRPCMiddleware<unknown, unknown>);\n  }\n\n  /**\n   * Handle a JSON-RPC request, and return a response.\n   *\n   * @param request - The request to handle.\n   * @param callback - An error-first callback that will receive the response.\n   */\n  handle<T, U>(request: JRPCRequest<T>, callback: (error: unknown, response: JRPCResponse<U>) => void): void;\n\n  /**\n   * Handle an array of JSON-RPC requests, and return an array of responses.\n   *\n   * @param request - The requests to handle.\n   * @param callback - An error-first callback that will receive the array of\n   * responses.\n   */\n  handle<T, U>(requests: JRPCRequest<T>[], callback: (error: unknown, responses: JRPCResponse<U>[]) => void): void;\n\n  /**\n   * Handle a JSON-RPC request, and return a response.\n   *\n   * @param request - The request to handle.\n   * @returns A promise that resolves with the response, or rejects with an\n   * error.\n   */\n  handle<T, U>(request: JRPCRequest<T>): Promise<JRPCResponse<U>>;\n\n  /**\n   * Handle an array of JSON-RPC requests, and return an array of responses.\n   *\n   * @param request - The requests to handle.\n   * @returns A promise that resolves with the array of responses, or rejects\n   * with an error.\n   */\n  handle<T, U>(requests: JRPCRequest<T>[]): Promise<JRPCResponse<U>[]>;\n\n  handle(req: unknown, cb?: any) {\n    if (cb && typeof cb !== \"function\") {\n      throw new Error('\"callback\" must be a function if provided.');\n    }\n\n    if (Array.isArray(req)) {\n      if (cb) {\n        return this._handleBatch(req, cb);\n      }\n      return this._handleBatch(req);\n    }\n\n    if (cb) {\n      return this._handle(req as JRPCRequest<unknown>, cb);\n    }\n    return this._promiseHandle(req as JRPCRequest<unknown>);\n  }\n\n  /**\n   * Returns this engine as a middleware function that can be pushed to other\n   * engines.\n   *\n   * @returns This engine as a middleware function.\n   */\n  asMiddleware(): JRPCMiddleware<unknown, unknown> {\n    return async (req, res, next, end) => {\n      try {\n        const [middlewareError, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);\n\n        if (isComplete) {\n          await JRPCEngine._runReturnHandlers(returnHandlers);\n          return end(middlewareError as Error);\n        }\n\n        return next(async (handlerCallback) => {\n          try {\n            await JRPCEngine._runReturnHandlers(returnHandlers);\n          } catch (error) {\n            return handlerCallback(error);\n          }\n          return handlerCallback();\n        });\n      } catch (error) {\n        return end(error);\n      }\n    };\n  }\n\n  /**\n   * Like _handle, but for batch requests.\n   */\n  private _handleBatch(reqs: JRPCRequest<unknown>[]): Promise<JRPCResponse<unknown>[]>;\n\n  /**\n   * Like _handle, but for batch requests.\n   */\n  private _handleBatch(reqs: JRPCRequest<unknown>[], cb: (error: unknown, responses?: JRPCResponse<unknown>[]) => void): Promise<void>;\n\n  private async _handleBatch(\n    reqs: JRPCRequest<unknown>[],\n    cb?: (error: unknown, responses?: JRPCResponse<unknown>[]) => void\n  ): Promise<JRPCResponse<unknown>[] | void> {\n    // The order here is important\n    try {\n      // 2. Wait for all requests to finish, or throw on some kind of fatal\n      // error\n      const responses = await Promise.all(\n        // 1. Begin executing each request in the order received\n        reqs.map(this._promiseHandle.bind(this))\n      );\n\n      // 3. Return batch response\n      if (cb) {\n        return cb(null, responses);\n      }\n      return responses;\n    } catch (error) {\n      if (cb) {\n        return cb(error);\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * A promise-wrapped _handle.\n   */\n  private _promiseHandle(req: JRPCRequest<unknown>): Promise<JRPCResponse<unknown>> {\n    return new Promise((resolve) => {\n      this._handle(req, (_err, res) => {\n        // There will always be a response, and it will always have any error\n        // that is caught and propagated.\n        resolve(res);\n      });\n    });\n  }\n\n  /**\n   * Ensures that the request object is valid, processes it, and passes any\n   * error and the response object to the given callback.\n   *\n   * Does not reject.\n   */\n  private async _handle(callerReq: JRPCRequest<unknown>, cb: (error: unknown, response: JRPCResponse<unknown>) => void): Promise<void> {\n    if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== \"object\") {\n      const error = new SerializableError({ code: -32603, message: \"request must be plain object\" });\n      return cb(error, { id: undefined, jsonrpc: \"2.0\", error });\n    }\n\n    if (typeof callerReq.method !== \"string\") {\n      const error = new SerializableError({ code: -32603, message: \"method must be string\" });\n      return cb(error, { id: callerReq.id, jsonrpc: \"2.0\", error });\n    }\n\n    const req: JRPCRequest<unknown> = { ...callerReq };\n    const res: JRPCResponse<unknown> = {\n      id: req.id,\n      jsonrpc: req.jsonrpc,\n    };\n    let error: Error = null;\n\n    try {\n      await this._processRequest(req, res);\n    } catch (_error) {\n      // A request handler error, a re-thrown middleware error, or something\n      // unexpected.\n      error = _error;\n    }\n\n    if (error) {\n      // Ensure no result is present on an errored response\n      delete res.result;\n      if (!res.error) {\n        res.error = serializeError(error);\n      }\n    }\n\n    return cb(error, res as JRPCResponse<unknown>);\n  }\n\n  /**\n   * For the given request and response, runs all middleware and their return\n   * handlers, if any, and ensures that internal request processing semantics\n   * are satisfied.\n   */\n  private async _processRequest(req: JRPCRequest<unknown>, res: JRPCResponse<unknown>): Promise<void> {\n    const [error, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);\n\n    // Throw if \"end\" was not called, or if the response has neither a result\n    // nor an error.\n    JRPCEngine._checkForCompletion(req, res, isComplete);\n\n    // The return handlers should run even if an error was encountered during\n    // middleware processing.\n    await JRPCEngine._runReturnHandlers(returnHandlers);\n\n    // Now we re-throw the middleware processing error, if any, to catch it\n    // further up the call chain.\n    if (error) {\n      throw error;\n    }\n  }\n}\n\nexport function mergeMiddleware(middlewareStack: JRPCMiddleware<unknown, unknown>[]): JRPCMiddleware<unknown, unknown> {\n  const engine = new JRPCEngine();\n  middlewareStack.forEach((middleware) => engine.push(middleware));\n  return engine.asMiddleware();\n}\n\nexport interface EngineStreamOptions {\n  engine: JRPCEngine;\n}\n\nexport function createEngineStream(opts: EngineStreamOptions): Duplex {\n  if (!opts || !opts.engine) {\n    throw new Error(\"Missing engine parameter!\");\n  }\n\n  const { engine } = opts;\n  // eslint-disable-next-line prefer-const\n  let stream: Duplex;\n\n  function read() {\n    return undefined;\n  }\n\n  function write(req: JRPCRequest<unknown>, _encoding: unknown, cb: (error?: Error | null) => void) {\n    engine.handle(req, (_err, res) => {\n      stream.push(res);\n    });\n    cb();\n  }\n\n  stream = new Duplex({ objectMode: true, read, write });\n\n  // forward notifications\n  if (engine.on) {\n    engine.on(\"notification\", (message) => {\n      stream.push(message);\n    });\n  }\n  return stream;\n}\n\nexport interface SafeEventEmitterProvider extends SafeEventEmitter {\n  sendAsync: <T, U>(req: JRPCRequest<T>) => Promise<U>;\n  send: <T, U>(req: JRPCRequest<T>, callback: SendCallBack<U>) => void;\n  request: <T, U>(args: RequestArguments<T>) => Promise<Maybe<U>>;\n}\n\nexport function providerFromEngine(engine: JRPCEngine): SafeEventEmitterProvider {\n  const provider: SafeEventEmitterProvider = new SafeEventEmitter() as SafeEventEmitterProvider;\n  // handle both rpc send methods\n  provider.sendAsync = async <T, U>(req: JRPCRequest<T>) => {\n    const res = await engine.handle(req);\n    if (res.error) {\n      const err = serializeError(res.error, {\n        fallbackError: {\n          message: res.error?.message || res.error.toString(),\n          code: res.error?.code || -32603,\n        },\n      });\n\n      throw rpcErrors.internal(err);\n    }\n    return res.result as U;\n  };\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  provider.send = <T, U>(req: JRPCRequest<T>, callback: (error: any, providerRes: U) => void) => {\n    if (typeof callback !== \"function\") {\n      throw new Error('Must provide callback to \"send\" method.');\n    }\n    engine.handle(req, callback);\n  };\n  // forward notifications\n  if (engine.on) {\n    engine.on(\"notification\", (message: string) => {\n      provider.emit(\"data\", null, message);\n    });\n  }\n\n  provider.request = async <T, U>(args: RequestArguments<T>) => {\n    const req: JRPCRequest<T> = {\n      ...args,\n      id: Math.random().toString(36).slice(2),\n      jsonrpc: \"2.0\",\n    };\n    const res = await provider.sendAsync(req);\n    return res as U;\n  };\n  return provider;\n}\n\nexport function providerFromMiddleware(middleware: JRPCMiddleware<string[], unknown>): SafeEventEmitterProvider {\n  const engine = new JRPCEngine();\n  engine.push(middleware);\n  const provider: SafeEventEmitterProvider = providerFromEngine(engine);\n  return provider;\n}\n\nexport function providerAsMiddleware(provider: SafeEventEmitterProvider): JRPCMiddleware<unknown, unknown> {\n  return async (req, res, _next, end) => {\n    // send request to provider\n    try {\n      const providerRes: unknown = await provider.sendAsync<unknown, unknown>(req);\n      res.result = providerRes;\n      return end();\n    } catch (error) {\n      return end(error.message);\n    }\n  };\n}\n","import { Duplex } from \"readable-stream\";\n\nimport { BufferEncoding } from \"./interfaces\";\n\nexport default class Substream extends Duplex {\n  private readonly _parent: any;\n\n  private readonly _name: string;\n\n  constructor({ parent, name }: { parent: any; name: string }) {\n    super({ objectMode: true });\n    this._parent = parent;\n    this._name = name;\n  }\n\n  /**\n   * Explicitly sets read operations to a no-op.\n   */\n  _read(): void {\n    return undefined;\n  }\n\n  /**\n   * Called when data should be written to this writable stream.\n   *\n   * @param chunk - Arbitrary object to write\n   * @param encoding - Encoding to use when writing payload\n   * @param callback - Called when writing is complete or an error occurs\n   */\n  _write(chunk: unknown, _encoding: BufferEncoding, callback: (error?: Error | null) => void): void {\n    this._parent.push({\n      name: this._name,\n      data: chunk,\n    });\n    callback();\n  }\n}\n","import eos from \"end-of-stream\";\nimport once from \"once\";\nimport pump from \"pump\";\nimport { Duplex } from \"readable-stream\";\nimport type { Readable, Writable } from \"stream\";\n\nimport { BufferEncoding } from \"./interfaces\";\nimport Substream from \"./substream\";\n\nexport const IGNORE_SUBSTREAM = Symbol(\"IGNORE_SUBSTREAM\");\n\nexport type Stream = Readable | Writable;\n\ninterface Chunk {\n  name: string;\n  data: unknown;\n}\n\nexport class ObjectMultiplex extends Duplex {\n  public _substreams: Record<string, Substream | typeof IGNORE_SUBSTREAM>;\n\n  getStream: (name: string) => Substream | symbol;\n\n  constructor(opts: Record<string, unknown> = {}) {\n    super({\n      ...opts,\n      objectMode: true,\n    });\n    this._substreams = {};\n  }\n\n  createStream(name: string): Substream {\n    // validate name\n    if (!name) {\n      throw new Error(\"ObjectMultiplex - name must not be empty\");\n    }\n\n    if (this._substreams[name]) {\n      throw new Error(`ObjectMultiplex - Substream for name \"${name}\" already exists`);\n    }\n\n    // create substream\n    const substream = new Substream({ parent: this, name });\n    this._substreams[name] = substream;\n\n    // listen for parent stream to end\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    anyStreamEnd(this, (_error?: Error | null) => substream.destroy(_error || undefined));\n\n    return substream;\n  }\n\n  // ignore streams (dont display orphaned data warning)\n  ignoreStream(name: string): void {\n    // validate name\n    if (!name) {\n      throw new Error(\"ObjectMultiplex - name must not be empty\");\n    }\n    if (this._substreams[name]) {\n      throw new Error(`ObjectMultiplex - Substream for name \"${name}\" already exists`);\n    }\n    // set\n    this._substreams[name] = IGNORE_SUBSTREAM;\n  }\n\n  _read(): void {\n    return undefined;\n  }\n\n  _write(chunk: Chunk, _encoding: BufferEncoding, callback: (error?: Error | null) => void): void {\n    const { name, data } = chunk;\n\n    if (!name) {\n      window.console.warn(`ObjectMultiplex - malformed chunk without name \"${chunk}\"`);\n      return callback();\n    }\n\n    // get corresponding substream\n    const substream = this._substreams[name];\n    if (!substream) {\n      window.console.warn(`ObjectMultiplex - orphaned data for stream \"${name}\"`);\n      return callback();\n    }\n\n    // push data into substream\n    if (substream !== IGNORE_SUBSTREAM) {\n      substream.push(data);\n    }\n\n    return callback();\n  }\n}\n\n// util\nfunction anyStreamEnd(stream: ObjectMultiplex, _cb: (error?: Error | null) => void) {\n  const cb = once(_cb);\n  eos(stream as unknown as Stream, { readable: false }, cb);\n  eos(stream as unknown as Stream, { writable: false }, cb);\n}\n\nexport function setupMultiplex(stream: Duplex): ObjectMultiplex {\n  const mux = new ObjectMultiplex();\n  mux.getStream = function streamHelper(name: string) {\n    if (this._substreams[name]) {\n      return this._substreams[name];\n    }\n    return this.createStream(name);\n  };\n\n  pump(stream as unknown as Stream, mux as unknown as Stream, stream as unknown as Stream, (err) => {\n    if (err) window.console.error(err);\n  });\n  return mux;\n}\n","import BasePostMessageStream from \"./basePostMessageStream\";\n\nexport default class PostMessageStream extends BasePostMessageStream {\n  _postMessage(data: unknown): void {\n    let originConstraint = this._targetOrigin;\n    if (typeof data === \"object\") {\n      const dataObj = data as Record<string, unknown>;\n      if (typeof dataObj.data === \"object\") {\n        const dataObjData = dataObj.data as Record<string, unknown>;\n        if (Array.isArray(dataObjData.params) && dataObjData.params.length > 0) {\n          const dataObjDataParam = dataObjData.params[0] as Record<string, unknown>;\n          if (dataObjDataParam._origin) {\n            originConstraint = dataObjDataParam._origin as string;\n          }\n\n          // add a constraint for the response\n          dataObjDataParam._origin = window.location.origin;\n        }\n      }\n    }\n\n    this._targetWindow.postMessage(\n      {\n        target: this._target,\n        data,\n      },\n      originConstraint\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}