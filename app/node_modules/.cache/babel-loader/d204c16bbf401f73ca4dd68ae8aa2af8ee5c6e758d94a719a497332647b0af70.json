{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeIdlAccount = exports.decodeIdlAccount = exports.seed = exports.idlAddress = void 0;\nconst buffer_1 = require(\"buffer\");\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst borsh = __importStar(require(\"@project-serum/borsh\"));\n// Deterministic IDL address as a function of the program id.\nasync function idlAddress(programId) {\n  const base = (await web3_js_1.PublicKey.findProgramAddress([], programId))[0];\n  return await web3_js_1.PublicKey.createWithSeed(base, seed(), programId);\n}\nexports.idlAddress = idlAddress;\n// Seed for generating the idlAddress.\nfunction seed() {\n  return \"anchor:idl\";\n}\nexports.seed = seed;\nconst IDL_ACCOUNT_LAYOUT = borsh.struct([borsh.publicKey(\"authority\"), borsh.vecU8(\"data\")]);\nfunction decodeIdlAccount(data) {\n  return IDL_ACCOUNT_LAYOUT.decode(data);\n}\nexports.decodeIdlAccount = decodeIdlAccount;\nfunction encodeIdlAccount(acc) {\n  const buffer = buffer_1.Buffer.alloc(1000); // TODO: use a tighter buffer.\n  const len = IDL_ACCOUNT_LAYOUT.encode(acc, buffer);\n  return buffer.slice(0, len);\n}\nexports.encodeIdlAccount = encodeIdlAccount;","map":{"version":3,"names":["buffer_1","require","web3_js_1","borsh","__importStar","idlAddress","programId","base","PublicKey","findProgramAddress","createWithSeed","seed","exports","IDL_ACCOUNT_LAYOUT","struct","publicKey","vecU8","decodeIdlAccount","data","decode","encodeIdlAccount","acc","buffer","Buffer","alloc","len","encode","slice"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/idl.ts"],"sourcesContent":["import { Buffer } from \"buffer\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport * as borsh from \"@project-serum/borsh\";\n\nexport type Idl = {\n  version: string;\n  name: string;\n  instructions: IdlInstruction[];\n  state?: IdlState;\n  accounts?: IdlAccountDef[];\n  types?: IdlTypeDef[];\n  events?: IdlEvent[];\n  errors?: IdlErrorCode[];\n  constants?: IdlConstant[];\n  metadata?: IdlMetadata;\n};\n\nexport type IdlMetadata = any;\n\nexport type IdlConstant = {\n  name: string;\n  type: IdlType;\n  value: string;\n};\n\nexport type IdlEvent = {\n  name: string;\n  fields: IdlEventField[];\n};\n\nexport type IdlEventField = {\n  name: string;\n  type: IdlType;\n  index: boolean;\n};\n\nexport type IdlInstruction = {\n  name: string;\n  accounts: IdlAccountItem[];\n  args: IdlField[];\n  returns?: IdlType;\n};\n\nexport type IdlState = {\n  struct: IdlTypeDef;\n  methods: IdlStateMethod[];\n};\n\nexport type IdlStateMethod = IdlInstruction;\n\nexport type IdlAccountItem = IdlAccount | IdlAccounts;\n\nexport type IdlAccount = {\n  name: string;\n  isMut: boolean;\n  isSigner: boolean;\n  pda?: IdlPda;\n};\n\nexport type IdlPda = {\n  seeds: IdlSeed[];\n  programId?: IdlSeed;\n};\n\nexport type IdlSeed = any; // TODO\n\n// A nested/recursive version of IdlAccount.\nexport type IdlAccounts = {\n  name: string;\n  accounts: IdlAccountItem[];\n};\n\nexport type IdlField = {\n  name: string;\n  type: IdlType;\n};\n\nexport type IdlTypeDef = {\n  name: string;\n  type: IdlTypeDefTy;\n};\n\nexport type IdlAccountDef = {\n  name: string;\n  type: IdlTypeDefTyStruct;\n};\n\nexport type IdlTypeDefTyStruct = {\n  kind: \"struct\";\n  fields: IdlTypeDefStruct;\n};\n\nexport type IdlTypeDefTyEnum = {\n  kind: \"enum\";\n  variants: IdlEnumVariant[];\n};\n\ntype IdlTypeDefTy = IdlTypeDefTyEnum | IdlTypeDefTyStruct;\n\ntype IdlTypeDefStruct = Array<IdlField>;\n\nexport type IdlType =\n  | \"bool\"\n  | \"u8\"\n  | \"i8\"\n  | \"u16\"\n  | \"i16\"\n  | \"u32\"\n  | \"i32\"\n  | \"f32\"\n  | \"u64\"\n  | \"i64\"\n  | \"f64\"\n  | \"u128\"\n  | \"i128\"\n  | \"bytes\"\n  | \"string\"\n  | \"publicKey\"\n  | IdlTypeDefined\n  | IdlTypeOption\n  | IdlTypeCOption\n  | IdlTypeVec\n  | IdlTypeArray;\n\n// User defined type.\nexport type IdlTypeDefined = {\n  defined: string;\n};\n\nexport type IdlTypeOption = {\n  option: IdlType;\n};\n\nexport type IdlTypeCOption = {\n  coption: IdlType;\n};\n\nexport type IdlTypeVec = {\n  vec: IdlType;\n};\n\nexport type IdlTypeArray = {\n  array: [idlType: IdlType, size: number];\n};\n\nexport type IdlEnumVariant = {\n  name: string;\n  fields?: IdlEnumFields;\n};\n\ntype IdlEnumFields = IdlEnumFieldsNamed | IdlEnumFieldsTuple;\n\ntype IdlEnumFieldsNamed = IdlField[];\n\ntype IdlEnumFieldsTuple = IdlType[];\n\nexport type IdlErrorCode = {\n  code: number;\n  name: string;\n  msg?: string;\n};\n\n// Deterministic IDL address as a function of the program id.\nexport async function idlAddress(programId: PublicKey): Promise<PublicKey> {\n  const base = (await PublicKey.findProgramAddress([], programId))[0];\n  return await PublicKey.createWithSeed(base, seed(), programId);\n}\n\n// Seed for generating the idlAddress.\nexport function seed(): string {\n  return \"anchor:idl\";\n}\n\n// The on-chain account of the IDL.\nexport interface IdlProgramAccount {\n  authority: PublicKey;\n  data: Buffer;\n}\n\nconst IDL_ACCOUNT_LAYOUT: borsh.Layout<IdlProgramAccount> = borsh.struct([\n  borsh.publicKey(\"authority\"),\n  borsh.vecU8(\"data\"),\n]);\n\nexport function decodeIdlAccount(data: Buffer): IdlProgramAccount {\n  return IDL_ACCOUNT_LAYOUT.decode(data);\n}\n\nexport function encodeIdlAccount(acc: IdlProgramAccount): Buffer {\n  const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n  const len = IDL_ACCOUNT_LAYOUT.encode(acc, buffer);\n  return buffer.slice(0, len);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAAA,QAAA,GAAAC,OAAA;AACA,MAAAC,SAAA,GAAAD,OAAA;AACA,MAAAE,KAAA,GAAAC,YAAA,CAAAH,OAAA;AAgKA;AACO,eAAeI,UAAUA,CAACC,SAAoB;EACnD,MAAMC,IAAI,GAAG,CAAC,MAAML,SAAA,CAAAM,SAAS,CAACC,kBAAkB,CAAC,EAAE,EAAEH,SAAS,CAAC,EAAE,CAAC,CAAC;EACnE,OAAO,MAAMJ,SAAA,CAAAM,SAAS,CAACE,cAAc,CAACH,IAAI,EAAEI,IAAI,EAAE,EAAEL,SAAS,CAAC;AAChE;AAHAM,OAAA,CAAAP,UAAA,GAAAA,UAAA;AAKA;AACA,SAAgBM,IAAIA,CAAA;EAClB,OAAO,YAAY;AACrB;AAFAC,OAAA,CAAAD,IAAA,GAAAA,IAAA;AAUA,MAAME,kBAAkB,GAAoCV,KAAK,CAACW,MAAM,CAAC,CACvEX,KAAK,CAACY,SAAS,CAAC,WAAW,CAAC,EAC5BZ,KAAK,CAACa,KAAK,CAAC,MAAM,CAAC,CACpB,CAAC;AAEF,SAAgBC,gBAAgBA,CAACC,IAAY;EAC3C,OAAOL,kBAAkB,CAACM,MAAM,CAACD,IAAI,CAAC;AACxC;AAFAN,OAAA,CAAAK,gBAAA,GAAAA,gBAAA;AAIA,SAAgBG,gBAAgBA,CAACC,GAAsB;EACrD,MAAMC,MAAM,GAAGtB,QAAA,CAAAuB,MAAM,CAACC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;EACnC,MAAMC,GAAG,GAAGZ,kBAAkB,CAACa,MAAM,CAACL,GAAG,EAAEC,MAAM,CAAC;EAClD,OAAOA,MAAM,CAACK,KAAK,CAAC,CAAC,EAAEF,GAAG,CAAC;AAC7B;AAJAb,OAAA,CAAAQ,gBAAA,GAAAA,gBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}