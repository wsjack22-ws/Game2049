{"ast":null,"code":"/* global module */\n\n/**\n * Library for sampling of random values from a discrete probability distribution, \n * using the Walker-Vose alias method.\n *\n * Creates a new Sample instance for the given probabilities and outcomes.\n *\n * @param {Array} the probabilities.\n * @param {Array} the outcomes. Index is assumed as outcome if not provided.\n */\nfunction Sample(probabilities, outcomes, rng) {\n  'use strict';\n\n  this.alias = [];\n  this.prob = [];\n  this.outcomes = outcomes || this.indexedOutcomes(probabilities.length);\n  this.rng = rng || Math.random;\n  this.precomputeAlias(probabilities);\n}\n\n/**\n * Samples outcomes from the underlying probability distribution.\n *\n * @param {int} the number of samples. Optional parameter, defaults to 1.\n * @return {Object} a random outcome according to the underlying probability distribution \n *                  and the requested number of samples. If the requested number of samples \n *                  is greater than 1 this method returns an array.\n */\nSample.prototype.next = function (numOfSamples) {\n  'use strict';\n\n  var n = numOfSamples || 1,\n    out = [],\n    i = 0;\n  do {\n    var c = Math.floor(this.rng() * this.prob.length);\n    out[i] = this.outcomes[this.rng() < this.prob[c] ? c : this.alias[c]];\n  } while (++i < n);\n  return n > 1 ? out : out[0];\n};\n\n/**\n * Ported from ransampl.c\n * Scientific Computing Group of JCNS at MLZ Garching.\n * http://apps.jcns.fz-juelich.de/doku/sc/ransampl\n */\nSample.prototype.precomputeAlias = function (p) {\n  'use strict';\n\n  var n = p.length,\n    sum = 0,\n    nS = 0,\n    nL = 0,\n    P = [],\n    S = [],\n    L = [],\n    g,\n    i,\n    a;\n\n  // Normalize probabilities\n  for (i = 0; i < n; ++i) {\n    if (p[i] < 0) {\n      throw 'Probability must be a positive: p[' + i + ']=' + p[i];\n    }\n    sum += p[i];\n  }\n  if (sum === 0) {\n    throw 'Probability cannot be zero.';\n  }\n  for (i = 0; i < n; ++i) {\n    P[i] = p[i] * n / sum;\n  }\n\n  // Set separate index lists for small and large probabilities:\n  for (i = n - 1; i >= 0; --i) {\n    // at variance from Schwarz, we revert the index order\n    if (P[i] < 1) S[nS++] = i;else L[nL++] = i;\n  }\n\n  // Work through index lists\n  while (nS && nL) {\n    a = S[--nS]; // Schwarz's l\n    g = L[--nL]; // Schwarz's g\n\n    this.prob[a] = P[a];\n    this.alias[a] = g;\n    P[g] = P[g] + P[a] - 1;\n    if (P[g] < 1) S[nS++] = g;else L[nL++] = g;\n  }\n  while (nL) this.prob[L[--nL]] = 1;\n  while (nS)\n  // can only happen through numeric instability\n  this.prob[S[--nS]] = 1;\n};\nSample.prototype.indexedOutcomes = function (n) {\n  'use strict';\n\n  var o = [];\n  for (var i = 0; i < n; i++) o[i] = i;\n  return o;\n};\nSample.prototype.randomInt = function (min, max) {\n  'use strict';\n\n  return Math.floor(this.rng() * (max - min)) + min;\n};\nmodule.exports = function (probabilities, outcomes, rng) {\n  'use strict';\n\n  return new Sample(probabilities, outcomes, rng);\n};","map":{"version":3,"names":["Sample","probabilities","outcomes","rng","alias","prob","indexedOutcomes","length","Math","random","precomputeAlias","prototype","next","numOfSamples","n","out","i","c","floor","p","sum","nS","nL","P","S","L","g","a","o","randomInt","min","max","module","exports"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@apocentre/alias-sampling/index.js"],"sourcesContent":["/* global module */\n\n/**\n * Library for sampling of random values from a discrete probability distribution, \n * using the Walker-Vose alias method.\n *\n * Creates a new Sample instance for the given probabilities and outcomes.\n *\n * @param {Array} the probabilities.\n * @param {Array} the outcomes. Index is assumed as outcome if not provided.\n */\nfunction Sample(probabilities, outcomes, rng) {\n  'use strict';\n\n  this.alias = [];\n  this.prob  = [];\n  this.outcomes = outcomes || this.indexedOutcomes(probabilities.length);\n  this.rng = rng || Math.random\n  this.precomputeAlias(probabilities);\n}\n\n/**\n * Samples outcomes from the underlying probability distribution.\n *\n * @param {int} the number of samples. Optional parameter, defaults to 1.\n * @return {Object} a random outcome according to the underlying probability distribution \n *                  and the requested number of samples. If the requested number of samples \n *                  is greater than 1 this method returns an array.\n */\nSample.prototype.next = function (numOfSamples) {\n  'use strict';\n\n  var n   = numOfSamples || 1,\n      out = [],\n      i   = 0;\n\n  do {\n    var c = Math.floor(this.rng() * this.prob.length);\n    out[i] = this.outcomes[(this.rng() < this.prob[c]) ? c : this.alias[c]];\n  } while (++i < n);\n\n  return (n > 1) ? out : out[0];\n};\n\n/**\n * Ported from ransampl.c\n * Scientific Computing Group of JCNS at MLZ Garching.\n * http://apps.jcns.fz-juelich.de/doku/sc/ransampl\n */\nSample.prototype.precomputeAlias = function (p) {\n  'use strict';\n\n  var n   = p.length,\n      sum = 0,\n      nS  = 0,\n      nL  = 0,\n      P   = [],\n      S   = [],\n      L   = [],\n      g, i, a;\n\n  // Normalize probabilities\n  for (i = 0; i < n; ++i) {\n    if (p[i] < 0) {\n      throw 'Probability must be a positive: p[' + i + ']=' + p[i];\n    }\n    sum += p[i];\n  }\n\n  if (sum === 0) {\n    throw 'Probability cannot be zero.';\n  }\n\n  for (i = 0; i < n; ++i) {\n    P[i] = p[i] * n / sum;\n  }\n\n  // Set separate index lists for small and large probabilities:\n  for (i = n - 1; i >= 0; --i) {\n    // at variance from Schwarz, we revert the index order\n    if (P[i] < 1)\n      S[nS++] = i;\n    else\n      L[nL++] = i;\n  }\n\n  // Work through index lists\n  while (nS && nL) {\n    a = S[--nS]; // Schwarz's l\n    g = L[--nL]; // Schwarz's g\n\n    this.prob[a] = P[a];\n    this.alias[a] = g;\n\n    P[g] = P[g] + P[a] - 1;\n    if (P[g] < 1)\n      S[nS++] = g;\n    else\n      L[nL++] = g;\n  }\n\n  while (nL)\n    this.prob[L[--nL]] = 1;\n\n  while (nS)\n    // can only happen through numeric instability\n    this.prob[S[--nS]] = 1;\n};\n\nSample.prototype.indexedOutcomes = function (n) {\n  'use strict';\n\n  var o = [];\n  for (var i = 0; i < n; i++) o[i] = i;\n  return o;\n};\n\nSample.prototype.randomInt = function (min, max) {\n  'use strict';\n\n  return Math.floor(this.rng() * (max - min)) + min;\n};\n\nmodule.exports = function (probabilities, outcomes, rng) {\n  'use strict';\n\n  return new Sample(probabilities, outcomes, rng);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}