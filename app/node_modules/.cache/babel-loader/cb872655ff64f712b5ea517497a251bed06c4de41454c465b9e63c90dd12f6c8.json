{"ast":null,"code":"import assert from \"assert\";\nimport { PublicKey, Transaction, TransactionInstruction } from \"@solana/web3.js\";\nimport { chunks } from \"../utils/common\";\nimport { translateAddress } from \"../program/common\";\nimport { getProvider } from \"../provider\";\n/**\n * Sends a transaction to a program with the given accounts and instruction\n * data.\n */\nexport async function invoke(programId, accounts, data, provider) {\n  programId = translateAddress(programId);\n  if (!provider) {\n    provider = getProvider();\n  }\n  const tx = new Transaction();\n  tx.add(new TransactionInstruction({\n    programId,\n    keys: accounts !== null && accounts !== void 0 ? accounts : [],\n    data\n  }));\n  return await provider.send(tx);\n}\nconst GET_MULTIPLE_ACCOUNTS_LIMIT = 99;\nexport async function getMultipleAccounts(connection, publicKeys) {\n  if (publicKeys.length <= GET_MULTIPLE_ACCOUNTS_LIMIT) {\n    return await getMultipleAccountsCore(connection, publicKeys);\n  } else {\n    const batches = chunks(publicKeys, GET_MULTIPLE_ACCOUNTS_LIMIT);\n    const results = await Promise.all(batches.map(batch => getMultipleAccountsCore(connection, batch)));\n    return results.flat();\n  }\n}\nasync function getMultipleAccountsCore(connection, publicKeys) {\n  const args = [publicKeys.map(k => k.toBase58()), {\n    commitment: \"recent\"\n  }];\n  // @ts-ignore\n  const res = await connection._rpcRequest(\"getMultipleAccounts\", args);\n  if (res.error) {\n    throw new Error(\"failed to get info about accounts \" + publicKeys.map(k => k.toBase58()).join(\", \") + \": \" + res.error.message);\n  }\n  assert(typeof res.result !== \"undefined\");\n  const accounts = [];\n  for (const account of res.result.value) {\n    let value = null;\n    if (account === null) {\n      accounts.push(null);\n      continue;\n    }\n    if (res.result.value) {\n      const {\n        executable,\n        owner,\n        lamports,\n        data\n      } = account;\n      assert(data[1] === \"base64\");\n      value = {\n        executable,\n        owner: new PublicKey(owner),\n        lamports,\n        data: Buffer.from(data[0], \"base64\")\n      };\n    }\n    if (value === null) {\n      throw new Error(\"Invalid response\");\n    }\n    accounts.push(value);\n  }\n  return accounts.map((account, idx) => {\n    if (account === null) {\n      return null;\n    }\n    return {\n      publicKey: publicKeys[idx],\n      account\n    };\n  });\n}","map":{"version":3,"names":["assert","PublicKey","Transaction","TransactionInstruction","chunks","translateAddress","getProvider","invoke","programId","accounts","data","provider","tx","add","keys","send","GET_MULTIPLE_ACCOUNTS_LIMIT","getMultipleAccounts","connection","publicKeys","length","getMultipleAccountsCore","batches","results","Promise","all","map","batch","flat","args","k","toBase58","commitment","res","_rpcRequest","error","Error","join","message","result","account","value","push","executable","owner","lamports","Buffer","from","idx","publicKey"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/utils/rpc.ts"],"sourcesContent":["import assert from \"assert\";\nimport {\n  AccountInfo,\n  AccountMeta,\n  Connection,\n  PublicKey,\n  TransactionSignature,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport { chunks } from \"../utils/common\";\nimport { Address, translateAddress } from \"../program/common\";\nimport Provider, { getProvider } from \"../provider\";\n\n/**\n * Sends a transaction to a program with the given accounts and instruction\n * data.\n */\nexport async function invoke(\n  programId: Address,\n  accounts?: Array<AccountMeta>,\n  data?: Buffer,\n  provider?: Provider\n): Promise<TransactionSignature> {\n  programId = translateAddress(programId);\n  if (!provider) {\n    provider = getProvider();\n  }\n\n  const tx = new Transaction();\n  tx.add(\n    new TransactionInstruction({\n      programId,\n      keys: accounts ?? [],\n      data,\n    })\n  );\n\n  return await provider.send(tx);\n}\n\nconst GET_MULTIPLE_ACCOUNTS_LIMIT: number = 99;\n\nexport async function getMultipleAccounts(\n  connection: Connection,\n  publicKeys: PublicKey[]\n): Promise<\n  Array<null | { publicKey: PublicKey; account: AccountInfo<Buffer> }>\n> {\n  if (publicKeys.length <= GET_MULTIPLE_ACCOUNTS_LIMIT) {\n    return await getMultipleAccountsCore(connection, publicKeys);\n  } else {\n    const batches = chunks(publicKeys, GET_MULTIPLE_ACCOUNTS_LIMIT);\n    const results = await Promise.all<\n      Array<null | { publicKey: PublicKey; account: AccountInfo<Buffer> }>\n    >(batches.map((batch) => getMultipleAccountsCore(connection, batch)));\n    return results.flat();\n  }\n}\n\nasync function getMultipleAccountsCore(\n  connection: Connection,\n  publicKeys: PublicKey[]\n): Promise<\n  Array<null | { publicKey: PublicKey; account: AccountInfo<Buffer> }>\n> {\n  const args = [publicKeys.map((k) => k.toBase58()), { commitment: \"recent\" }];\n  // @ts-ignore\n  const res = await connection._rpcRequest(\"getMultipleAccounts\", args);\n  if (res.error) {\n    throw new Error(\n      \"failed to get info about accounts \" +\n        publicKeys.map((k) => k.toBase58()).join(\", \") +\n        \": \" +\n        res.error.message\n    );\n  }\n  assert(typeof res.result !== \"undefined\");\n  const accounts: Array<null | {\n    executable: any;\n    owner: PublicKey;\n    lamports: any;\n    data: Buffer;\n  }> = [];\n  for (const account of res.result.value) {\n    let value: {\n      executable: any;\n      owner: PublicKey;\n      lamports: any;\n      data: Buffer;\n    } | null = null;\n    if (account === null) {\n      accounts.push(null);\n      continue;\n    }\n    if (res.result.value) {\n      const { executable, owner, lamports, data } = account;\n      assert(data[1] === \"base64\");\n      value = {\n        executable,\n        owner: new PublicKey(owner),\n        lamports,\n        data: Buffer.from(data[0], \"base64\"),\n      };\n    }\n    if (value === null) {\n      throw new Error(\"Invalid response\");\n    }\n    accounts.push(value);\n  }\n  return accounts.map((account, idx) => {\n    if (account === null) {\n      return null;\n    }\n    return {\n      publicKey: publicKeys[idx],\n      account,\n    };\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}