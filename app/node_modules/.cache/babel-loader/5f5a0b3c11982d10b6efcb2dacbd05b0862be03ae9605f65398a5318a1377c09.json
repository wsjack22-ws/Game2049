{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InvalidStatusCodeError = exports.InvalidCertError = void 0;\nconst DEFAULT_OPT = Object.freeze({\n  redirect: true,\n  expectStatusCode: 200,\n  headers: {},\n  full: false,\n  keepAlive: true,\n  cors: false,\n  referrer: false,\n  sslAllowSelfSigned: false,\n  _redirectCount: 0\n});\nclass InvalidCertError extends Error {\n  constructor(msg, fingerprint256) {\n    super(msg);\n    this.fingerprint256 = fingerprint256;\n  }\n}\nexports.InvalidCertError = InvalidCertError;\nclass InvalidStatusCodeError extends Error {\n  constructor(statusCode) {\n    super(`Request Failed. Status Code: ${statusCode}`);\n    this.statusCode = statusCode;\n  }\n}\nexports.InvalidStatusCodeError = InvalidStatusCodeError;\nfunction detectType(b, type) {\n  if (!type || type === 'text' || type === 'json') {\n    try {\n      let text = new TextDecoder('utf8', {\n        fatal: true\n      }).decode(b);\n      if (type === 'text') return text;\n      try {\n        return JSON.parse(text);\n      } catch (err) {\n        if (type === 'json') throw err;\n        return text;\n      }\n    } catch (err) {\n      if (type === 'text' || type === 'json') throw err;\n    }\n  }\n  return b;\n}\nlet agents = {};\nfunction fetchNode(url, _options) {\n  let options = {\n    ...DEFAULT_OPT,\n    ..._options\n  };\n  const http = require('http');\n  const https = require('https');\n  const zlib = require('zlib');\n  const {\n    promisify\n  } = require('util');\n  const {\n    resolve: urlResolve\n  } = require('url');\n  const isSecure = !!/^https/.test(url);\n  let opts = {\n    method: options.method || 'GET',\n    headers: {\n      'Accept-Encoding': 'gzip, deflate, br'\n    }\n  };\n  const compactFP = s => s.replace(/:| /g, '').toLowerCase();\n  if (options.keepAlive) {\n    const agentOpt = {\n      keepAlive: true,\n      keepAliveMsecs: 30 * 1000,\n      maxFreeSockets: 1024,\n      maxCachedSessions: 1024\n    };\n    const agentKey = [isSecure, isSecure && options.sslPinnedCertificates?.map(i => compactFP(i)).sort()].join();\n    opts.agent = agents[agentKey] || (agents[agentKey] = new (isSecure ? https : http).Agent(agentOpt));\n  }\n  if (options.type === 'json') opts.headers['Content-Type'] = 'application/json';\n  if (options.data) {\n    if (!options.method) opts.method = 'POST';\n    opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n  }\n  opts.headers = {\n    ...opts.headers,\n    ...options.headers\n  };\n  if (options.sslAllowSelfSigned) opts.rejectUnauthorized = false;\n  const handleRes = async res => {\n    const status = res.statusCode;\n    if (options.redirect && 300 <= status && status < 400 && res.headers['location']) {\n      if (options._redirectCount == 10) throw new Error('Request failed. Too much redirects.');\n      options._redirectCount += 1;\n      return await fetchNode(urlResolve(url, res.headers['location']), options);\n    }\n    if (options.expectStatusCode && status !== options.expectStatusCode) {\n      res.resume();\n      throw new InvalidStatusCodeError(status);\n    }\n    let buf = [];\n    for await (const chunk of res) buf.push(chunk);\n    let bytes = Buffer.concat(buf);\n    const encoding = res.headers['content-encoding'];\n    if (encoding === 'br') bytes = await promisify(zlib.brotliDecompress)(bytes);\n    if (encoding === 'gzip' || encoding === 'deflate') bytes = await promisify(zlib.unzip)(bytes);\n    const body = detectType(bytes, options.type);\n    if (options.full) return {\n      headers: res.headers,\n      status,\n      body\n    };\n    return body;\n  };\n  return new Promise((resolve, reject) => {\n    const handleError = async err => {\n      if (err && err.code === 'DEPTH_ZERO_SELF_SIGNED_CERT') {\n        try {\n          await fetchNode(url, {\n            ...options,\n            sslAllowSelfSigned: true,\n            sslPinnedCertificates: []\n          });\n        } catch (e) {\n          if (e && e.fingerprint256) {\n            err = new InvalidCertError(`Self-signed SSL certificate: ${e.fingerprint256}`, e.fingerprint256);\n          }\n        }\n      }\n      reject(err);\n    };\n    const req = (isSecure ? https : http).request(url, opts, res => {\n      res.on('error', handleError);\n      (async () => {\n        try {\n          resolve(await handleRes(res));\n        } catch (error) {\n          reject(error);\n        }\n      })();\n    });\n    req.on('error', handleError);\n    const pinned = options.sslPinnedCertificates?.map(i => compactFP(i));\n    const mfetchSecureConnect = socket => {\n      const fp256 = compactFP(socket.getPeerCertificate()?.fingerprint256 || '');\n      if (!fp256 && socket.isSessionReused()) return;\n      if (pinned.includes(fp256)) return;\n      req.emit('error', new InvalidCertError(`Invalid SSL certificate: ${fp256} Expected: ${pinned}`, fp256));\n      return req.abort();\n    };\n    if (options.sslPinnedCertificates) {\n      req.on('socket', socket => {\n        const hasListeners = socket.listeners('secureConnect').map(i => (i.name || '').replace('bound ', '')).includes('mfetchSecureConnect');\n        if (hasListeners) return;\n        socket.on('secureConnect', mfetchSecureConnect.bind(null, socket));\n      });\n    }\n    if (options.keepAlive) req.setNoDelay(true);\n    if (opts.body) req.write(opts.body);\n    req.end();\n  });\n}\nconst SAFE_HEADERS = new Set(['Accept', 'Accept-Language', 'Content-Language', 'Content-Type'].map(i => i.toLowerCase()));\nconst FORBIDDEN_HEADERS = new Set(['Accept-Charset', 'Accept-Encoding', 'Access-Control-Request-Headers', 'Access-Control-Request-Method', 'Connection', 'Content-Length', 'Cookie', 'Cookie2', 'Date', 'DNT', 'Expect', 'Host', 'Keep-Alive', 'Origin', 'Referer', 'TE', 'Trailer', 'Transfer-Encoding', 'Upgrade', 'Via'].map(i => i.toLowerCase()));\nasync function fetchBrowser(url, _options) {\n  let options = {\n    ...DEFAULT_OPT,\n    ..._options\n  };\n  const headers = new Headers();\n  if (options.type === 'json') headers.set('Content-Type', 'application/json');\n  let parsed = new URL(url);\n  if (parsed.username) {\n    const auth = btoa(`${parsed.username}:${parsed.password}`);\n    headers.set('Authorization', `Basic ${auth}`);\n    parsed.username = '';\n    parsed.password = '';\n  }\n  url = '' + parsed;\n  for (let k in options.headers) {\n    const name = k.toLowerCase();\n    if (SAFE_HEADERS.has(name) || options.cors && !FORBIDDEN_HEADERS.has(name)) headers.set(k, options.headers[k]);\n  }\n  let opts = {\n    headers,\n    redirect: options.redirect ? 'follow' : 'manual'\n  };\n  if (!options.referrer) opts.referrerPolicy = 'no-referrer';\n  if (options.cors) opts.mode = 'cors';\n  if (options.data) {\n    if (!options.method) opts.method = 'POST';\n    opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n  }\n  const res = await fetch(url, opts);\n  if (options.expectStatusCode && res.status !== options.expectStatusCode) throw new InvalidStatusCodeError(res.status);\n  const body = detectType(new Uint8Array(await res.arrayBuffer()), options.type);\n  if (options.full) return {\n    headers: Object.fromEntries(res.headers.entries()),\n    status: res.status,\n    body\n  };\n  return body;\n}\nconst IS_NODE = !!(typeof process == 'object' && process.versions && process.versions.node && process.versions.v8);\nfunction fetchUrl(url, options) {\n  const fn = IS_NODE ? fetchNode : fetchBrowser;\n  return fn(url, options);\n}\nexports.default = fetchUrl;","map":{"version":3,"names":["Object","defineProperty","exports","value","InvalidStatusCodeError","InvalidCertError","DEFAULT_OPT","freeze","redirect","expectStatusCode","headers","full","keepAlive","cors","referrer","sslAllowSelfSigned","_redirectCount","Error","constructor","msg","fingerprint256","statusCode","detectType","b","type","text","TextDecoder","fatal","decode","JSON","parse","err","agents","fetchNode","url","_options","options","http","require","https","zlib","promisify","resolve","urlResolve","isSecure","test","opts","method","compactFP","s","replace","toLowerCase","agentOpt","keepAliveMsecs","maxFreeSockets","maxCachedSessions","agentKey","sslPinnedCertificates","map","i","sort","join","agent","Agent","data","body","stringify","rejectUnauthorized","handleRes","res","status","resume","buf","chunk","push","bytes","Buffer","concat","encoding","brotliDecompress","unzip","Promise","reject","handleError","code","e","req","request","on","error","pinned","mfetchSecureConnect","socket","fp256","getPeerCertificate","isSessionReused","includes","emit","abort","hasListeners","listeners","name","bind","setNoDelay","write","end","SAFE_HEADERS","Set","FORBIDDEN_HEADERS","fetchBrowser","Headers","set","parsed","URL","username","auth","btoa","password","k","has","referrerPolicy","mode","fetch","Uint8Array","arrayBuffer","fromEntries","entries","IS_NODE","process","versions","node","v8","fetchUrl","fn","default"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/micro-ftch/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InvalidStatusCodeError = exports.InvalidCertError = void 0;\nconst DEFAULT_OPT = Object.freeze({\n    redirect: true,\n    expectStatusCode: 200,\n    headers: {},\n    full: false,\n    keepAlive: true,\n    cors: false,\n    referrer: false,\n    sslAllowSelfSigned: false,\n    _redirectCount: 0,\n});\nclass InvalidCertError extends Error {\n    constructor(msg, fingerprint256) {\n        super(msg);\n        this.fingerprint256 = fingerprint256;\n    }\n}\nexports.InvalidCertError = InvalidCertError;\nclass InvalidStatusCodeError extends Error {\n    constructor(statusCode) {\n        super(`Request Failed. Status Code: ${statusCode}`);\n        this.statusCode = statusCode;\n    }\n}\nexports.InvalidStatusCodeError = InvalidStatusCodeError;\nfunction detectType(b, type) {\n    if (!type || type === 'text' || type === 'json') {\n        try {\n            let text = new TextDecoder('utf8', { fatal: true }).decode(b);\n            if (type === 'text')\n                return text;\n            try {\n                return JSON.parse(text);\n            }\n            catch (err) {\n                if (type === 'json')\n                    throw err;\n                return text;\n            }\n        }\n        catch (err) {\n            if (type === 'text' || type === 'json')\n                throw err;\n        }\n    }\n    return b;\n}\nlet agents = {};\nfunction fetchNode(url, _options) {\n    let options = { ...DEFAULT_OPT, ..._options };\n    const http = require('http');\n    const https = require('https');\n    const zlib = require('zlib');\n    const { promisify } = require('util');\n    const { resolve: urlResolve } = require('url');\n    const isSecure = !!/^https/.test(url);\n    let opts = {\n        method: options.method || 'GET',\n        headers: { 'Accept-Encoding': 'gzip, deflate, br' },\n    };\n    const compactFP = (s) => s.replace(/:| /g, '').toLowerCase();\n    if (options.keepAlive) {\n        const agentOpt = {\n            keepAlive: true,\n            keepAliveMsecs: 30 * 1000,\n            maxFreeSockets: 1024,\n            maxCachedSessions: 1024,\n        };\n        const agentKey = [\n            isSecure,\n            isSecure && options.sslPinnedCertificates?.map((i) => compactFP(i)).sort(),\n        ].join();\n        opts.agent =\n            agents[agentKey] || (agents[agentKey] = new (isSecure ? https : http).Agent(agentOpt));\n    }\n    if (options.type === 'json')\n        opts.headers['Content-Type'] = 'application/json';\n    if (options.data) {\n        if (!options.method)\n            opts.method = 'POST';\n        opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n    }\n    opts.headers = { ...opts.headers, ...options.headers };\n    if (options.sslAllowSelfSigned)\n        opts.rejectUnauthorized = false;\n    const handleRes = async (res) => {\n        const status = res.statusCode;\n        if (options.redirect && 300 <= status && status < 400 && res.headers['location']) {\n            if (options._redirectCount == 10)\n                throw new Error('Request failed. Too much redirects.');\n            options._redirectCount += 1;\n            return await fetchNode(urlResolve(url, res.headers['location']), options);\n        }\n        if (options.expectStatusCode && status !== options.expectStatusCode) {\n            res.resume();\n            throw new InvalidStatusCodeError(status);\n        }\n        let buf = [];\n        for await (const chunk of res)\n            buf.push(chunk);\n        let bytes = Buffer.concat(buf);\n        const encoding = res.headers['content-encoding'];\n        if (encoding === 'br')\n            bytes = await promisify(zlib.brotliDecompress)(bytes);\n        if (encoding === 'gzip' || encoding === 'deflate')\n            bytes = await promisify(zlib.unzip)(bytes);\n        const body = detectType(bytes, options.type);\n        if (options.full)\n            return { headers: res.headers, status, body };\n        return body;\n    };\n    return new Promise((resolve, reject) => {\n        const handleError = async (err) => {\n            if (err && err.code === 'DEPTH_ZERO_SELF_SIGNED_CERT') {\n                try {\n                    await fetchNode(url, { ...options, sslAllowSelfSigned: true, sslPinnedCertificates: [] });\n                }\n                catch (e) {\n                    if (e && e.fingerprint256) {\n                        err = new InvalidCertError(`Self-signed SSL certificate: ${e.fingerprint256}`, e.fingerprint256);\n                    }\n                }\n            }\n            reject(err);\n        };\n        const req = (isSecure ? https : http).request(url, opts, (res) => {\n            res.on('error', handleError);\n            (async () => {\n                try {\n                    resolve(await handleRes(res));\n                }\n                catch (error) {\n                    reject(error);\n                }\n            })();\n        });\n        req.on('error', handleError);\n        const pinned = options.sslPinnedCertificates?.map((i) => compactFP(i));\n        const mfetchSecureConnect = (socket) => {\n            const fp256 = compactFP(socket.getPeerCertificate()?.fingerprint256 || '');\n            if (!fp256 && socket.isSessionReused())\n                return;\n            if (pinned.includes(fp256))\n                return;\n            req.emit('error', new InvalidCertError(`Invalid SSL certificate: ${fp256} Expected: ${pinned}`, fp256));\n            return req.abort();\n        };\n        if (options.sslPinnedCertificates) {\n            req.on('socket', (socket) => {\n                const hasListeners = socket\n                    .listeners('secureConnect')\n                    .map((i) => (i.name || '').replace('bound ', ''))\n                    .includes('mfetchSecureConnect');\n                if (hasListeners)\n                    return;\n                socket.on('secureConnect', mfetchSecureConnect.bind(null, socket));\n            });\n        }\n        if (options.keepAlive)\n            req.setNoDelay(true);\n        if (opts.body)\n            req.write(opts.body);\n        req.end();\n    });\n}\nconst SAFE_HEADERS = new Set(['Accept', 'Accept-Language', 'Content-Language', 'Content-Type'].map((i) => i.toLowerCase()));\nconst FORBIDDEN_HEADERS = new Set(['Accept-Charset', 'Accept-Encoding', 'Access-Control-Request-Headers', 'Access-Control-Request-Method',\n    'Connection', 'Content-Length', 'Cookie', 'Cookie2', 'Date', 'DNT', 'Expect', 'Host', 'Keep-Alive', 'Origin', 'Referer', 'TE', 'Trailer',\n    'Transfer-Encoding', 'Upgrade', 'Via'].map((i) => i.toLowerCase()));\nasync function fetchBrowser(url, _options) {\n    let options = { ...DEFAULT_OPT, ..._options };\n    const headers = new Headers();\n    if (options.type === 'json')\n        headers.set('Content-Type', 'application/json');\n    let parsed = new URL(url);\n    if (parsed.username) {\n        const auth = btoa(`${parsed.username}:${parsed.password}`);\n        headers.set('Authorization', `Basic ${auth}`);\n        parsed.username = '';\n        parsed.password = '';\n    }\n    url = '' + parsed;\n    for (let k in options.headers) {\n        const name = k.toLowerCase();\n        if (SAFE_HEADERS.has(name) || (options.cors && !FORBIDDEN_HEADERS.has(name)))\n            headers.set(k, options.headers[k]);\n    }\n    let opts = { headers, redirect: options.redirect ? 'follow' : 'manual' };\n    if (!options.referrer)\n        opts.referrerPolicy = 'no-referrer';\n    if (options.cors)\n        opts.mode = 'cors';\n    if (options.data) {\n        if (!options.method)\n            opts.method = 'POST';\n        opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n    }\n    const res = await fetch(url, opts);\n    if (options.expectStatusCode && res.status !== options.expectStatusCode)\n        throw new InvalidStatusCodeError(res.status);\n    const body = detectType(new Uint8Array(await res.arrayBuffer()), options.type);\n    if (options.full)\n        return { headers: Object.fromEntries(res.headers.entries()), status: res.status, body };\n    return body;\n}\nconst IS_NODE = !!(typeof process == 'object' &&\n    process.versions &&\n    process.versions.node &&\n    process.versions.v8);\nfunction fetchUrl(url, options) {\n    const fn = IS_NODE ? fetchNode : fetchBrowser;\n    return fn(url, options);\n}\nexports.default = fetchUrl;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}