{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst error_js_1 = require(\"../../error.js\");\nconst common_js_1 = require(\"../common.js\");\nconst context_js_1 = require(\"../context.js\");\nconst features = __importStar(require(\"../../utils/features.js\"));\nclass InstructionNamespaceFactory {\n  static build(idlIx, encodeFn, programId) {\n    if (idlIx.name === \"_inner\") {\n      throw new error_js_1.IdlError(\"the _inner name is reserved\");\n    }\n    const ix = (...args) => {\n      const [ixArgs, ctx] = (0, context_js_1.splitArgsAndCtx)(idlIx, [...args]);\n      (0, common_js_1.validateAccounts)(idlIx.accounts, ctx.accounts);\n      validateInstruction(idlIx, ...args);\n      const keys = ix.accounts(ctx.accounts);\n      if (ctx.remainingAccounts !== undefined) {\n        keys.push(...ctx.remainingAccounts);\n      }\n      if (features.isSet(\"debug-logs\")) {\n        console.log(\"Outgoing account metas:\", keys);\n      }\n      return new web3_js_1.TransactionInstruction({\n        keys,\n        programId,\n        data: encodeFn(idlIx.name, (0, common_js_1.toInstruction)(idlIx, ...ixArgs))\n      });\n    };\n    // Utility fn for ordering the accounts for this instruction.\n    ix[\"accounts\"] = accs => {\n      return InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts, idlIx.name);\n    };\n    return ix;\n  }\n  static accountsArray(ctx, accounts, ixName) {\n    if (!ctx) {\n      return [];\n    }\n    return accounts.map(acc => {\n      // Nested accounts.\n      const nestedAccounts = \"accounts\" in acc ? acc.accounts : undefined;\n      if (nestedAccounts !== undefined) {\n        const rpcAccs = ctx[acc.name];\n        return InstructionNamespaceFactory.accountsArray(rpcAccs, acc.accounts, ixName).flat();\n      } else {\n        const account = acc;\n        let pubkey;\n        try {\n          pubkey = (0, common_js_1.translateAddress)(ctx[acc.name]);\n        } catch (err) {\n          throw new Error(`Wrong input type for account \"${acc.name}\" in the instruction accounts object${ixName !== undefined ? ' for instruction \"' + ixName + '\"' : \"\"}. Expected PublicKey or string.`);\n        }\n        return {\n          pubkey,\n          isWritable: account.isMut,\n          isSigner: account.isSigner\n        };\n      }\n    }).flat();\n  }\n}\nexports.default = InstructionNamespaceFactory;\n// Throws error if any argument required for the `ix` is not given.\nfunction validateInstruction(ix, ...args) {\n  // todo\n}","map":{"version":3,"names":["web3_js_1","require","error_js_1","common_js_1","context_js_1","features","__importStar","InstructionNamespaceFactory","build","idlIx","encodeFn","programId","name","IdlError","ix","args","ixArgs","ctx","splitArgsAndCtx","validateAccounts","accounts","validateInstruction","keys","remainingAccounts","undefined","push","isSet","console","log","TransactionInstruction","data","toInstruction","accs","accountsArray","ixName","map","acc","nestedAccounts","rpcAccs","flat","account","pubkey","translateAddress","err","Error","isWritable","isMut","isSigner","exports","default"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/program/namespace/instruction.ts"],"sourcesContent":["import {\n  AccountMeta,\n  PublicKey,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport {\n  Idl,\n  IdlAccount,\n  IdlAccountItem,\n  IdlAccounts,\n  IdlInstruction,\n} from \"../../idl.js\";\nimport { IdlError } from \"../../error.js\";\nimport {\n  toInstruction,\n  validateAccounts,\n  translateAddress,\n  Address,\n} from \"../common.js\";\nimport { Accounts, splitArgsAndCtx } from \"../context.js\";\nimport * as features from \"../../utils/features.js\";\nimport {\n  AllInstructions,\n  AllInstructionsMap,\n  InstructionContextFn,\n  InstructionContextFnArgs,\n  MakeInstructionsNamespace,\n} from \"./types.js\";\n\nexport default class InstructionNamespaceFactory {\n  public static build<IDL extends Idl, I extends AllInstructions<IDL>>(\n    idlIx: I,\n    encodeFn: InstructionEncodeFn<I>,\n    programId: PublicKey\n  ): InstructionFn<IDL, I> {\n    if (idlIx.name === \"_inner\") {\n      throw new IdlError(\"the _inner name is reserved\");\n    }\n\n    const ix = (\n      ...args: InstructionContextFnArgs<IDL, I>\n    ): TransactionInstruction => {\n      const [ixArgs, ctx] = splitArgsAndCtx(idlIx, [...args]);\n      validateAccounts(idlIx.accounts, ctx.accounts);\n      validateInstruction(idlIx, ...args);\n\n      const keys = ix.accounts(ctx.accounts);\n\n      if (ctx.remainingAccounts !== undefined) {\n        keys.push(...ctx.remainingAccounts);\n      }\n\n      if (features.isSet(\"debug-logs\")) {\n        console.log(\"Outgoing account metas:\", keys);\n      }\n\n      return new TransactionInstruction({\n        keys,\n        programId,\n        data: encodeFn(idlIx.name, toInstruction(idlIx, ...ixArgs)),\n      });\n    };\n\n    // Utility fn for ordering the accounts for this instruction.\n    ix[\"accounts\"] = (accs: Accounts<I[\"accounts\"][number]> | undefined) => {\n      return InstructionNamespaceFactory.accountsArray(\n        accs,\n        idlIx.accounts,\n        idlIx.name\n      );\n    };\n\n    return ix;\n  }\n\n  public static accountsArray(\n    ctx: Accounts | undefined,\n    accounts: readonly IdlAccountItem[],\n    ixName?: string\n  ): AccountMeta[] {\n    if (!ctx) {\n      return [];\n    }\n\n    return accounts\n      .map((acc: IdlAccountItem) => {\n        // Nested accounts.\n        const nestedAccounts: IdlAccountItem[] | undefined =\n          \"accounts\" in acc ? acc.accounts : undefined;\n        if (nestedAccounts !== undefined) {\n          const rpcAccs = ctx[acc.name] as Accounts;\n          return InstructionNamespaceFactory.accountsArray(\n            rpcAccs,\n            (acc as IdlAccounts).accounts,\n            ixName\n          ).flat();\n        } else {\n          const account: IdlAccount = acc as IdlAccount;\n          let pubkey;\n          try {\n            pubkey = translateAddress(ctx[acc.name] as Address);\n          } catch (err) {\n            throw new Error(\n              `Wrong input type for account \"${\n                acc.name\n              }\" in the instruction accounts object${\n                ixName !== undefined ? ' for instruction \"' + ixName + '\"' : \"\"\n              }. Expected PublicKey or string.`\n            );\n          }\n          return {\n            pubkey,\n            isWritable: account.isMut,\n            isSigner: account.isSigner,\n          };\n        }\n      })\n      .flat();\n  }\n}\n\n/**\n * The namespace provides functions to build [[TransactionInstruction]]\n * objects for each method of a program.\n *\n * ## Usage\n *\n * ```javascript\n * instruction.<method>(...args, ctx);\n * ```\n *\n * ## Parameters\n *\n * 1. `args` - The positional arguments for the program. The type and number\n *    of these arguments depend on the program being used.\n * 2. `ctx`  - [[Context]] non-argument parameters to pass to the method.\n *    Always the last parameter in the method call.\n *\n * ## Example\n *\n * To create an instruction for the `increment` method above,\n *\n * ```javascript\n * const tx = await program.instruction.increment({\n *   accounts: {\n *     counter,\n *   },\n * });\n * ```\n */\nexport type InstructionNamespace<\n  IDL extends Idl = Idl,\n  I extends IdlInstruction = IDL[\"instructions\"][number]\n> = MakeInstructionsNamespace<\n  IDL,\n  I,\n  TransactionInstruction,\n  {\n    [M in keyof AllInstructionsMap<IDL>]: {\n      accounts: (\n        ctx: Accounts<AllInstructionsMap<IDL>[M][\"accounts\"][number]>\n      ) => unknown;\n    };\n  }\n>;\n\n/**\n * Function to create a `TransactionInstruction` generated from an IDL.\n * Additionally it provides an `accounts` utility method, returning a list\n * of ordered accounts for the instruction.\n */\nexport type InstructionFn<\n  IDL extends Idl = Idl,\n  I extends AllInstructions<IDL> = AllInstructions<IDL>\n> = InstructionContextFn<IDL, I, TransactionInstruction> &\n  IxProps<Accounts<I[\"accounts\"][number]>>;\n\ntype IxProps<A extends Accounts> = {\n  /**\n   * Returns an ordered list of accounts associated with the instruction.\n   */\n  accounts: (ctx: A) => AccountMeta[];\n};\n\nexport type InstructionEncodeFn<I extends IdlInstruction = IdlInstruction> = (\n  ixName: I[\"name\"],\n  ix: any\n) => Buffer;\n\n// Throws error if any argument required for the `ix` is not given.\nfunction validateInstruction(ix: IdlInstruction, ...args: any[]) {\n  // todo\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}