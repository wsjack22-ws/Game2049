{"ast":null,"code":"import camelCase from \"camelcase\";\nimport EventEmitter from \"eventemitter3\";\nimport * as bs58 from \"bs58\";\nimport { SystemProgram } from \"@solana/web3.js\";\nimport Coder, { ACCOUNT_DISCRIMINATOR_SIZE, accountSize, AccountsCoder } from \"../../coder\";\nimport { translateAddress } from \"../common\";\nimport { getProvider } from \"../../\";\nimport * as pubkeyUtil from \"../../utils/pubkey\";\nimport * as rpcUtil from \"../../utils/rpc\";\nexport default class AccountFactory {\n  static build(idl, coder, programId, provider) {\n    var _a;\n    const accountFns = {};\n    (_a = idl.accounts) === null || _a === void 0 ? void 0 : _a.forEach(idlAccount => {\n      const name = camelCase(idlAccount.name);\n      accountFns[name] = new AccountClient(idl, idlAccount, programId, provider, coder);\n    });\n    return accountFns;\n  }\n}\nexport class AccountClient {\n  constructor(idl, idlAccount, programId, provider, coder) {\n    var _a;\n    this._idlAccount = idlAccount;\n    this._programId = programId;\n    this._provider = provider !== null && provider !== void 0 ? provider : getProvider();\n    this._coder = coder !== null && coder !== void 0 ? coder : new Coder(idl);\n    this._size = ACCOUNT_DISCRIMINATOR_SIZE + ((_a = accountSize(idl, idlAccount)) !== null && _a !== void 0 ? _a : 0);\n  }\n  /**\n   * Returns the number of bytes in this account.\n   */\n  get size() {\n    return this._size;\n  }\n  /**\n   * Returns the program ID owning all accounts.\n   */\n  get programId() {\n    return this._programId;\n  }\n  /**\n   * Returns the client's wallet and network provider.\n   */\n  get provider() {\n    return this._provider;\n  }\n  /**\n   * Returns the coder.\n   */\n  get coder() {\n    return this._coder;\n  }\n  /**\n   * Returns a deserialized account, returning null if it doesn't exist.\n   *\n   * @param address The address of the account to fetch.\n   */\n  async fetchNullable(address) {\n    const accountInfo = await this._provider.connection.getAccountInfo(translateAddress(address));\n    if (accountInfo === null) {\n      return null;\n    }\n    // Assert the account discriminator is correct.\n    const discriminator = AccountsCoder.accountDiscriminator(this._idlAccount.name);\n    if (discriminator.compare(accountInfo.data.slice(0, 8))) {\n      throw new Error(\"Invalid account discriminator\");\n    }\n    return this._coder.accounts.decode(this._idlAccount.name, accountInfo.data);\n  }\n  /**\n   * Returns a deserialized account.\n   *\n   * @param address The address of the account to fetch.\n   */\n  async fetch(address) {\n    const data = await this.fetchNullable(address);\n    if (data === null) {\n      throw new Error(`Account does not exist ${address.toString()}`);\n    }\n    return data;\n  }\n  /**\n   * Returns multiple deserialized accounts.\n   * Accounts not found or with wrong discriminator are returned as null.\n   *\n   * @param addresses The addresses of the accounts to fetch.\n   */\n  async fetchMultiple(addresses) {\n    const accounts = await rpcUtil.getMultipleAccounts(this._provider.connection, addresses.map(address => translateAddress(address)));\n    const discriminator = AccountsCoder.accountDiscriminator(this._idlAccount.name);\n    // Decode accounts where discriminator is correct, null otherwise\n    return accounts.map(account => {\n      if (account == null) {\n        return null;\n      }\n      if (discriminator.compare(account === null || account === void 0 ? void 0 : account.account.data.slice(0, 8))) {\n        return null;\n      }\n      return this._coder.accounts.decode(this._idlAccount.name, account === null || account === void 0 ? void 0 : account.account.data);\n    });\n  }\n  /**\n   * Returns all instances of this account type for the program.\n   *\n   * @param filters User-provided filters to narrow the results from `connection.getProgramAccounts`.\n   *\n   *                When filters are not defined this method returns all\n   *                the account instances.\n   *\n   *                When filters are of type `Buffer`, the filters are appended\n   *                after the discriminator.\n   *\n   *                When filters are of type `GetProgramAccountsFilter[]`,\n   *                filters are appended after the discriminator filter.\n   */\n  async all(filters) {\n    const discriminator = AccountsCoder.accountDiscriminator(this._idlAccount.name);\n    let resp = await this._provider.connection.getProgramAccounts(this._programId, {\n      commitment: this._provider.connection.commitment,\n      filters: [{\n        memcmp: {\n          offset: 0,\n          bytes: bs58.encode(filters instanceof Buffer ? Buffer.concat([discriminator, filters]) : discriminator)\n        }\n      }, ...(Array.isArray(filters) ? filters : [])]\n    });\n    return resp.map(({\n      pubkey,\n      account\n    }) => {\n      return {\n        publicKey: pubkey,\n        account: this._coder.accounts.decode(this._idlAccount.name, account.data)\n      };\n    });\n  }\n  /**\n   * Returns an `EventEmitter` emitting a \"change\" event whenever the account\n   * changes.\n   */\n  subscribe(address, commitment) {\n    const sub = subscriptions.get(address.toString());\n    if (sub) {\n      return sub.ee;\n    }\n    const ee = new EventEmitter();\n    address = translateAddress(address);\n    const listener = this._provider.connection.onAccountChange(address, acc => {\n      const account = this._coder.accounts.decode(this._idlAccount.name, acc.data);\n      ee.emit(\"change\", account);\n    }, commitment);\n    subscriptions.set(address.toString(), {\n      ee,\n      listener\n    });\n    return ee;\n  }\n  /**\n   * Unsubscribes from the account at the given address.\n   */\n  async unsubscribe(address) {\n    let sub = subscriptions.get(address.toString());\n    if (!sub) {\n      console.warn(\"Address is not subscribed\");\n      return;\n    }\n    if (subscriptions) {\n      await this._provider.connection.removeAccountChangeListener(sub.listener).then(() => {\n        subscriptions.delete(address.toString());\n      }).catch(console.error);\n    }\n  }\n  /**\n   * Returns an instruction for creating this account.\n   */\n  async createInstruction(signer, sizeOverride) {\n    const size = this.size;\n    return SystemProgram.createAccount({\n      fromPubkey: this._provider.wallet.publicKey,\n      newAccountPubkey: signer.publicKey,\n      space: sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size,\n      lamports: await this._provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size),\n      programId: this._programId\n    });\n  }\n  /**\n   * @deprecated since version 14.0.\n   *\n   * Function returning the associated account. Args are keys to associate.\n   * Order matters.\n   */\n  async associated(...args) {\n    const addr = await this.associatedAddress(...args);\n    return await this.fetch(addr);\n  }\n  /**\n   * @deprecated since version 14.0.\n   *\n   * Function returning the associated address. Args are keys to associate.\n   * Order matters.\n   */\n  async associatedAddress(...args) {\n    return await pubkeyUtil.associated(this._programId, ...args);\n  }\n}\n// Tracks all subscriptions.\nconst subscriptions = new Map();","map":{"version":3,"names":["camelCase","EventEmitter","bs58","SystemProgram","Coder","ACCOUNT_DISCRIMINATOR_SIZE","accountSize","AccountsCoder","translateAddress","getProvider","pubkeyUtil","rpcUtil","AccountFactory","build","idl","coder","programId","provider","accountFns","_a","accounts","forEach","idlAccount","name","AccountClient","constructor","_idlAccount","_programId","_provider","_coder","_size","size","fetchNullable","address","accountInfo","connection","getAccountInfo","discriminator","accountDiscriminator","compare","data","slice","Error","decode","fetch","toString","fetchMultiple","addresses","getMultipleAccounts","map","account","all","filters","resp","getProgramAccounts","commitment","memcmp","offset","bytes","encode","Buffer","concat","Array","isArray","pubkey","publicKey","subscribe","sub","subscriptions","get","ee","listener","onAccountChange","acc","emit","set","unsubscribe","console","warn","removeAccountChangeListener","then","delete","catch","error","createInstruction","signer","sizeOverride","createAccount","fromPubkey","wallet","newAccountPubkey","space","lamports","getMinimumBalanceForRentExemption","associated","args","addr","associatedAddress","Map"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/program/namespace/account.ts"],"sourcesContent":["import camelCase from \"camelcase\";\nimport EventEmitter from \"eventemitter3\";\nimport * as bs58 from \"bs58\";\nimport {\n  Signer,\n  PublicKey,\n  SystemProgram,\n  TransactionInstruction,\n  Commitment,\n  GetProgramAccountsFilter,\n} from \"@solana/web3.js\";\nimport Provider from \"../../provider\";\nimport { Idl, IdlTypeDef } from \"../../idl\";\nimport Coder, {\n  ACCOUNT_DISCRIMINATOR_SIZE,\n  accountSize,\n  AccountsCoder,\n} from \"../../coder\";\nimport { Subscription, Address, translateAddress } from \"../common\";\nimport { getProvider } from \"../../\";\nimport { AllAccountsMap, IdlTypes, TypeDef } from \"./types\";\nimport * as pubkeyUtil from \"../../utils/pubkey\";\nimport * as rpcUtil from \"../../utils/rpc\";\n\nexport default class AccountFactory {\n  public static build<IDL extends Idl>(\n    idl: IDL,\n    coder: Coder,\n    programId: PublicKey,\n    provider?: Provider\n  ): AccountNamespace<IDL> {\n    const accountFns: AccountNamespace = {};\n\n    idl.accounts?.forEach((idlAccount) => {\n      const name = camelCase(idlAccount.name);\n      accountFns[name] = new AccountClient<IDL>(\n        idl,\n        idlAccount,\n        programId,\n        provider,\n        coder\n      );\n    });\n\n    return accountFns as AccountNamespace<IDL>;\n  }\n}\n\ntype NullableIdlAccount<IDL extends Idl> = IDL[\"accounts\"] extends undefined\n  ? IdlTypeDef\n  : NonNullable<IDL[\"accounts\"]>[number];\n\n/**\n * The namespace provides handles to an [[AccountClient]] object for each\n * account in a program.\n *\n * ## Usage\n *\n * ```javascript\n * account.<account-client>\n * ```\n *\n * ## Example\n *\n * To fetch a `Counter` account from the above example,\n *\n * ```javascript\n * const counter = await program.account.counter.fetch(address);\n * ```\n *\n * For the full API, see the [[AccountClient]] reference.\n */\nexport type AccountNamespace<IDL extends Idl = Idl> = {\n  [M in keyof AllAccountsMap<IDL>]: AccountClient<IDL>;\n};\n\nexport class AccountClient<\n  IDL extends Idl = Idl,\n  A extends NullableIdlAccount<IDL> = IDL[\"accounts\"] extends undefined\n    ? IdlTypeDef\n    : NonNullable<IDL[\"accounts\"]>[number],\n  T = TypeDef<A, IdlTypes<IDL>>\n> {\n  /**\n   * Returns the number of bytes in this account.\n   */\n  get size(): number {\n    return this._size;\n  }\n  private _size: number;\n\n  /**\n   * Returns the program ID owning all accounts.\n   */\n  get programId(): PublicKey {\n    return this._programId;\n  }\n  private _programId: PublicKey;\n\n  /**\n   * Returns the client's wallet and network provider.\n   */\n  get provider(): Provider {\n    return this._provider;\n  }\n  private _provider: Provider;\n\n  /**\n   * Returns the coder.\n   */\n  get coder(): Coder {\n    return this._coder;\n  }\n  private _coder: Coder;\n\n  private _idlAccount: A;\n\n  constructor(\n    idl: IDL,\n    idlAccount: A,\n    programId: PublicKey,\n    provider?: Provider,\n    coder?: Coder\n  ) {\n    this._idlAccount = idlAccount;\n    this._programId = programId;\n    this._provider = provider ?? getProvider();\n    this._coder = coder ?? new Coder(idl);\n    this._size =\n      ACCOUNT_DISCRIMINATOR_SIZE + (accountSize(idl, idlAccount) ?? 0);\n  }\n\n  /**\n   * Returns a deserialized account, returning null if it doesn't exist.\n   *\n   * @param address The address of the account to fetch.\n   */\n  async fetchNullable(address: Address): Promise<T | null> {\n    const accountInfo = await this._provider.connection.getAccountInfo(\n      translateAddress(address)\n    );\n    if (accountInfo === null) {\n      return null;\n    }\n\n    // Assert the account discriminator is correct.\n    const discriminator = AccountsCoder.accountDiscriminator(\n      this._idlAccount.name\n    );\n    if (discriminator.compare(accountInfo.data.slice(0, 8))) {\n      throw new Error(\"Invalid account discriminator\");\n    }\n\n    return this._coder.accounts.decode<T>(\n      this._idlAccount.name,\n      accountInfo.data\n    );\n  }\n\n  /**\n   * Returns a deserialized account.\n   *\n   * @param address The address of the account to fetch.\n   */\n  async fetch(address: Address): Promise<T> {\n    const data = await this.fetchNullable(address);\n    if (data === null) {\n      throw new Error(`Account does not exist ${address.toString()}`);\n    }\n    return data;\n  }\n\n  /**\n   * Returns multiple deserialized accounts.\n   * Accounts not found or with wrong discriminator are returned as null.\n   *\n   * @param addresses The addresses of the accounts to fetch.\n   */\n  async fetchMultiple(addresses: Address[]): Promise<(Object | null)[]> {\n    const accounts = await rpcUtil.getMultipleAccounts(\n      this._provider.connection,\n      addresses.map((address) => translateAddress(address))\n    );\n\n    const discriminator = AccountsCoder.accountDiscriminator(\n      this._idlAccount.name\n    );\n    // Decode accounts where discriminator is correct, null otherwise\n    return accounts.map((account) => {\n      if (account == null) {\n        return null;\n      }\n      if (discriminator.compare(account?.account.data.slice(0, 8))) {\n        return null;\n      }\n      return this._coder.accounts.decode(\n        this._idlAccount.name,\n        account?.account.data\n      );\n    });\n  }\n\n  /**\n   * Returns all instances of this account type for the program.\n   *\n   * @param filters User-provided filters to narrow the results from `connection.getProgramAccounts`.\n   *\n   *                When filters are not defined this method returns all\n   *                the account instances.\n   *\n   *                When filters are of type `Buffer`, the filters are appended\n   *                after the discriminator.\n   *\n   *                When filters are of type `GetProgramAccountsFilter[]`,\n   *                filters are appended after the discriminator filter.\n   */\n  async all(\n    filters?: Buffer | GetProgramAccountsFilter[]\n  ): Promise<ProgramAccount<T>[]> {\n    const discriminator = AccountsCoder.accountDiscriminator(\n      this._idlAccount.name\n    );\n\n    let resp = await this._provider.connection.getProgramAccounts(\n      this._programId,\n      {\n        commitment: this._provider.connection.commitment,\n        filters: [\n          {\n            memcmp: {\n              offset: 0,\n              bytes: bs58.encode(\n                filters instanceof Buffer\n                  ? Buffer.concat([discriminator, filters])\n                  : discriminator\n              ),\n            },\n          },\n          ...(Array.isArray(filters) ? filters : []),\n        ],\n      }\n    );\n    return resp.map(({ pubkey, account }) => {\n      return {\n        publicKey: pubkey,\n        account: this._coder.accounts.decode(\n          this._idlAccount.name,\n          account.data\n        ),\n      };\n    });\n  }\n\n  /**\n   * Returns an `EventEmitter` emitting a \"change\" event whenever the account\n   * changes.\n   */\n  subscribe(address: Address, commitment?: Commitment): EventEmitter {\n    const sub = subscriptions.get(address.toString());\n    if (sub) {\n      return sub.ee;\n    }\n\n    const ee = new EventEmitter();\n    address = translateAddress(address);\n    const listener = this._provider.connection.onAccountChange(\n      address,\n      (acc) => {\n        const account = this._coder.accounts.decode(\n          this._idlAccount.name,\n          acc.data\n        );\n        ee.emit(\"change\", account);\n      },\n      commitment\n    );\n\n    subscriptions.set(address.toString(), {\n      ee,\n      listener,\n    });\n\n    return ee;\n  }\n\n  /**\n   * Unsubscribes from the account at the given address.\n   */\n  async unsubscribe(address: Address) {\n    let sub = subscriptions.get(address.toString());\n    if (!sub) {\n      console.warn(\"Address is not subscribed\");\n      return;\n    }\n    if (subscriptions) {\n      await this._provider.connection\n        .removeAccountChangeListener(sub.listener)\n        .then(() => {\n          subscriptions.delete(address.toString());\n        })\n        .catch(console.error);\n    }\n  }\n\n  /**\n   * Returns an instruction for creating this account.\n   */\n  async createInstruction(\n    signer: Signer,\n    sizeOverride?: number\n  ): Promise<TransactionInstruction> {\n    const size = this.size;\n\n    return SystemProgram.createAccount({\n      fromPubkey: this._provider.wallet.publicKey,\n      newAccountPubkey: signer.publicKey,\n      space: sizeOverride ?? size,\n      lamports: await this._provider.connection.getMinimumBalanceForRentExemption(\n        sizeOverride ?? size\n      ),\n      programId: this._programId,\n    });\n  }\n\n  /**\n   * @deprecated since version 14.0.\n   *\n   * Function returning the associated account. Args are keys to associate.\n   * Order matters.\n   */\n  async associated(...args: Array<PublicKey | Buffer>): Promise<T> {\n    const addr = await this.associatedAddress(...args);\n    return await this.fetch(addr);\n  }\n\n  /**\n   * @deprecated since version 14.0.\n   *\n   * Function returning the associated address. Args are keys to associate.\n   * Order matters.\n   */\n  async associatedAddress(\n    ...args: Array<PublicKey | Buffer>\n  ): Promise<PublicKey> {\n    return await pubkeyUtil.associated(this._programId, ...args);\n  }\n}\n\n/**\n * @hidden\n *\n * Deserialized account owned by a program.\n */\nexport type ProgramAccount<T = any> = {\n  publicKey: PublicKey;\n  account: T;\n};\n\n// Tracks all subscriptions.\nconst subscriptions: Map<string, Subscription> = new Map();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}