{"ast":null,"code":"export function splitArgsAndCtx(idlIx, args) {\n  var _a, _b;\n  let options = {};\n  const inputLen = idlIx.args ? idlIx.args.length : 0;\n  if (args.length > inputLen) {\n    if (args.length !== inputLen + 1) {\n      throw new Error(`provided too many arguments ${args} to instruction ${idlIx === null || idlIx === void 0 ? void 0 : idlIx.name} expecting: ${(_b = (_a = idlIx.args) === null || _a === void 0 ? void 0 : _a.map(a => a.name)) !== null && _b !== void 0 ? _b : []}`);\n    }\n    options = args.pop();\n  }\n  return [args, options];\n}","map":{"version":3,"names":["splitArgsAndCtx","idlIx","args","options","inputLen","length","Error","name","_b","_a","map","a","pop"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/program/context.ts"],"sourcesContent":["import {\n  AccountMeta,\n  Signer,\n  ConfirmOptions,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport { Address } from \"./common\";\nimport { IdlAccountItem, IdlAccounts, IdlInstruction } from \"../idl\";\n\n/**\n * Context provides all non-argument inputs for generating Anchor transactions.\n */\nexport type Context<A extends Accounts = Accounts> = {\n  /**\n   * Accounts used in the instruction context.\n   */\n  accounts?: A;\n\n  /**\n   * All accounts to pass into an instruction *after* the main `accounts`.\n   * This can be used for optional or otherwise unknown accounts.\n   */\n  remainingAccounts?: AccountMeta[];\n\n  /**\n   * Accounts that must sign a given transaction.\n   */\n  signers?: Array<Signer>;\n\n  /**\n   * Instructions to run *before* a given method. Often this is used, for\n   * example to create accounts prior to executing a method.\n   */\n  instructions?: TransactionInstruction[];\n\n  /**\n   * Commitment parameters to use for a transaction.\n   */\n  options?: ConfirmOptions;\n\n  /**\n   * @hidden\n   *\n   * Private namespace for development.\n   */\n  __private?: { logAccounts: boolean };\n};\n\n/**\n * A set of accounts mapping one-to-one to the program's accounts struct, i.e.,\n * the type deriving `#[derive(Accounts)]`.\n *\n * The name of each field should match the name for that account in the IDL.\n *\n * If multiple accounts are nested in the rust program, then they should be\n * nested here.\n */\nexport type Accounts<A extends IdlAccountItem = IdlAccountItem> = {\n  [N in A[\"name\"]]: Account<A & { name: N }>;\n};\n\ntype Account<A extends IdlAccountItem> = A extends IdlAccounts\n  ? Accounts<A[\"accounts\"][number]>\n  : Address;\n\nexport function splitArgsAndCtx(\n  idlIx: IdlInstruction,\n  args: any[]\n): [any[], Context] {\n  let options = {};\n\n  const inputLen = idlIx.args ? idlIx.args.length : 0;\n  if (args.length > inputLen) {\n    if (args.length !== inputLen + 1) {\n      throw new Error(\n        `provided too many arguments ${args} to instruction ${\n          idlIx?.name\n        } expecting: ${idlIx.args?.map((a) => a.name) ?? []}`\n      );\n    }\n    options = args.pop();\n  }\n\n  return [args, options];\n}\n"],"mappings":"AAiEA,OAAM,SAAUA,eAAeA,CAC7BC,KAAqB,EACrBC,IAAW;;EAEX,IAAIC,OAAO,GAAG,EAAE;EAEhB,MAAMC,QAAQ,GAAGH,KAAK,CAACC,IAAI,GAAGD,KAAK,CAACC,IAAI,CAACG,MAAM,GAAG,CAAC;EACnD,IAAIH,IAAI,CAACG,MAAM,GAAGD,QAAQ,EAAE;IAC1B,IAAIF,IAAI,CAACG,MAAM,KAAKD,QAAQ,GAAG,CAAC,EAAE;MAChC,MAAM,IAAIE,KAAK,CACb,+BAA+BJ,IAAI,mBACjCD,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEM,IACT,eAAe,CAAAC,EAAA,IAAAC,EAAA,GAAAR,KAAK,CAACC,IAAI,cAAAO,EAAA,uBAAAA,EAAA,CAAEC,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAACJ,IAAI,CAAC,cAAAC,EAAA,cAAAA,EAAA,GAAI,EAAE,EAAE,CACtD;;IAEHL,OAAO,GAAGD,IAAI,CAACU,GAAG,EAAE;;EAGtB,OAAO,CAACV,IAAI,EAAEC,OAAO,CAAC;AACxB"},"metadata":{},"sourceType":"module","externalDependencies":[]}