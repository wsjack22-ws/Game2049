{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getProvider = exports.setProvider = exports.AnchorProvider = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst index_js_1 = require(\"./utils/bytes/index.js\");\nconst common_js_1 = require(\"./utils/common.js\");\nconst rpc_js_1 = require(\"./utils/rpc.js\");\n/**\n * The network and wallet context used to send transactions paid for and signed\n * by the provider.\n */\nclass AnchorProvider {\n  /**\n   * @param connection The cluster connection where the program is deployed.\n   * @param wallet     The wallet used to pay for and sign all transactions.\n   * @param opts       Transaction confirmation options to use by default.\n   */\n  constructor(connection, wallet, opts) {\n    this.connection = connection;\n    this.wallet = wallet;\n    this.opts = opts;\n  }\n  static defaultOptions() {\n    return {\n      preflightCommitment: \"processed\",\n      commitment: \"processed\"\n    };\n  }\n  /**\n   * Returns a `Provider` with a wallet read from the local filesystem.\n   *\n   * @param url  The network cluster url.\n   * @param opts The default transaction confirmation options.\n   *\n   * (This api is for Node only.)\n   */\n  static local(url, opts) {\n    if (common_js_1.isBrowser) {\n      throw new Error(`Provider local is not available on browser.`);\n    }\n    opts = opts !== null && opts !== void 0 ? opts : AnchorProvider.defaultOptions();\n    const connection = new web3_js_1.Connection(url !== null && url !== void 0 ? url : \"http://localhost:8899\", opts.preflightCommitment);\n    const NodeWallet = require(\"./nodewallet.js\").default;\n    const wallet = NodeWallet.local();\n    return new AnchorProvider(connection, wallet, opts);\n  }\n  /**\n   * Returns a `Provider` read from the `ANCHOR_PROVIDER_URL` environment\n   * variable\n   *\n   * (This api is for Node only.)\n   */\n  static env() {\n    if (common_js_1.isBrowser) {\n      throw new Error(`Provider env is not available on browser.`);\n    }\n    const process = require(\"process\");\n    const url = process.env.ANCHOR_PROVIDER_URL;\n    if (url === undefined) {\n      throw new Error(\"ANCHOR_PROVIDER_URL is not defined\");\n    }\n    const options = AnchorProvider.defaultOptions();\n    const connection = new web3_js_1.Connection(url, options.commitment);\n    const NodeWallet = require(\"./nodewallet.js\").default;\n    const wallet = NodeWallet.local();\n    return new AnchorProvider(connection, wallet, options);\n  }\n  /**\n   * Sends the given transaction, paid for and signed by the provider's wallet.\n   *\n   * @param tx      The transaction to send.\n   * @param signers The signers of the transaction.\n   * @param opts    Transaction confirmation options.\n   */\n  async sendAndConfirm(tx, signers, opts) {\n    var _a;\n    if (opts === undefined) {\n      opts = this.opts;\n    }\n    tx.feePayer = this.wallet.publicKey;\n    tx.recentBlockhash = (await this.connection.getRecentBlockhash(opts.preflightCommitment)).blockhash;\n    tx = await this.wallet.signTransaction(tx);\n    (signers !== null && signers !== void 0 ? signers : []).forEach(kp => {\n      tx.partialSign(kp);\n    });\n    const rawTx = tx.serialize();\n    try {\n      return await sendAndConfirmRawTransaction(this.connection, rawTx, opts);\n    } catch (err) {\n      // thrown if the underlying 'confirmTransaction' encounters a failed tx\n      // the 'confirmTransaction' error does not return logs so we make another rpc call to get them\n      if (err instanceof ConfirmError) {\n        // choose the shortest available commitment for 'getTransaction'\n        // (the json RPC does not support any shorter than \"confirmed\" for 'getTransaction')\n        // because that will see the tx sent with `sendAndConfirmRawTransaction` no matter which\n        // commitment `sendAndConfirmRawTransaction` used\n        const failedTx = await this.connection.getTransaction(index_js_1.bs58.encode(tx.signature), {\n          commitment: \"confirmed\"\n        });\n        if (!failedTx) {\n          throw err;\n        } else {\n          const logs = (_a = failedTx.meta) === null || _a === void 0 ? void 0 : _a.logMessages;\n          throw !logs ? err : new web3_js_1.SendTransactionError(err.message, logs);\n        }\n      } else {\n        throw err;\n      }\n    }\n  }\n  /**\n   * Similar to `send`, but for an array of transactions and signers.\n   */\n  async sendAll(txWithSigners, opts) {\n    if (opts === undefined) {\n      opts = this.opts;\n    }\n    const blockhash = await this.connection.getRecentBlockhash(opts.preflightCommitment);\n    let txs = txWithSigners.map(r => {\n      var _a;\n      let tx = r.tx;\n      let signers = (_a = r.signers) !== null && _a !== void 0 ? _a : [];\n      tx.feePayer = this.wallet.publicKey;\n      tx.recentBlockhash = blockhash.blockhash;\n      signers.forEach(kp => {\n        tx.partialSign(kp);\n      });\n      return tx;\n    });\n    const signedTxs = await this.wallet.signAllTransactions(txs);\n    const sigs = [];\n    for (let k = 0; k < txs.length; k += 1) {\n      const tx = signedTxs[k];\n      const rawTx = tx.serialize();\n      sigs.push(await sendAndConfirmRawTransaction(this.connection, rawTx, opts));\n    }\n    return sigs;\n  }\n  /**\n   * Simulates the given transaction, returning emitted logs from execution.\n   *\n   * @param tx      The transaction to send.\n   * @param signers The signers of the transaction.\n   * @param opts    Transaction confirmation options.\n   */\n  async simulate(tx, signers, commitment, includeAccounts) {\n    tx.feePayer = this.wallet.publicKey;\n    tx.recentBlockhash = (await this.connection.getLatestBlockhash(commitment !== null && commitment !== void 0 ? commitment : this.connection.commitment)).blockhash;\n    tx = await this.wallet.signTransaction(tx);\n    const result = await (0, rpc_js_1.simulateTransaction)(this.connection, tx, signers, commitment, includeAccounts);\n    if (result.value.err) {\n      throw new SimulateError(result.value);\n    }\n    return result.value;\n  }\n}\nexports.AnchorProvider = AnchorProvider;\nclass SimulateError extends Error {\n  constructor(simulationResponse, message) {\n    super(message);\n    this.simulationResponse = simulationResponse;\n  }\n}\n// Copy of Connection.sendAndConfirmRawTransaction that throws\n// a better error if 'confirmTransaction` returns an error status\nasync function sendAndConfirmRawTransaction(connection, rawTransaction, options) {\n  const sendOptions = options && {\n    skipPreflight: options.skipPreflight,\n    preflightCommitment: options.preflightCommitment || options.commitment\n  };\n  const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);\n  const status = (await connection.confirmTransaction(signature, options && options.commitment)).value;\n  if (status.err) {\n    throw new ConfirmError(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);\n  }\n  return signature;\n}\nclass ConfirmError extends Error {\n  constructor(message) {\n    super(message);\n  }\n}\n/**\n * Sets the default provider on the client.\n */\nfunction setProvider(provider) {\n  _provider = provider;\n}\nexports.setProvider = setProvider;\n/**\n * Returns the default provider being used by the client.\n */\nfunction getProvider() {\n  if (_provider === null) {\n    return AnchorProvider.local();\n  }\n  return _provider;\n}\nexports.getProvider = getProvider;\n// Global provider used as the default when a provider is not given.\nlet _provider = null;","map":{"version":3,"names":["web3_js_1","require","index_js_1","common_js_1","rpc_js_1","AnchorProvider","constructor","connection","wallet","opts","defaultOptions","preflightCommitment","commitment","local","url","isBrowser","Error","Connection","NodeWallet","default","env","process","ANCHOR_PROVIDER_URL","undefined","options","sendAndConfirm","tx","signers","feePayer","publicKey","recentBlockhash","getRecentBlockhash","blockhash","signTransaction","forEach","kp","partialSign","rawTx","serialize","sendAndConfirmRawTransaction","err","ConfirmError","failedTx","getTransaction","bs58","encode","signature","logs","_a","meta","logMessages","SendTransactionError","message","sendAll","txWithSigners","txs","map","r","signedTxs","signAllTransactions","sigs","k","length","push","simulate","includeAccounts","getLatestBlockhash","result","simulateTransaction","value","SimulateError","exports","simulationResponse","rawTransaction","sendOptions","skipPreflight","sendRawTransaction","status","confirmTransaction","JSON","stringify","setProvider","provider","_provider","getProvider"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/provider.ts"],"sourcesContent":["import {\n  Connection,\n  Signer,\n  PublicKey,\n  Transaction,\n  TransactionSignature,\n  ConfirmOptions,\n  SimulatedTransactionResponse,\n  Commitment,\n  SendTransactionError,\n  SendOptions,\n  RpcResponseAndContext,\n} from \"@solana/web3.js\";\nimport { bs58 } from \"./utils/bytes/index.js\";\nimport { isBrowser } from \"./utils/common.js\";\nimport {\n  simulateTransaction,\n  SuccessfulTxSimulationResponse,\n} from \"./utils/rpc.js\";\n\nexport default interface Provider {\n  readonly connection: Connection;\n\n  send?(\n    tx: Transaction,\n    signers?: Signer[],\n    opts?: SendOptions\n  ): Promise<TransactionSignature>;\n  sendAndConfirm?(\n    tx: Transaction,\n    signers?: Signer[],\n    opts?: ConfirmOptions\n  ): Promise<TransactionSignature>;\n  sendAll?(\n    txWithSigners: { tx: Transaction; signers?: Signer[] }[],\n    opts?: ConfirmOptions\n  ): Promise<Array<TransactionSignature>>;\n  simulate?(\n    tx: Transaction,\n    signers?: Signer[],\n    commitment?: Commitment,\n    includeAccounts?: boolean | PublicKey[]\n  ): Promise<SuccessfulTxSimulationResponse>;\n}\n\n/**\n * The network and wallet context used to send transactions paid for and signed\n * by the provider.\n */\nexport class AnchorProvider implements Provider {\n  /**\n   * @param connection The cluster connection where the program is deployed.\n   * @param wallet     The wallet used to pay for and sign all transactions.\n   * @param opts       Transaction confirmation options to use by default.\n   */\n  constructor(\n    readonly connection: Connection,\n    readonly wallet: Wallet,\n    readonly opts: ConfirmOptions\n  ) {}\n\n  static defaultOptions(): ConfirmOptions {\n    return {\n      preflightCommitment: \"processed\",\n      commitment: \"processed\",\n    };\n  }\n\n  /**\n   * Returns a `Provider` with a wallet read from the local filesystem.\n   *\n   * @param url  The network cluster url.\n   * @param opts The default transaction confirmation options.\n   *\n   * (This api is for Node only.)\n   */\n  static local(url?: string, opts?: ConfirmOptions): AnchorProvider {\n    if (isBrowser) {\n      throw new Error(`Provider local is not available on browser.`);\n    }\n    opts = opts ?? AnchorProvider.defaultOptions();\n    const connection = new Connection(\n      url ?? \"http://localhost:8899\",\n      opts.preflightCommitment\n    );\n    const NodeWallet = require(\"./nodewallet.js\").default;\n    const wallet = NodeWallet.local();\n    return new AnchorProvider(connection, wallet, opts);\n  }\n\n  /**\n   * Returns a `Provider` read from the `ANCHOR_PROVIDER_URL` environment\n   * variable\n   *\n   * (This api is for Node only.)\n   */\n  static env(): AnchorProvider {\n    if (isBrowser) {\n      throw new Error(`Provider env is not available on browser.`);\n    }\n\n    const process = require(\"process\");\n    const url = process.env.ANCHOR_PROVIDER_URL;\n    if (url === undefined) {\n      throw new Error(\"ANCHOR_PROVIDER_URL is not defined\");\n    }\n    const options = AnchorProvider.defaultOptions();\n    const connection = new Connection(url, options.commitment);\n    const NodeWallet = require(\"./nodewallet.js\").default;\n    const wallet = NodeWallet.local();\n\n    return new AnchorProvider(connection, wallet, options);\n  }\n\n  /**\n   * Sends the given transaction, paid for and signed by the provider's wallet.\n   *\n   * @param tx      The transaction to send.\n   * @param signers The signers of the transaction.\n   * @param opts    Transaction confirmation options.\n   */\n  async sendAndConfirm(\n    tx: Transaction,\n    signers?: Signer[],\n    opts?: ConfirmOptions\n  ): Promise<TransactionSignature> {\n    if (opts === undefined) {\n      opts = this.opts;\n    }\n\n    tx.feePayer = this.wallet.publicKey;\n    tx.recentBlockhash = (\n      await this.connection.getRecentBlockhash(opts.preflightCommitment)\n    ).blockhash;\n\n    tx = await this.wallet.signTransaction(tx);\n    (signers ?? []).forEach((kp) => {\n      tx.partialSign(kp);\n    });\n\n    const rawTx = tx.serialize();\n\n    try {\n      return await sendAndConfirmRawTransaction(this.connection, rawTx, opts);\n    } catch (err) {\n      // thrown if the underlying 'confirmTransaction' encounters a failed tx\n      // the 'confirmTransaction' error does not return logs so we make another rpc call to get them\n      if (err instanceof ConfirmError) {\n        // choose the shortest available commitment for 'getTransaction'\n        // (the json RPC does not support any shorter than \"confirmed\" for 'getTransaction')\n        // because that will see the tx sent with `sendAndConfirmRawTransaction` no matter which\n        // commitment `sendAndConfirmRawTransaction` used\n        const failedTx = await this.connection.getTransaction(\n          bs58.encode(tx.signature!),\n          { commitment: \"confirmed\" }\n        );\n        if (!failedTx) {\n          throw err;\n        } else {\n          const logs = failedTx.meta?.logMessages;\n          throw !logs ? err : new SendTransactionError(err.message, logs);\n        }\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Similar to `send`, but for an array of transactions and signers.\n   */\n  async sendAll(\n    txWithSigners: { tx: Transaction; signers?: Signer[] }[],\n    opts?: ConfirmOptions\n  ): Promise<Array<TransactionSignature>> {\n    if (opts === undefined) {\n      opts = this.opts;\n    }\n    const blockhash = await this.connection.getRecentBlockhash(\n      opts.preflightCommitment\n    );\n\n    let txs = txWithSigners.map((r) => {\n      let tx = r.tx;\n      let signers = r.signers ?? [];\n\n      tx.feePayer = this.wallet.publicKey;\n      tx.recentBlockhash = blockhash.blockhash;\n\n      signers.forEach((kp) => {\n        tx.partialSign(kp);\n      });\n\n      return tx;\n    });\n\n    const signedTxs = await this.wallet.signAllTransactions(txs);\n\n    const sigs: TransactionSignature[] = [];\n\n    for (let k = 0; k < txs.length; k += 1) {\n      const tx = signedTxs[k];\n      const rawTx = tx.serialize();\n      sigs.push(\n        await sendAndConfirmRawTransaction(this.connection, rawTx, opts)\n      );\n    }\n\n    return sigs;\n  }\n\n  /**\n   * Simulates the given transaction, returning emitted logs from execution.\n   *\n   * @param tx      The transaction to send.\n   * @param signers The signers of the transaction.\n   * @param opts    Transaction confirmation options.\n   */\n  async simulate(\n    tx: Transaction,\n    signers?: Signer[],\n    commitment?: Commitment,\n    includeAccounts?: boolean | PublicKey[]\n  ): Promise<SuccessfulTxSimulationResponse> {\n    tx.feePayer = this.wallet.publicKey;\n    tx.recentBlockhash = (\n      await this.connection.getLatestBlockhash(\n        commitment ?? this.connection.commitment\n      )\n    ).blockhash;\n\n    tx = await this.wallet.signTransaction(tx);\n    const result = await simulateTransaction(\n      this.connection,\n      tx,\n      signers,\n      commitment,\n      includeAccounts\n    );\n\n    if (result.value.err) {\n      throw new SimulateError(result.value);\n    }\n\n    return result.value;\n  }\n}\n\nclass SimulateError extends Error {\n  constructor(\n    readonly simulationResponse: SimulatedTransactionResponse,\n    message?: string\n  ) {\n    super(message);\n  }\n}\n\nexport type SendTxRequest = {\n  tx: Transaction;\n  signers: Array<Signer | undefined>;\n};\n\n/**\n * Wallet interface for objects that can be used to sign provider transactions.\n */\nexport interface Wallet {\n  signTransaction(tx: Transaction): Promise<Transaction>;\n  signAllTransactions(txs: Transaction[]): Promise<Transaction[]>;\n  publicKey: PublicKey;\n}\n\n// Copy of Connection.sendAndConfirmRawTransaction that throws\n// a better error if 'confirmTransaction` returns an error status\nasync function sendAndConfirmRawTransaction(\n  connection: Connection,\n  rawTransaction: Buffer,\n  options?: ConfirmOptions\n): Promise<TransactionSignature> {\n  const sendOptions = options && {\n    skipPreflight: options.skipPreflight,\n    preflightCommitment: options.preflightCommitment || options.commitment,\n  };\n\n  const signature = await connection.sendRawTransaction(\n    rawTransaction,\n    sendOptions\n  );\n\n  const status = (\n    await connection.confirmTransaction(\n      signature,\n      options && options.commitment\n    )\n  ).value;\n\n  if (status.err) {\n    throw new ConfirmError(\n      `Raw transaction ${signature} failed (${JSON.stringify(status)})`\n    );\n  }\n\n  return signature;\n}\n\nclass ConfirmError extends Error {\n  constructor(message?: string) {\n    super(message);\n  }\n}\n\n/**\n * Sets the default provider on the client.\n */\nexport function setProvider(provider: Provider) {\n  _provider = provider;\n}\n\n/**\n * Returns the default provider being used by the client.\n */\nexport function getProvider(): Provider {\n  if (_provider === null) {\n    return AnchorProvider.local();\n  }\n  return _provider;\n}\n\n// Global provider used as the default when a provider is not given.\nlet _provider: Provider | null = null;\n"],"mappings":";;;;;;AAAA,MAAAA,SAAA,GAAAC,OAAA;AAaA,MAAAC,UAAA,GAAAD,OAAA;AACA,MAAAE,WAAA,GAAAF,OAAA;AACA,MAAAG,QAAA,GAAAH,OAAA;AA8BA;;;;AAIA,MAAaI,cAAc;EACzB;;;;;EAKAC,YACWC,UAAsB,EACtBC,MAAc,EACdC,IAAoB;IAFpB,KAAAF,UAAU,GAAVA,UAAU;IACV,KAAAC,MAAM,GAANA,MAAM;IACN,KAAAC,IAAI,GAAJA,IAAI;EACZ;EAEH,OAAOC,cAAcA,CAAA;IACnB,OAAO;MACLC,mBAAmB,EAAE,WAAW;MAChCC,UAAU,EAAE;KACb;EACH;EAEA;;;;;;;;EAQA,OAAOC,KAAKA,CAACC,GAAY,EAAEL,IAAqB;IAC9C,IAAIN,WAAA,CAAAY,SAAS,EAAE;MACb,MAAM,IAAIC,KAAK,CAAC,6CAA6C,CAAC;;IAEhEP,IAAI,GAAGA,IAAI,aAAJA,IAAI,cAAJA,IAAI,GAAIJ,cAAc,CAACK,cAAc,EAAE;IAC9C,MAAMH,UAAU,GAAG,IAAIP,SAAA,CAAAiB,UAAU,CAC/BH,GAAG,aAAHA,GAAG,cAAHA,GAAG,GAAI,uBAAuB,EAC9BL,IAAI,CAACE,mBAAmB,CACzB;IACD,MAAMO,UAAU,GAAGjB,OAAO,CAAC,iBAAiB,CAAC,CAACkB,OAAO;IACrD,MAAMX,MAAM,GAAGU,UAAU,CAACL,KAAK,EAAE;IACjC,OAAO,IAAIR,cAAc,CAACE,UAAU,EAAEC,MAAM,EAAEC,IAAI,CAAC;EACrD;EAEA;;;;;;EAMA,OAAOW,GAAGA,CAAA;IACR,IAAIjB,WAAA,CAAAY,SAAS,EAAE;MACb,MAAM,IAAIC,KAAK,CAAC,2CAA2C,CAAC;;IAG9D,MAAMK,OAAO,GAAGpB,OAAO,CAAC,SAAS,CAAC;IAClC,MAAMa,GAAG,GAAGO,OAAO,CAACD,GAAG,CAACE,mBAAmB;IAC3C,IAAIR,GAAG,KAAKS,SAAS,EAAE;MACrB,MAAM,IAAIP,KAAK,CAAC,oCAAoC,CAAC;;IAEvD,MAAMQ,OAAO,GAAGnB,cAAc,CAACK,cAAc,EAAE;IAC/C,MAAMH,UAAU,GAAG,IAAIP,SAAA,CAAAiB,UAAU,CAACH,GAAG,EAAEU,OAAO,CAACZ,UAAU,CAAC;IAC1D,MAAMM,UAAU,GAAGjB,OAAO,CAAC,iBAAiB,CAAC,CAACkB,OAAO;IACrD,MAAMX,MAAM,GAAGU,UAAU,CAACL,KAAK,EAAE;IAEjC,OAAO,IAAIR,cAAc,CAACE,UAAU,EAAEC,MAAM,EAAEgB,OAAO,CAAC;EACxD;EAEA;;;;;;;EAOA,MAAMC,cAAcA,CAClBC,EAAe,EACfC,OAAkB,EAClBlB,IAAqB;;IAErB,IAAIA,IAAI,KAAKc,SAAS,EAAE;MACtBd,IAAI,GAAG,IAAI,CAACA,IAAI;;IAGlBiB,EAAE,CAACE,QAAQ,GAAG,IAAI,CAACpB,MAAM,CAACqB,SAAS;IACnCH,EAAE,CAACI,eAAe,GAAG,CACnB,MAAM,IAAI,CAACvB,UAAU,CAACwB,kBAAkB,CAACtB,IAAI,CAACE,mBAAmB,CAAC,EAClEqB,SAAS;IAEXN,EAAE,GAAG,MAAM,IAAI,CAAClB,MAAM,CAACyB,eAAe,CAACP,EAAE,CAAC;IAC1C,CAACC,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAI,EAAE,EAAEO,OAAO,CAAEC,EAAE,IAAI;MAC7BT,EAAE,CAACU,WAAW,CAACD,EAAE,CAAC;IACpB,CAAC,CAAC;IAEF,MAAME,KAAK,GAAGX,EAAE,CAACY,SAAS,EAAE;IAE5B,IAAI;MACF,OAAO,MAAMC,4BAA4B,CAAC,IAAI,CAAChC,UAAU,EAAE8B,KAAK,EAAE5B,IAAI,CAAC;KACxE,CAAC,OAAO+B,GAAG,EAAE;MACZ;MACA;MACA,IAAIA,GAAG,YAAYC,YAAY,EAAE;QAC/B;QACA;QACA;QACA;QACA,MAAMC,QAAQ,GAAG,MAAM,IAAI,CAACnC,UAAU,CAACoC,cAAc,CACnDzC,UAAA,CAAA0C,IAAI,CAACC,MAAM,CAACnB,EAAE,CAACoB,SAAU,CAAC,EAC1B;UAAElC,UAAU,EAAE;QAAW,CAAE,CAC5B;QACD,IAAI,CAAC8B,QAAQ,EAAE;UACb,MAAMF,GAAG;SACV,MAAM;UACL,MAAMO,IAAI,GAAG,CAAAC,EAAA,GAAAN,QAAQ,CAACO,IAAI,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,WAAW;UACvC,MAAM,CAACH,IAAI,GAAGP,GAAG,GAAG,IAAIxC,SAAA,CAAAmD,oBAAoB,CAACX,GAAG,CAACY,OAAO,EAAEL,IAAI,CAAC;;OAElE,MAAM;QACL,MAAMP,GAAG;;;EAGf;EAEA;;;EAGA,MAAMa,OAAOA,CACXC,aAAwD,EACxD7C,IAAqB;IAErB,IAAIA,IAAI,KAAKc,SAAS,EAAE;MACtBd,IAAI,GAAG,IAAI,CAACA,IAAI;;IAElB,MAAMuB,SAAS,GAAG,MAAM,IAAI,CAACzB,UAAU,CAACwB,kBAAkB,CACxDtB,IAAI,CAACE,mBAAmB,CACzB;IAED,IAAI4C,GAAG,GAAGD,aAAa,CAACE,GAAG,CAAEC,CAAC,IAAI;;MAChC,IAAI/B,EAAE,GAAG+B,CAAC,CAAC/B,EAAE;MACb,IAAIC,OAAO,GAAG,CAAAqB,EAAA,GAAAS,CAAC,CAAC9B,OAAO,cAAAqB,EAAA,cAAAA,EAAA,GAAI,EAAE;MAE7BtB,EAAE,CAACE,QAAQ,GAAG,IAAI,CAACpB,MAAM,CAACqB,SAAS;MACnCH,EAAE,CAACI,eAAe,GAAGE,SAAS,CAACA,SAAS;MAExCL,OAAO,CAACO,OAAO,CAAEC,EAAE,IAAI;QACrBT,EAAE,CAACU,WAAW,CAACD,EAAE,CAAC;MACpB,CAAC,CAAC;MAEF,OAAOT,EAAE;IACX,CAAC,CAAC;IAEF,MAAMgC,SAAS,GAAG,MAAM,IAAI,CAAClD,MAAM,CAACmD,mBAAmB,CAACJ,GAAG,CAAC;IAE5D,MAAMK,IAAI,GAA2B,EAAE;IAEvC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,GAAG,CAACO,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;MACtC,MAAMnC,EAAE,GAAGgC,SAAS,CAACG,CAAC,CAAC;MACvB,MAAMxB,KAAK,GAAGX,EAAE,CAACY,SAAS,EAAE;MAC5BsB,IAAI,CAACG,IAAI,CACP,MAAMxB,4BAA4B,CAAC,IAAI,CAAChC,UAAU,EAAE8B,KAAK,EAAE5B,IAAI,CAAC,CACjE;;IAGH,OAAOmD,IAAI;EACb;EAEA;;;;;;;EAOA,MAAMI,QAAQA,CACZtC,EAAe,EACfC,OAAkB,EAClBf,UAAuB,EACvBqD,eAAuC;IAEvCvC,EAAE,CAACE,QAAQ,GAAG,IAAI,CAACpB,MAAM,CAACqB,SAAS;IACnCH,EAAE,CAACI,eAAe,GAAG,CACnB,MAAM,IAAI,CAACvB,UAAU,CAAC2D,kBAAkB,CACtCtD,UAAU,aAAVA,UAAU,cAAVA,UAAU,GAAI,IAAI,CAACL,UAAU,CAACK,UAAU,CACzC,EACDoB,SAAS;IAEXN,EAAE,GAAG,MAAM,IAAI,CAAClB,MAAM,CAACyB,eAAe,CAACP,EAAE,CAAC;IAC1C,MAAMyC,MAAM,GAAG,MAAM,IAAA/D,QAAA,CAAAgE,mBAAmB,EACtC,IAAI,CAAC7D,UAAU,EACfmB,EAAE,EACFC,OAAO,EACPf,UAAU,EACVqD,eAAe,CAChB;IAED,IAAIE,MAAM,CAACE,KAAK,CAAC7B,GAAG,EAAE;MACpB,MAAM,IAAI8B,aAAa,CAACH,MAAM,CAACE,KAAK,CAAC;;IAGvC,OAAOF,MAAM,CAACE,KAAK;EACrB;;AApMFE,OAAA,CAAAlE,cAAA,GAAAA,cAAA;AAuMA,MAAMiE,aAAc,SAAQtD,KAAK;EAC/BV,YACWkE,kBAAgD,EACzDpB,OAAgB;IAEhB,KAAK,CAACA,OAAO,CAAC;IAHL,KAAAoB,kBAAkB,GAAlBA,kBAAkB;EAI7B;;AAiBF;AACA;AACA,eAAejC,4BAA4BA,CACzChC,UAAsB,EACtBkE,cAAsB,EACtBjD,OAAwB;EAExB,MAAMkD,WAAW,GAAGlD,OAAO,IAAI;IAC7BmD,aAAa,EAAEnD,OAAO,CAACmD,aAAa;IACpChE,mBAAmB,EAAEa,OAAO,CAACb,mBAAmB,IAAIa,OAAO,CAACZ;GAC7D;EAED,MAAMkC,SAAS,GAAG,MAAMvC,UAAU,CAACqE,kBAAkB,CACnDH,cAAc,EACdC,WAAW,CACZ;EAED,MAAMG,MAAM,GAAG,CACb,MAAMtE,UAAU,CAACuE,kBAAkB,CACjChC,SAAS,EACTtB,OAAO,IAAIA,OAAO,CAACZ,UAAU,CAC9B,EACDyD,KAAK;EAEP,IAAIQ,MAAM,CAACrC,GAAG,EAAE;IACd,MAAM,IAAIC,YAAY,CACpB,mBAAmBK,SAAS,YAAYiC,IAAI,CAACC,SAAS,CAACH,MAAM,CAAC,GAAG,CAClE;;EAGH,OAAO/B,SAAS;AAClB;AAEA,MAAML,YAAa,SAAQzB,KAAK;EAC9BV,YAAY8C,OAAgB;IAC1B,KAAK,CAACA,OAAO,CAAC;EAChB;;AAGF;;;AAGA,SAAgB6B,WAAWA,CAACC,QAAkB;EAC5CC,SAAS,GAAGD,QAAQ;AACtB;AAFAX,OAAA,CAAAU,WAAA,GAAAA,WAAA;AAIA;;;AAGA,SAAgBG,WAAWA,CAAA;EACzB,IAAID,SAAS,KAAK,IAAI,EAAE;IACtB,OAAO9E,cAAc,CAACQ,KAAK,EAAE;;EAE/B,OAAOsE,SAAS;AAClB;AALAZ,OAAA,CAAAa,WAAA,GAAAA,WAAA;AAOA;AACA,IAAID,SAAS,GAAoB,IAAI"},"metadata":{},"sourceType":"script","externalDependencies":[]}