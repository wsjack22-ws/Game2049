{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createDataView = exports.concatBytes = exports.valueToBytes = exports.stringToBytes = exports.numberToBytes = exports.signedBigIntToBytes = exports.bigIntToBytes = exports.hexToBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToSignedBigInt = exports.bytesToBigInt = exports.bytesToHex = exports.assertIsBytes = exports.isBytes = void 0;\nconst assert_1 = require(\"./assert\");\nconst hex_1 = require(\"./hex\");\n// '0'.charCodeAt(0) === 48\nconst HEX_MINIMUM_NUMBER_CHARACTER = 48;\n// '9'.charCodeAt(0) === 57\nconst HEX_MAXIMUM_NUMBER_CHARACTER = 58;\nconst HEX_CHARACTER_OFFSET = 87;\n/**\n * Memoized function that returns an array to be used as a lookup table for\n * converting bytes to hexadecimal values.\n *\n * The array is created lazily and then cached for future use. The benefit of\n * this approach is that the performance of converting bytes to hex is much\n * better than if we were to call `toString(16)` on each byte.\n *\n * The downside is that the array is created once and then never garbage\n * collected. This is not a problem in practice because the array is only 256\n * elements long.\n *\n * @returns A function that returns the lookup table.\n */\nfunction getPrecomputedHexValuesBuilder() {\n  // To avoid issues with tree shaking, we need to use a function to return the\n  // array. This is because the array is only used in the `bytesToHex` function\n  // and if we were to use a global variable, the array might be removed by the\n  // tree shaker.\n  const lookupTable = [];\n  return () => {\n    if (lookupTable.length === 0) {\n      for (let i = 0; i < 256; i++) {\n        lookupTable.push(i.toString(16).padStart(2, '0'));\n      }\n    }\n    return lookupTable;\n  };\n}\n/**\n * Function implementation of the {@link getPrecomputedHexValuesBuilder}\n * function.\n */\nconst getPrecomputedHexValues = getPrecomputedHexValuesBuilder();\n/**\n * Check if a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @returns Whether the value is a `Uint8Array`.\n */\nfunction isBytes(value) {\n  return value instanceof Uint8Array;\n}\nexports.isBytes = isBytes;\n/**\n * Assert that a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @throws If the value is not a `Uint8Array`.\n */\nfunction assertIsBytes(value) {\n  (0, assert_1.assert)(isBytes(value), 'Value must be a Uint8Array.');\n}\nexports.assertIsBytes = assertIsBytes;\n/**\n * Convert a `Uint8Array` to a hexadecimal string.\n *\n * @param bytes - The bytes to convert to a hexadecimal string.\n * @returns The hexadecimal string.\n */\nfunction bytesToHex(bytes) {\n  assertIsBytes(bytes);\n  if (bytes.length === 0) {\n    return '0x';\n  }\n  const lookupTable = getPrecomputedHexValues();\n  const hexadecimal = new Array(bytes.length);\n  for (let i = 0; i < bytes.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    hexadecimal[i] = lookupTable[bytes[i]];\n  }\n  return (0, hex_1.add0x)(hexadecimal.join(''));\n}\nexports.bytesToHex = bytesToHex;\n/**\n * Convert a `Uint8Array` to a `bigint`.\n *\n * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.\n * To convert a two's complement encoded `Uint8Array` to a `bigint`, use\n * {@link bytesToSignedBigInt}.\n *\n * @param bytes - The bytes to convert to a `bigint`.\n * @returns The `bigint`.\n */\nfunction bytesToBigInt(bytes) {\n  assertIsBytes(bytes);\n  const hexadecimal = bytesToHex(bytes);\n  return BigInt(hexadecimal);\n}\nexports.bytesToBigInt = bytesToBigInt;\n/**\n * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are\n * encoded in two's complement.\n *\n * To convert a `Uint8Array` to an unsigned `bigint` instead, use\n * {@link bytesToBigInt}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param bytes - The bytes to convert to a signed `bigint`.\n * @returns The signed `bigint`.\n */\nfunction bytesToSignedBigInt(bytes) {\n  assertIsBytes(bytes);\n  let value = BigInt(0);\n  for (const byte of bytes) {\n    // eslint-disable-next-line no-bitwise\n    value = (value << BigInt(8)) + BigInt(byte);\n  }\n  return BigInt.asIntN(bytes.length * 8, value);\n}\nexports.bytesToSignedBigInt = bytesToSignedBigInt;\n/**\n * Convert a `Uint8Array` to a `number`.\n *\n * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.\n *\n * @param bytes - The bytes to convert to a number.\n * @returns The number.\n * @throws If the resulting number is not a safe integer.\n */\nfunction bytesToNumber(bytes) {\n  assertIsBytes(bytes);\n  const bigint = bytesToBigInt(bytes);\n  (0, assert_1.assert)(bigint <= BigInt(Number.MAX_SAFE_INTEGER), 'Number is not a safe integer. Use `bytesToBigInt` instead.');\n  return Number(bigint);\n}\nexports.bytesToNumber = bytesToNumber;\n/**\n * Convert a UTF-8 encoded `Uint8Array` to a `string`.\n *\n * @param bytes - The bytes to convert to a string.\n * @returns The string.\n */\nfunction bytesToString(bytes) {\n  assertIsBytes(bytes);\n  return new TextDecoder().decode(bytes);\n}\nexports.bytesToString = bytesToString;\n/**\n * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be\n * prefixed with `0x`. It accepts even and odd length strings.\n *\n * If the value is \"0x\", an empty `Uint8Array` is returned.\n *\n * @param value - The hexadecimal string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction hexToBytes(value) {\n  var _a;\n  // \"0x\" is often used as empty byte array.\n  if (((_a = value === null || value === void 0 ? void 0 : value.toLowerCase) === null || _a === void 0 ? void 0 : _a.call(value)) === '0x') {\n    return new Uint8Array();\n  }\n  (0, hex_1.assertIsHexString)(value);\n  // Remove the `0x` prefix if it exists, and pad the string to have an even\n  // number of characters.\n  const strippedValue = (0, hex_1.remove0x)(value).toLowerCase();\n  const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;\n  const bytes = new Uint8Array(normalizedValue.length / 2);\n  for (let i = 0; i < bytes.length; i++) {\n    // While this is not the prettiest way to convert a hexadecimal string to a\n    // `Uint8Array`, it is a lot faster than using `parseInt` to convert each\n    // character.\n    const c1 = normalizedValue.charCodeAt(i * 2);\n    const c2 = normalizedValue.charCodeAt(i * 2 + 1);\n    const n1 = c1 - (c1 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);\n    const n2 = c2 - (c2 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);\n    bytes[i] = n1 * 16 + n2;\n  }\n  return bytes;\n}\nexports.hexToBytes = hexToBytes;\n/**\n * Convert a `bigint` to a `Uint8Array`.\n *\n * This assumes that the `bigint` is an unsigned integer. To convert a signed\n * `bigint` instead, use {@link signedBigIntToBytes}.\n *\n * @param value - The bigint to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction bigIntToBytes(value) {\n  (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');\n  (0, assert_1.assert)(value >= BigInt(0), 'Value must be a non-negative bigint.');\n  const hexadecimal = value.toString(16);\n  return hexToBytes(hexadecimal);\n}\nexports.bigIntToBytes = bigIntToBytes;\n/**\n * Check if a `bigint` fits in a certain number of bytes.\n *\n * @param value - The `bigint` to check.\n * @param bytes - The number of bytes.\n * @returns Whether the `bigint` fits in the number of bytes.\n */\nfunction bigIntFits(value, bytes) {\n  (0, assert_1.assert)(bytes > 0);\n  /* eslint-disable no-bitwise */\n  const mask = value >> BigInt(31);\n  return !((~value & mask) + (value & ~mask) >> BigInt(bytes * 8 + ~0));\n  /* eslint-enable no-bitwise */\n}\n/**\n * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement\n * encoding to represent negative numbers.\n *\n * To convert an unsigned `bigint` to a `Uint8Array` instead, use\n * {@link bigIntToBytes}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param value - The number to convert to bytes.\n * @param byteLength - The length of the resulting `Uint8Array`. If the number\n * is larger than the maximum value that can be represented by the given length,\n * an error is thrown.\n * @returns The bytes as `Uint8Array`.\n */\nfunction signedBigIntToBytes(value, byteLength) {\n  (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');\n  (0, assert_1.assert)(typeof byteLength === 'number', 'Byte length must be a number.');\n  (0, assert_1.assert)(byteLength > 0, 'Byte length must be greater than 0.');\n  (0, assert_1.assert)(bigIntFits(value, byteLength), 'Byte length is too small to represent the given value.');\n  // ESLint doesn't like mutating function parameters, so to avoid having to\n  // disable the rule, we create a new variable.\n  let numberValue = value;\n  const bytes = new Uint8Array(byteLength);\n  for (let i = 0; i < bytes.length; i++) {\n    bytes[i] = Number(BigInt.asUintN(8, numberValue));\n    // eslint-disable-next-line no-bitwise\n    numberValue >>= BigInt(8);\n  }\n  return bytes.reverse();\n}\nexports.signedBigIntToBytes = signedBigIntToBytes;\n/**\n * Convert a `number` to a `Uint8Array`.\n *\n * @param value - The number to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n * @throws If the number is not a safe integer.\n */\nfunction numberToBytes(value) {\n  (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');\n  (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');\n  (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToBytes` instead.');\n  const hexadecimal = value.toString(16);\n  return hexToBytes(hexadecimal);\n}\nexports.numberToBytes = numberToBytes;\n/**\n * Convert a `string` to a UTF-8 encoded `Uint8Array`.\n *\n * @param value - The string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction stringToBytes(value) {\n  (0, assert_1.assert)(typeof value === 'string', 'Value must be a string.');\n  return new TextEncoder().encode(value);\n}\nexports.stringToBytes = stringToBytes;\n/**\n * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,\n * a `bigint`, a `number`, or a `string`.\n *\n * This will attempt to guess the type of the value based on its type and\n * contents. For more control over the conversion, use the more specific\n * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.\n *\n * If the value is a `string`, and it is prefixed with `0x`, it will be\n * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a\n * UTF-8 string. To convert a hexadecimal string to bytes without interpreting\n * it as a UTF-8 string, use {@link hexToBytes} instead.\n *\n * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed\n * `bigint` to bytes, use {@link signedBigIntToBytes} instead.\n *\n * If the value is a `Uint8Array`, it will be returned as-is.\n *\n * @param value - The value to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction valueToBytes(value) {\n  if (typeof value === 'bigint') {\n    return bigIntToBytes(value);\n  }\n  if (typeof value === 'number') {\n    return numberToBytes(value);\n  }\n  if (typeof value === 'string') {\n    if (value.startsWith('0x')) {\n      return hexToBytes(value);\n    }\n    return stringToBytes(value);\n  }\n  if (isBytes(value)) {\n    return value;\n  }\n  throw new TypeError(`Unsupported value type: \"${typeof value}\".`);\n}\nexports.valueToBytes = valueToBytes;\n/**\n * Concatenate multiple byte-like values into a single `Uint8Array`. The values\n * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses\n * {@link valueToBytes} under the hood to convert each value to bytes. Refer to\n * the documentation of that function for more information.\n *\n * @param values - The values to concatenate.\n * @returns The concatenated bytes as `Uint8Array`.\n */\nfunction concatBytes(values) {\n  const normalizedValues = new Array(values.length);\n  let byteLength = 0;\n  for (let i = 0; i < values.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const value = valueToBytes(values[i]);\n    normalizedValues[i] = value;\n    byteLength += value.length;\n  }\n  const bytes = new Uint8Array(byteLength);\n  for (let i = 0, offset = 0; i < normalizedValues.length; i++) {\n    // While we could simply spread the values into an array and use\n    // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.\n    bytes.set(normalizedValues[i], offset);\n    offset += normalizedValues[i].length;\n  }\n  return bytes;\n}\nexports.concatBytes = concatBytes;\n/**\n * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience\n * function that avoids having to create a {@link DataView} manually, which\n * requires passing the `byteOffset` and `byteLength` parameters every time.\n *\n * Not passing the `byteOffset` and `byteLength` parameters can result in\n * unexpected behavior when the {@link Uint8Array} is a view of a larger\n * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.\n *\n * This function also supports Node.js {@link Buffer}s.\n *\n * @example\n * ```typescript\n * const bytes = new Uint8Array([1, 2, 3]);\n *\n * // This is equivalent to:\n * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n * const dataView = createDataView(bytes);\n * ```\n * @param bytes - The bytes to create the {@link DataView} from.\n * @returns The {@link DataView}.\n */\nfunction createDataView(bytes) {\n  // To maintain compatibility with Node.js, we need to check if the bytes are\n  // a Buffer. If so, we need to slice the buffer to get the underlying\n  // ArrayBuffer.\n  // eslint-disable-next-line no-restricted-globals\n  if (typeof Buffer !== 'undefined' && bytes instanceof Buffer) {\n    const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);\n    return new DataView(buffer);\n  }\n  return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n}\nexports.createDataView = createDataView;","map":{"version":3,"names":["assert_1","require","hex_1","HEX_MINIMUM_NUMBER_CHARACTER","HEX_MAXIMUM_NUMBER_CHARACTER","HEX_CHARACTER_OFFSET","getPrecomputedHexValuesBuilder","lookupTable","length","i","push","toString","padStart","getPrecomputedHexValues","isBytes","value","Uint8Array","exports","assertIsBytes","assert","bytesToHex","bytes","hexadecimal","Array","add0x","join","bytesToBigInt","BigInt","bytesToSignedBigInt","byte","asIntN","bytesToNumber","bigint","Number","MAX_SAFE_INTEGER","bytesToString","TextDecoder","decode","hexToBytes","_a","toLowerCase","call","assertIsHexString","strippedValue","remove0x","normalizedValue","c1","charCodeAt","c2","n1","n2","bigIntToBytes","bigIntFits","mask","signedBigIntToBytes","byteLength","numberValue","asUintN","reverse","numberToBytes","isSafeInteger","stringToBytes","TextEncoder","encode","valueToBytes","startsWith","TypeError","concatBytes","values","normalizedValues","offset","set","createDataView","Buffer","buffer","slice","byteOffset","DataView"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@metamask/utils/src/bytes.ts"],"sourcesContent":["import { assert } from './assert';\nimport { add0x, assertIsHexString, Hex, remove0x } from './hex';\n\n// '0'.charCodeAt(0) === 48\nconst HEX_MINIMUM_NUMBER_CHARACTER = 48;\n\n// '9'.charCodeAt(0) === 57\nconst HEX_MAXIMUM_NUMBER_CHARACTER = 58;\nconst HEX_CHARACTER_OFFSET = 87;\n\nexport type Bytes = bigint | number | string | Uint8Array;\n\n/**\n * Memoized function that returns an array to be used as a lookup table for\n * converting bytes to hexadecimal values.\n *\n * The array is created lazily and then cached for future use. The benefit of\n * this approach is that the performance of converting bytes to hex is much\n * better than if we were to call `toString(16)` on each byte.\n *\n * The downside is that the array is created once and then never garbage\n * collected. This is not a problem in practice because the array is only 256\n * elements long.\n *\n * @returns A function that returns the lookup table.\n */\nfunction getPrecomputedHexValuesBuilder(): () => string[] {\n  // To avoid issues with tree shaking, we need to use a function to return the\n  // array. This is because the array is only used in the `bytesToHex` function\n  // and if we were to use a global variable, the array might be removed by the\n  // tree shaker.\n  const lookupTable: string[] = [];\n\n  return () => {\n    if (lookupTable.length === 0) {\n      for (let i = 0; i < 256; i++) {\n        lookupTable.push(i.toString(16).padStart(2, '0'));\n      }\n    }\n\n    return lookupTable;\n  };\n}\n\n/**\n * Function implementation of the {@link getPrecomputedHexValuesBuilder}\n * function.\n */\nconst getPrecomputedHexValues = getPrecomputedHexValuesBuilder();\n\n/**\n * Check if a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @returns Whether the value is a `Uint8Array`.\n */\nexport function isBytes(value: unknown): value is Uint8Array {\n  return value instanceof Uint8Array;\n}\n\n/**\n * Assert that a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @throws If the value is not a `Uint8Array`.\n */\nexport function assertIsBytes(value: unknown): asserts value is Uint8Array {\n  assert(isBytes(value), 'Value must be a Uint8Array.');\n}\n\n/**\n * Convert a `Uint8Array` to a hexadecimal string.\n *\n * @param bytes - The bytes to convert to a hexadecimal string.\n * @returns The hexadecimal string.\n */\nexport function bytesToHex(bytes: Uint8Array): Hex {\n  assertIsBytes(bytes);\n\n  if (bytes.length === 0) {\n    return '0x';\n  }\n\n  const lookupTable = getPrecomputedHexValues();\n  const hexadecimal = new Array(bytes.length);\n\n  for (let i = 0; i < bytes.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    hexadecimal[i] = lookupTable[bytes[i]!];\n  }\n\n  return add0x(hexadecimal.join(''));\n}\n\n/**\n * Convert a `Uint8Array` to a `bigint`.\n *\n * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.\n * To convert a two's complement encoded `Uint8Array` to a `bigint`, use\n * {@link bytesToSignedBigInt}.\n *\n * @param bytes - The bytes to convert to a `bigint`.\n * @returns The `bigint`.\n */\nexport function bytesToBigInt(bytes: Uint8Array): bigint {\n  assertIsBytes(bytes);\n\n  const hexadecimal = bytesToHex(bytes);\n  return BigInt(hexadecimal);\n}\n\n/**\n * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are\n * encoded in two's complement.\n *\n * To convert a `Uint8Array` to an unsigned `bigint` instead, use\n * {@link bytesToBigInt}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param bytes - The bytes to convert to a signed `bigint`.\n * @returns The signed `bigint`.\n */\nexport function bytesToSignedBigInt(bytes: Uint8Array): bigint {\n  assertIsBytes(bytes);\n\n  let value = BigInt(0);\n  for (const byte of bytes) {\n    // eslint-disable-next-line no-bitwise\n    value = (value << BigInt(8)) + BigInt(byte);\n  }\n\n  return BigInt.asIntN(bytes.length * 8, value);\n}\n\n/**\n * Convert a `Uint8Array` to a `number`.\n *\n * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.\n *\n * @param bytes - The bytes to convert to a number.\n * @returns The number.\n * @throws If the resulting number is not a safe integer.\n */\nexport function bytesToNumber(bytes: Uint8Array): number {\n  assertIsBytes(bytes);\n\n  const bigint = bytesToBigInt(bytes);\n\n  assert(\n    bigint <= BigInt(Number.MAX_SAFE_INTEGER),\n    'Number is not a safe integer. Use `bytesToBigInt` instead.',\n  );\n\n  return Number(bigint);\n}\n\n/**\n * Convert a UTF-8 encoded `Uint8Array` to a `string`.\n *\n * @param bytes - The bytes to convert to a string.\n * @returns The string.\n */\nexport function bytesToString(bytes: Uint8Array): string {\n  assertIsBytes(bytes);\n\n  return new TextDecoder().decode(bytes);\n}\n\n/**\n * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be\n * prefixed with `0x`. It accepts even and odd length strings.\n *\n * If the value is \"0x\", an empty `Uint8Array` is returned.\n *\n * @param value - The hexadecimal string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function hexToBytes(value: string): Uint8Array {\n  // \"0x\" is often used as empty byte array.\n  if (value?.toLowerCase?.() === '0x') {\n    return new Uint8Array();\n  }\n\n  assertIsHexString(value);\n\n  // Remove the `0x` prefix if it exists, and pad the string to have an even\n  // number of characters.\n  const strippedValue = remove0x(value).toLowerCase();\n  const normalizedValue =\n    strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;\n  const bytes = new Uint8Array(normalizedValue.length / 2);\n\n  for (let i = 0; i < bytes.length; i++) {\n    // While this is not the prettiest way to convert a hexadecimal string to a\n    // `Uint8Array`, it is a lot faster than using `parseInt` to convert each\n    // character.\n    const c1 = normalizedValue.charCodeAt(i * 2);\n    const c2 = normalizedValue.charCodeAt(i * 2 + 1);\n    const n1 =\n      c1 -\n      (c1 < HEX_MAXIMUM_NUMBER_CHARACTER\n        ? HEX_MINIMUM_NUMBER_CHARACTER\n        : HEX_CHARACTER_OFFSET);\n    const n2 =\n      c2 -\n      (c2 < HEX_MAXIMUM_NUMBER_CHARACTER\n        ? HEX_MINIMUM_NUMBER_CHARACTER\n        : HEX_CHARACTER_OFFSET);\n\n    bytes[i] = n1 * 16 + n2;\n  }\n\n  return bytes;\n}\n\n/**\n * Convert a `bigint` to a `Uint8Array`.\n *\n * This assumes that the `bigint` is an unsigned integer. To convert a signed\n * `bigint` instead, use {@link signedBigIntToBytes}.\n *\n * @param value - The bigint to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function bigIntToBytes(value: bigint): Uint8Array {\n  assert(typeof value === 'bigint', 'Value must be a bigint.');\n  assert(value >= BigInt(0), 'Value must be a non-negative bigint.');\n\n  const hexadecimal = value.toString(16);\n  return hexToBytes(hexadecimal);\n}\n\n/**\n * Check if a `bigint` fits in a certain number of bytes.\n *\n * @param value - The `bigint` to check.\n * @param bytes - The number of bytes.\n * @returns Whether the `bigint` fits in the number of bytes.\n */\nfunction bigIntFits(value: bigint, bytes: number): boolean {\n  assert(bytes > 0);\n\n  /* eslint-disable no-bitwise */\n  const mask = value >> BigInt(31);\n  return !(((~value & mask) + (value & ~mask)) >> BigInt(bytes * 8 + ~0));\n  /* eslint-enable no-bitwise */\n}\n\n/**\n * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement\n * encoding to represent negative numbers.\n *\n * To convert an unsigned `bigint` to a `Uint8Array` instead, use\n * {@link bigIntToBytes}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param value - The number to convert to bytes.\n * @param byteLength - The length of the resulting `Uint8Array`. If the number\n * is larger than the maximum value that can be represented by the given length,\n * an error is thrown.\n * @returns The bytes as `Uint8Array`.\n */\nexport function signedBigIntToBytes(\n  value: bigint,\n  byteLength: number,\n): Uint8Array {\n  assert(typeof value === 'bigint', 'Value must be a bigint.');\n  assert(typeof byteLength === 'number', 'Byte length must be a number.');\n  assert(byteLength > 0, 'Byte length must be greater than 0.');\n  assert(\n    bigIntFits(value, byteLength),\n    'Byte length is too small to represent the given value.',\n  );\n\n  // ESLint doesn't like mutating function parameters, so to avoid having to\n  // disable the rule, we create a new variable.\n  let numberValue = value;\n  const bytes = new Uint8Array(byteLength);\n\n  for (let i = 0; i < bytes.length; i++) {\n    bytes[i] = Number(BigInt.asUintN(8, numberValue));\n    // eslint-disable-next-line no-bitwise\n    numberValue >>= BigInt(8);\n  }\n\n  return bytes.reverse();\n}\n\n/**\n * Convert a `number` to a `Uint8Array`.\n *\n * @param value - The number to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n * @throws If the number is not a safe integer.\n */\nexport function numberToBytes(value: number): Uint8Array {\n  assert(typeof value === 'number', 'Value must be a number.');\n  assert(value >= 0, 'Value must be a non-negative number.');\n  assert(\n    Number.isSafeInteger(value),\n    'Value is not a safe integer. Use `bigIntToBytes` instead.',\n  );\n\n  const hexadecimal = value.toString(16);\n  return hexToBytes(hexadecimal);\n}\n\n/**\n * Convert a `string` to a UTF-8 encoded `Uint8Array`.\n *\n * @param value - The string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function stringToBytes(value: string): Uint8Array {\n  assert(typeof value === 'string', 'Value must be a string.');\n\n  return new TextEncoder().encode(value);\n}\n\n/**\n * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,\n * a `bigint`, a `number`, or a `string`.\n *\n * This will attempt to guess the type of the value based on its type and\n * contents. For more control over the conversion, use the more specific\n * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.\n *\n * If the value is a `string`, and it is prefixed with `0x`, it will be\n * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a\n * UTF-8 string. To convert a hexadecimal string to bytes without interpreting\n * it as a UTF-8 string, use {@link hexToBytes} instead.\n *\n * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed\n * `bigint` to bytes, use {@link signedBigIntToBytes} instead.\n *\n * If the value is a `Uint8Array`, it will be returned as-is.\n *\n * @param value - The value to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function valueToBytes(value: Bytes): Uint8Array {\n  if (typeof value === 'bigint') {\n    return bigIntToBytes(value);\n  }\n\n  if (typeof value === 'number') {\n    return numberToBytes(value);\n  }\n\n  if (typeof value === 'string') {\n    if (value.startsWith('0x')) {\n      return hexToBytes(value);\n    }\n\n    return stringToBytes(value);\n  }\n\n  if (isBytes(value)) {\n    return value;\n  }\n\n  throw new TypeError(`Unsupported value type: \"${typeof value}\".`);\n}\n\n/**\n * Concatenate multiple byte-like values into a single `Uint8Array`. The values\n * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses\n * {@link valueToBytes} under the hood to convert each value to bytes. Refer to\n * the documentation of that function for more information.\n *\n * @param values - The values to concatenate.\n * @returns The concatenated bytes as `Uint8Array`.\n */\nexport function concatBytes(values: Bytes[]): Uint8Array {\n  const normalizedValues = new Array(values.length);\n  let byteLength = 0;\n\n  for (let i = 0; i < values.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const value = valueToBytes(values[i]!);\n\n    normalizedValues[i] = value;\n    byteLength += value.length;\n  }\n\n  const bytes = new Uint8Array(byteLength);\n  for (let i = 0, offset = 0; i < normalizedValues.length; i++) {\n    // While we could simply spread the values into an array and use\n    // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.\n    bytes.set(normalizedValues[i], offset);\n    offset += normalizedValues[i].length;\n  }\n\n  return bytes;\n}\n\n/**\n * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience\n * function that avoids having to create a {@link DataView} manually, which\n * requires passing the `byteOffset` and `byteLength` parameters every time.\n *\n * Not passing the `byteOffset` and `byteLength` parameters can result in\n * unexpected behavior when the {@link Uint8Array} is a view of a larger\n * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.\n *\n * This function also supports Node.js {@link Buffer}s.\n *\n * @example\n * ```typescript\n * const bytes = new Uint8Array([1, 2, 3]);\n *\n * // This is equivalent to:\n * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n * const dataView = createDataView(bytes);\n * ```\n * @param bytes - The bytes to create the {@link DataView} from.\n * @returns The {@link DataView}.\n */\nexport function createDataView(bytes: Uint8Array): DataView {\n  // To maintain compatibility with Node.js, we need to check if the bytes are\n  // a Buffer. If so, we need to slice the buffer to get the underlying\n  // ArrayBuffer.\n  // eslint-disable-next-line no-restricted-globals\n  if (typeof Buffer !== 'undefined' && bytes instanceof Buffer) {\n    const buffer = bytes.buffer.slice(\n      bytes.byteOffset,\n      bytes.byteOffset + bytes.byteLength,\n    );\n\n    return new DataView(buffer);\n  }\n\n  return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}