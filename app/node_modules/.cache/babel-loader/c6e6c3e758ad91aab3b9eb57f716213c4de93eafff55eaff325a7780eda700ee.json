{"ast":null,"code":"/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * Support for translating between Buffer instances and JavaScript\n * native types.\n *\n * {@link module:Layout~Layout|Layout} is the basis of a class\n * hierarchy that associates property names with sequences of encoded\n * bytes.\n *\n * Layouts are supported for these scalar (numeric) types:\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\n *   format} with {@link module:Layout.u8|8-bit}, {@link\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\n *   {@link module:Layout.u32|32-bit}, {@link\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\n *   {@link module:Layout.u40be|40-bit}, and {@link\n *   module:Layout.u48be|48-bit} representation ranges;\n * * {@link module:Layout~Int|Signed integers in little-endian\n *   format} with {@link module:Layout.s8|8-bit}, {@link\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\n *   {@link module:Layout.s32|32-bit}, {@link\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\n *   with {@link module:Layout.s16be|16-bit}, {@link\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\n *   {@link module:Layout.s40be|40-bit}, and {@link\n *   module:Layout.s48be|48-bit} representation ranges;\n * * 64-bit integral values that decode to an exact (if magnitude is\n *   less than 2^53) or nearby integral Number in {@link\n *   module:Layout.nu64|unsigned little-endian}, {@link\n *   module:Layout.nu64be|unsigned big-endian}, {@link\n *   module:Layout.ns64|signed little-endian}, and {@link\n *   module:Layout.ns64be|unsigned big-endian} encodings;\n * * 32-bit floating point values with {@link\n *   module:Layout.f32|little-endian} and {@link\n *   module:Layout.f32be|big-endian} representations;\n * * 64-bit floating point values with {@link\n *   module:Layout.f64|little-endian} and {@link\n *   module:Layout.f64be|big-endian} representations;\n * * {@link module:Layout.const|Constants} that take no space in the\n *   encoded expression.\n *\n * and for these aggregate types:\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\n *   module:Layout~Layout|Layout}, with JavaScript representation as\n *   an Array and constant or data-dependent {@link\n *   module:Layout~Sequence#count|length};\n * * {@link module:Layout.struct|Structure}s that aggregate a\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\n *   instances, with JavaScript representation as an Object;\n * * {@link module:Layout.union|Union}s that support multiple {@link\n *   module:Layout~VariantLayout|variant layouts} over a fixed\n *   (padded) or variable (not padded) span of bytes, using an\n *   unsigned integer at the start of the data or a separate {@link\n *   module:Layout.unionLayoutDiscriminator|layout element} to\n *   determine which layout to use when interpreting the buffer\n *   contents;\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\n *   of individual {@link\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\n *   16, 24, or 32-bit unsigned integer starting at the least- or\n *   most-significant bit;\n * * {@link module:Layout.cstr|C strings} of varying length;\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\n *   module:Layout~Blob#length|length} raw data.\n *\n * All {@link module:Layout~Layout|Layout} instances are immutable\n * after construction, to prevent internal state from becoming\n * inconsistent.\n *\n * @local Layout\n * @local ExternalLayout\n * @local GreedyCount\n * @local OffsetLayout\n * @local UInt\n * @local UIntBE\n * @local Int\n * @local IntBE\n * @local NearUInt64\n * @local NearUInt64BE\n * @local NearInt64\n * @local NearInt64BE\n * @local Float\n * @local FloatBE\n * @local Double\n * @local DoubleBE\n * @local Sequence\n * @local Structure\n * @local UnionDiscriminator\n * @local UnionLayoutDiscriminator\n * @local Union\n * @local VariantLayout\n * @local BitStructure\n * @local BitField\n * @local Boolean\n * @local Blob\n * @local CString\n * @local Constant\n * @local bindConstructorLayout\n * @module Layout\n * @license MIT\n * @author Peter A. Bigot\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\n */\n\n'use strict';\n\n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */\nvar _assertThisInitialized = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _inherits = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _classCallCheck = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar Layout = /*#__PURE__*/function () {\n  function Layout(span, property) {\n    _classCallCheck(this, Layout);\n    if (!Number.isInteger(span)) {\n      throw new TypeError('span must be an integer');\n    }\n\n    /** The span of the layout in bytes.\n     *\n     * Positive values are generally expected.\n     *\n     * Zero will only appear in {@link Constant}s and in {@link\n     * Sequence}s where the {@link Sequence#count|count} is zero.\n     *\n     * A negative value indicates that the span is value-specific, and\n     * must be obtained using {@link Layout#getSpan|getSpan}. */\n    this.span = span;\n\n    /** The property name used when this layout is represented in an\n     * Object.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances.  If left undefined the span of the unnamed layout will\n     * be treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n    this.property = property;\n  }\n\n  /** Function to create an Object into which decoded properties will\n   * be written.\n   *\n   * Used only for layouts that {@link Layout#decode|decode} to Object\n   * instances, which means:\n   * * {@link Structure}\n   * * {@link Union}\n   * * {@link VariantLayout}\n   * * {@link BitStructure}\n   *\n   * If left undefined the JavaScript representation of these layouts\n   * will be Object instances.\n   *\n   * See {@link bindConstructorLayout}.\n   */\n  _createClass(Layout, [{\n    key: \"makeDestinationObject\",\n    value: function makeDestinationObject() {\n      return {};\n    }\n\n    /**\n     * Decode from a Buffer into an JavaScript value.\n     *\n     * @param {Buffer} b - the buffer from which encoded data is read.\n     *\n     * @param {Number} [offset] - the offset at which the encoded data\n     * starts.  If absent a zero offset is inferred.\n     *\n     * @returns {(Number|Array|Object)} - the value of the decoded data.\n     *\n     * @abstract\n     */\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      throw new Error('Layout is abstract');\n    }\n\n    /**\n     * Encode a JavaScript value into a Buffer.\n     *\n     * @param {(Number|Array|Object)} src - the value to be encoded into\n     * the buffer.  The type accepted depends on the (sub-)type of {@link\n     * Layout}.\n     *\n     * @param {Buffer} b - the buffer into which encoded data will be\n     * written.\n     *\n     * @param {Number} [offset] - the offset at which the encoded data\n     * starts.  If absent a zero offset is inferred.\n     *\n     * @returns {Number} - the number of bytes encoded, including the\n     * space skipped for internal padding, but excluding data such as\n     * {@link Sequence#count|lengths} when stored {@link\n     * ExternalLayout|externally}.  This is the adjustment to `offset`\n     * producing the offset where data for the next layout would be\n     * written.\n     *\n     * @abstract\n     */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      throw new Error('Layout is abstract');\n    }\n\n    /**\n     * Calculate the span of a specific instance of a layout.\n     *\n     * @param {Buffer} b - the buffer that contains an encoded instance.\n     *\n     * @param {Number} [offset] - the offset at which the encoded instance\n     * starts.  If absent a zero offset is inferred.\n     *\n     * @return {Number} - the number of bytes covered by the layout\n     * instance.  If this method is not overridden in a subclass the\n     * definition-time constant {@link Layout#span|span} will be\n     * returned.\n     *\n     * @throws {RangeError} - if the length of the value cannot be\n     * determined.\n     */\n  }, {\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      if (0 > this.span) {\n        throw new RangeError('indeterminate span');\n      }\n      return this.span;\n    }\n\n    /**\n     * Replicate the layout using a new property.\n     *\n     * This function must be used to get a structurally-equivalent layout\n     * with a different name since all {@link Layout} instances are\n     * immutable.\n     *\n     * **NOTE** This is a shallow copy.  All fields except {@link\n     * Layout#property|property} are strictly equal to the origin layout.\n     *\n     * @param {String} property - the value for {@link\n     * Layout#property|property} in the replica.\n     *\n     * @returns {Layout} - the copy with {@link Layout#property|property}\n     * set to `property`.\n     */\n  }, {\n    key: \"replicate\",\n    value: function replicate(property) {\n      var rv = Object.create(this.constructor.prototype);\n      Object.assign(rv, this);\n      rv.property = property;\n      return rv;\n    }\n\n    /**\n     * Create an object from layout properties and an array of values.\n     *\n     * **NOTE** This function returns `undefined` if invoked on a layout\n     * that does not return its value as an Object.  Objects are\n     * returned for things that are a {@link Structure}, which includes\n     * {@link VariantLayout|variant layouts} if they are structures, and\n     * excludes {@link Union}s.  If you want this feature for a union\n     * you must use {@link Union.getVariant|getVariant} to select the\n     * desired layout.\n     *\n     * @param {Array} values - an array of values that correspond to the\n     * default order for properties.  As with {@link Layout#decode|decode}\n     * layout elements that have no property name are skipped when\n     * iterating over the array values.  Only the top-level properties are\n     * assigned; arguments are not assigned to properties of contained\n     * layouts.  Any unused values are ignored.\n     *\n     * @return {(Object|undefined)}\n     */\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(values) {\n      return undefined;\n    }\n  }]);\n  return Layout;\n}();\nexports.Layout = Layout;\n\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */\nfunction nameWithProperty(name, lo) {\n  if (lo.property) {\n    return name + '[' + lo.property + ']';\n  }\n  return name;\n}\nexports.nameWithProperty = nameWithProperty;\n\n/**\n * Augment a class so that instances can be encoded/decoded using a\n * given layout.\n *\n * Calling this function couples `Class` with `layout` in several ways:\n *\n * * `Class.layout_` becomes a static member property equal to `layout`;\n * * `layout.boundConstructor_` becomes a static member property equal\n *    to `Class`;\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\n *   property of `layout` is set to a function that returns a `new\n *   Class()`;\n * * `Class.decode(b, offset)` becomes a static member function that\n *   delegates to {@link Layout#decode|layout.decode}.  The\n *   synthesized function may be captured and extended.\n * * `Class.prototype.encode(b, offset)` provides an instance member\n *   function that delegates to {@link Layout#encode|layout.encode}\n *   with `src` set to `this`.  The synthesized function may be\n *   captured and extended, but when the extension is invoked `this`\n *   must be explicitly bound to the instance.\n *\n * @param {class} Class - a JavaScript class with a nullary\n * constructor.\n *\n * @param {Layout} layout - the {@link Layout} instance used to encode\n * instances of `Class`.\n */\nfunction bindConstructorLayout(Class, layout) {\n  if ('function' !== typeof Class) {\n    throw new TypeError('Class must be constructor');\n  }\n  if (Class.hasOwnProperty('layout_')) {\n    throw new Error('Class is already bound to a layout');\n  }\n  if (!(layout && layout instanceof Layout)) {\n    throw new TypeError('layout must be a Layout');\n  }\n  if (layout.hasOwnProperty('boundConstructor_')) {\n    throw new Error('layout is already bound to a constructor');\n  }\n  Class.layout_ = layout;\n  layout.boundConstructor_ = Class;\n  layout.makeDestinationObject = function () {\n    return new Class();\n  };\n  Object.defineProperty(Class.prototype, 'encode', {\n    value: function value(b, offset) {\n      return layout.encode(this, b, offset);\n    },\n    writable: true\n  });\n  Object.defineProperty(Class, 'decode', {\n    value: function value(b, offset) {\n      return layout.decode(b, offset);\n    },\n    writable: true\n  });\n}\nexports.bindConstructorLayout = bindConstructorLayout;\n\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */\nvar ExternalLayout = /*#__PURE__*/function (_Layout) {\n  _inherits(ExternalLayout, _Layout);\n  var _super = _createSuper(ExternalLayout);\n  function ExternalLayout() {\n    _classCallCheck(this, ExternalLayout);\n    return _super.apply(this, arguments);\n  }\n  _createClass(ExternalLayout, [{\n    key: \"isCount\",\n    value:\n    /**\n     * Return `true` iff the external layout decodes to an unsigned\n     * integer layout.\n     *\n     * In that case it can be used as the source of {@link\n     * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n     * or as {@link UnionLayoutDiscriminator#layout|external union\n     * discriminators}.\n     *\n     * @abstract\n     */\n    function isCount() {\n      throw new Error('ExternalLayout is abstract');\n    }\n  }]);\n  return ExternalLayout;\n}(Layout);\n/**\n * An {@link ExternalLayout} that determines its {@link\n * Layout#decode|value} based on offset into and length of the buffer\n * on which it is invoked.\n *\n * *Factory*: {@link module:Layout.greedy|greedy}\n *\n * @param {Number} [elementSpan] - initializer for {@link\n * GreedyCount#elementSpan|elementSpan}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {ExternalLayout}\n */\nvar GreedyCount = /*#__PURE__*/function (_ExternalLayout) {\n  _inherits(GreedyCount, _ExternalLayout);\n  var _super2 = _createSuper(GreedyCount);\n  function GreedyCount(elementSpan, property) {\n    var _this;\n    _classCallCheck(this, GreedyCount);\n    if (undefined === elementSpan) {\n      elementSpan = 1;\n    }\n    if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {\n      throw new TypeError('elementSpan must be a (positive) integer');\n    }\n    _this = _super2.call(this, -1, property);\n\n    /** The layout for individual elements of the sequence.  The value\n     * must be a positive integer.  If not provided, the value will be\n     * 1. */\n    _this.elementSpan = elementSpan;\n    return _this;\n  }\n\n  /** @override */\n  _createClass(GreedyCount, [{\n    key: \"isCount\",\n    value: function isCount() {\n      return true;\n    }\n\n    /** @override */\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var rem = b.length - offset;\n      return Math.floor(rem / this.elementSpan);\n    }\n\n    /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      return 0;\n    }\n  }]);\n  return GreedyCount;\n}(ExternalLayout);\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */\nvar OffsetLayout = /*#__PURE__*/function (_ExternalLayout2) {\n  _inherits(OffsetLayout, _ExternalLayout2);\n  var _super3 = _createSuper(OffsetLayout);\n  function OffsetLayout(layout, offset, property) {\n    var _this2;\n    _classCallCheck(this, OffsetLayout);\n    if (!(layout instanceof Layout)) {\n      throw new TypeError('layout must be a Layout');\n    }\n    if (undefined === offset) {\n      offset = 0;\n    } else if (!Number.isInteger(offset)) {\n      throw new TypeError('offset must be integer or undefined');\n    }\n    _this2 = _super3.call(this, layout.span, property || layout.property);\n\n    /** The subordinated layout. */\n    _this2.layout = layout;\n\n    /** The location of {@link OffsetLayout#layout} relative to the\n     * start of another layout.\n     *\n     * The value may be positive or negative, but an error will thrown\n     * if at the point of use it goes outside the span of the Buffer\n     * being accessed.  */\n    _this2.offset = offset;\n    return _this2;\n  }\n\n  /** @override */\n  _createClass(OffsetLayout, [{\n    key: \"isCount\",\n    value: function isCount() {\n      return this.layout instanceof UInt || this.layout instanceof UIntBE;\n    }\n\n    /** @override */\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      return this.layout.decode(b, offset + this.offset);\n    }\n\n    /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      return this.layout.encode(src, b, offset + this.offset);\n    }\n  }]);\n  return OffsetLayout;\n}(ExternalLayout);\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nvar UInt = /*#__PURE__*/function (_Layout2) {\n  _inherits(UInt, _Layout2);\n  var _super4 = _createSuper(UInt);\n  function UInt(span, property) {\n    var _this3;\n    _classCallCheck(this, UInt);\n    _this3 = _super4.call(this, span, property);\n    if (6 < _this3.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n    return _this3;\n  }\n\n  /** @override */\n  _createClass(UInt, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      return b.readUIntLE(offset, this.span);\n    }\n\n    /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      b.writeUIntLE(src, offset, this.span);\n      return this.span;\n    }\n  }]);\n  return UInt;\n}(Layout);\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nvar UIntBE = /*#__PURE__*/function (_Layout3) {\n  _inherits(UIntBE, _Layout3);\n  var _super5 = _createSuper(UIntBE);\n  function UIntBE(span, property) {\n    var _this4;\n    _classCallCheck(this, UIntBE);\n    _this4 = _super5.call(this, span, property);\n    if (6 < _this4.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n    return _this4;\n  }\n\n  /** @override */\n  _createClass(UIntBE, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      return b.readUIntBE(offset, this.span);\n    }\n\n    /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      b.writeUIntBE(src, offset, this.span);\n      return this.span;\n    }\n  }]);\n  return UIntBE;\n}(Layout);\n/**\n * Represent a signed integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.s8|s8}, {@link\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\n *  module:Layout.s48|s48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nvar Int = /*#__PURE__*/function (_Layout4) {\n  _inherits(Int, _Layout4);\n  var _super6 = _createSuper(Int);\n  function Int(span, property) {\n    var _this5;\n    _classCallCheck(this, Int);\n    _this5 = _super6.call(this, span, property);\n    if (6 < _this5.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n    return _this5;\n  }\n\n  /** @override */\n  _createClass(Int, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      return b.readIntLE(offset, this.span);\n    }\n\n    /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      b.writeIntLE(src, offset, this.span);\n      return this.span;\n    }\n  }]);\n  return Int;\n}(Layout);\n/**\n * Represent a signed integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\n * {@link module:Layout.s32be|s32be}, {@link\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nvar IntBE = /*#__PURE__*/function (_Layout5) {\n  _inherits(IntBE, _Layout5);\n  var _super7 = _createSuper(IntBE);\n  function IntBE(span, property) {\n    var _this6;\n    _classCallCheck(this, IntBE);\n    _this6 = _super7.call(this, span, property);\n    if (6 < _this6.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n    return _this6;\n  }\n\n  /** @override */\n  _createClass(IntBE, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      return b.readIntBE(offset, this.span);\n    }\n\n    /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      b.writeIntBE(src, offset, this.span);\n      return this.span;\n    }\n  }]);\n  return IntBE;\n}(Layout);\nvar V2E32 = Math.pow(2, 32);\n\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */\nfunction divmodInt64(src) {\n  var hi32 = Math.floor(src / V2E32);\n  var lo32 = src - hi32 * V2E32;\n  return {\n    hi32: hi32,\n    lo32: lo32\n  };\n}\n/* Reconstruct Number from quotient and non-negative remainder */\nfunction roundedInt64(hi32, lo32) {\n  return hi32 * V2E32 + lo32;\n}\n\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nvar NearUInt64 = /*#__PURE__*/function (_Layout6) {\n  _inherits(NearUInt64, _Layout6);\n  var _super8 = _createSuper(NearUInt64);\n  function NearUInt64(property) {\n    _classCallCheck(this, NearUInt64);\n    return _super8.call(this, 8, property);\n  }\n\n  /** @override */\n  _createClass(NearUInt64, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var lo32 = b.readUInt32LE(offset);\n      var hi32 = b.readUInt32LE(offset + 4);\n      return roundedInt64(hi32, lo32);\n    }\n\n    /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var split = divmodInt64(src);\n      b.writeUInt32LE(split.lo32, offset);\n      b.writeUInt32LE(split.hi32, offset + 4);\n      return 8;\n    }\n  }]);\n  return NearUInt64;\n}(Layout);\n/**\n * Represent an unsigned 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64be|nu64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nvar NearUInt64BE = /*#__PURE__*/function (_Layout7) {\n  _inherits(NearUInt64BE, _Layout7);\n  var _super9 = _createSuper(NearUInt64BE);\n  function NearUInt64BE(property) {\n    _classCallCheck(this, NearUInt64BE);\n    return _super9.call(this, 8, property);\n  }\n\n  /** @override */\n  _createClass(NearUInt64BE, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var hi32 = b.readUInt32BE(offset);\n      var lo32 = b.readUInt32BE(offset + 4);\n      return roundedInt64(hi32, lo32);\n    }\n\n    /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var split = divmodInt64(src);\n      b.writeUInt32BE(split.hi32, offset);\n      b.writeUInt32BE(split.lo32, offset + 4);\n      return 8;\n    }\n  }]);\n  return NearUInt64BE;\n}(Layout);\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nvar NearInt64 = /*#__PURE__*/function (_Layout8) {\n  _inherits(NearInt64, _Layout8);\n  var _super10 = _createSuper(NearInt64);\n  function NearInt64(property) {\n    _classCallCheck(this, NearInt64);\n    return _super10.call(this, 8, property);\n  }\n\n  /** @override */\n  _createClass(NearInt64, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var lo32 = b.readUInt32LE(offset);\n      var hi32 = b.readInt32LE(offset + 4);\n      return roundedInt64(hi32, lo32);\n    }\n\n    /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var split = divmodInt64(src);\n      b.writeUInt32LE(split.lo32, offset);\n      b.writeInt32LE(split.hi32, offset + 4);\n      return 8;\n    }\n  }]);\n  return NearInt64;\n}(Layout);\n/**\n * Represent a signed 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64be|ns64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nvar NearInt64BE = /*#__PURE__*/function (_Layout9) {\n  _inherits(NearInt64BE, _Layout9);\n  var _super11 = _createSuper(NearInt64BE);\n  function NearInt64BE(property) {\n    _classCallCheck(this, NearInt64BE);\n    return _super11.call(this, 8, property);\n  }\n\n  /** @override */\n  _createClass(NearInt64BE, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var hi32 = b.readInt32BE(offset);\n      var lo32 = b.readUInt32BE(offset + 4);\n      return roundedInt64(hi32, lo32);\n    }\n\n    /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var split = divmodInt64(src);\n      b.writeInt32BE(split.hi32, offset);\n      b.writeUInt32BE(split.lo32, offset + 4);\n      return 8;\n    }\n  }]);\n  return NearInt64BE;\n}(Layout);\n/**\n * Represent a 32-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f32|f32}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nvar Float = /*#__PURE__*/function (_Layout10) {\n  _inherits(Float, _Layout10);\n  var _super12 = _createSuper(Float);\n  function Float(property) {\n    _classCallCheck(this, Float);\n    return _super12.call(this, 4, property);\n  }\n\n  /** @override */\n  _createClass(Float, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      return b.readFloatLE(offset);\n    }\n\n    /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      b.writeFloatLE(src, offset);\n      return 4;\n    }\n  }]);\n  return Float;\n}(Layout);\n/**\n * Represent a 32-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f32be|f32be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nvar FloatBE = /*#__PURE__*/function (_Layout11) {\n  _inherits(FloatBE, _Layout11);\n  var _super13 = _createSuper(FloatBE);\n  function FloatBE(property) {\n    _classCallCheck(this, FloatBE);\n    return _super13.call(this, 4, property);\n  }\n\n  /** @override */\n  _createClass(FloatBE, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      return b.readFloatBE(offset);\n    }\n\n    /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      b.writeFloatBE(src, offset);\n      return 4;\n    }\n  }]);\n  return FloatBE;\n}(Layout);\n/**\n * Represent a 64-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f64|f64}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nvar Double = /*#__PURE__*/function (_Layout12) {\n  _inherits(Double, _Layout12);\n  var _super14 = _createSuper(Double);\n  function Double(property) {\n    _classCallCheck(this, Double);\n    return _super14.call(this, 8, property);\n  }\n\n  /** @override */\n  _createClass(Double, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      return b.readDoubleLE(offset);\n    }\n\n    /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      b.writeDoubleLE(src, offset);\n      return 8;\n    }\n  }]);\n  return Double;\n}(Layout);\n/**\n * Represent a 64-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f64be|f64be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nvar DoubleBE = /*#__PURE__*/function (_Layout13) {\n  _inherits(DoubleBE, _Layout13);\n  var _super15 = _createSuper(DoubleBE);\n  function DoubleBE(property) {\n    _classCallCheck(this, DoubleBE);\n    return _super15.call(this, 8, property);\n  }\n\n  /** @override */\n  _createClass(DoubleBE, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      return b.readDoubleBE(offset);\n    }\n\n    /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      b.writeDoubleBE(src, offset);\n      return 8;\n    }\n  }]);\n  return DoubleBE;\n}(Layout);\n/**\n * Represent a contiguous sequence of a specific layout as an Array.\n *\n * *Factory*: {@link module:Layout.seq|seq}\n *\n * @param {Layout} elementLayout - initializer for {@link\n * Sequence#elementLayout|elementLayout}.\n *\n * @param {(Number|ExternalLayout)} count - initializer for {@link\n * Sequence#count|count}.  The parameter must be either a positive\n * integer or an instance of {@link ExternalLayout}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nvar Sequence = /*#__PURE__*/function (_Layout14) {\n  _inherits(Sequence, _Layout14);\n  var _super16 = _createSuper(Sequence);\n  function Sequence(elementLayout, count, property) {\n    var _this7;\n    _classCallCheck(this, Sequence);\n    if (!(elementLayout instanceof Layout)) {\n      throw new TypeError('elementLayout must be a Layout');\n    }\n    if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {\n      throw new TypeError('count must be non-negative integer ' + 'or an unsigned integer ExternalLayout');\n    }\n    var span = -1;\n    if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {\n      span = count * elementLayout.span;\n    }\n    _this7 = _super16.call(this, span, property);\n\n    /** The layout for individual elements of the sequence. */\n    _this7.elementLayout = elementLayout;\n\n    /** The number of elements in the sequence.\n     *\n     * This will be either a non-negative integer or an instance of\n     * {@link ExternalLayout} for which {@link\n     * ExternalLayout#isCount|isCount()} is `true`. */\n    _this7.count = count;\n    return _this7;\n  }\n\n  /** @override */\n  _createClass(Sequence, [{\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      if (0 <= this.span) {\n        return this.span;\n      }\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var span = 0;\n      var count = this.count;\n      if (count instanceof ExternalLayout) {\n        count = count.decode(b, offset);\n      }\n      if (0 < this.elementLayout.span) {\n        span = count * this.elementLayout.span;\n      } else {\n        var idx = 0;\n        while (idx < count) {\n          span += this.elementLayout.getSpan(b, offset + span);\n          ++idx;\n        }\n      }\n      return span;\n    }\n\n    /** @override */\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var rv = [];\n      var i = 0;\n      var count = this.count;\n      if (count instanceof ExternalLayout) {\n        count = count.decode(b, offset);\n      }\n      while (i < count) {\n        rv.push(this.elementLayout.decode(b, offset));\n        offset += this.elementLayout.getSpan(b, offset);\n        i += 1;\n      }\n      return rv;\n    }\n\n    /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n     *\n     * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n     * the unused space in the buffer is left unchanged.  If `src` is\n     * longer than {@link Sequence#count|count} the unneeded elements are\n     * ignored.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var elo = this.elementLayout;\n      var span = src.reduce(function (span, v) {\n        return span + elo.encode(v, b, offset + span);\n      }, 0);\n      if (this.count instanceof ExternalLayout) {\n        this.count.encode(src.length, b, offset);\n      }\n      return span;\n    }\n  }]);\n  return Sequence;\n}(Layout);\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */\nvar Structure = /*#__PURE__*/function (_Layout15) {\n  _inherits(Structure, _Layout15);\n  var _super17 = _createSuper(Structure);\n  function Structure(fields, property, decodePrefixes) {\n    var _this8;\n    _classCallCheck(this, Structure);\n    if (!(Array.isArray(fields) && fields.reduce(function (acc, v) {\n      return acc && v instanceof Layout;\n    }, true))) {\n      throw new TypeError('fields must be array of Layout instances');\n    }\n    if ('boolean' === typeof property && undefined === decodePrefixes) {\n      decodePrefixes = property;\n      property = undefined;\n    }\n\n    /* Verify absence of unnamed variable-length fields. */\n    var _iterator = _createForOfIteratorHelper(fields),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var fd = _step.value;\n        if (0 > fd.span && undefined === fd.property) {\n          throw new Error('fields cannot contain unnamed variable-length layout');\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var span = -1;\n    try {\n      span = fields.reduce(function (span, fd) {\n        return span + fd.getSpan();\n      }, 0);\n    } catch (e) {}\n    _this8 = _super17.call(this, span, property);\n\n    /** The sequence of {@link Layout} values that comprise the\n     * structure.\n     *\n     * The individual elements need not be the same type, and may be\n     * either scalar or aggregate layouts.  If a member layout leaves\n     * its {@link Layout#property|property} undefined the\n     * corresponding region of the buffer associated with the element\n     * will not be mutated.\n     *\n     * @type {Layout[]} */\n    _this8.fields = fields;\n\n    /** Control behavior of {@link Layout#decode|decode()} given short\n     * buffers.\n     *\n     * In some situations a structure many be extended with additional\n     * fields over time, with older installations providing only a\n     * prefix of the full structure.  If this property is `true`\n     * decoding will accept those buffers and leave subsequent fields\n     * undefined, as long as the buffer ends at a field boundary.\n     * Defaults to `false`. */\n    _this8.decodePrefixes = !!decodePrefixes;\n    return _this8;\n  }\n\n  /** @override */\n  _createClass(Structure, [{\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      if (0 <= this.span) {\n        return this.span;\n      }\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var span = 0;\n      try {\n        span = this.fields.reduce(function (span, fd) {\n          var fsp = fd.getSpan(b, offset);\n          offset += fsp;\n          return span + fsp;\n        }, 0);\n      } catch (e) {\n        throw new RangeError('indeterminate span');\n      }\n      return span;\n    }\n\n    /** @override */\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var dest = this.makeDestinationObject();\n      var _iterator2 = _createForOfIteratorHelper(this.fields),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var fd = _step2.value;\n          if (undefined !== fd.property) {\n            dest[fd.property] = fd.decode(b, offset);\n          }\n          offset += fd.getSpan(b, offset);\n          if (this.decodePrefixes && b.length === offset) {\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return dest;\n    }\n\n    /** Implement {@link Layout#encode|encode} for {@link Structure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the buffer is\n     * left unmodified. */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var firstOffset = offset;\n      var lastOffset = 0;\n      var lastWrote = 0;\n      var _iterator3 = _createForOfIteratorHelper(this.fields),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var fd = _step3.value;\n          var span = fd.span;\n          lastWrote = 0 < span ? span : 0;\n          if (undefined !== fd.property) {\n            var fv = src[fd.property];\n            if (undefined !== fv) {\n              lastWrote = fd.encode(fv, b, offset);\n              if (0 > span) {\n                /* Read the as-encoded span, which is not necessarily the\n                 * same as what we wrote. */\n                span = fd.getSpan(b, offset);\n              }\n            }\n          }\n          lastOffset = offset;\n          offset += span;\n        }\n        /* Use (lastOffset + lastWrote) instead of offset because the last\n         * item may have had a dynamic length and we don't want to include\n         * the padding between it and the end of the space reserved for\n         * it. */\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return lastOffset + lastWrote - firstOffset;\n    }\n\n    /** @override */\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(values) {\n      var dest = this.makeDestinationObject();\n      var _iterator4 = _createForOfIteratorHelper(this.fields),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var fd = _step4.value;\n          if (undefined !== fd.property && 0 < values.length) {\n            dest[fd.property] = values.shift();\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      return dest;\n    }\n\n    /**\n     * Get access to the layout of a given property.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Layout} - the layout associated with `property`, or\n     * undefined if there is no such property.\n     */\n  }, {\n    key: \"layoutFor\",\n    value: function layoutFor(property) {\n      if ('string' !== typeof property) {\n        throw new TypeError('property must be string');\n      }\n      var _iterator5 = _createForOfIteratorHelper(this.fields),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var fd = _step5.value;\n          if (fd.property === property) {\n            return fd;\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n\n    /**\n     * Get the offset of a structure member.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Number} - the offset in bytes to the start of `property`\n     * within the structure, or undefined if `property` is not a field\n     * within the structure.  If the property is a member but follows a\n     * variable-length structure member a negative number will be\n     * returned.\n     */\n  }, {\n    key: \"offsetOf\",\n    value: function offsetOf(property) {\n      if ('string' !== typeof property) {\n        throw new TypeError('property must be string');\n      }\n      var offset = 0;\n      var _iterator6 = _createForOfIteratorHelper(this.fields),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var fd = _step6.value;\n          if (fd.property === property) {\n            return offset;\n          }\n          if (0 > fd.span) {\n            offset = -1;\n          } else if (0 <= offset) {\n            offset += fd.span;\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  }]);\n  return Structure;\n}(Layout);\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */\nvar UnionDiscriminator = /*#__PURE__*/function () {\n  function UnionDiscriminator(property) {\n    _classCallCheck(this, UnionDiscriminator);\n    /** The {@link Layout#property|property} to be used when the\n     * discriminator is referenced in isolation (generally when {@link\n     * Union#decode|Union decode} cannot delegate to a specific\n     * variant). */\n    this.property = property;\n  }\n\n  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n   *\n   * The implementation of this method need not reference the buffer if\n   * variant information is available through other means. */\n  _createClass(UnionDiscriminator, [{\n    key: \"decode\",\n    value: function decode() {\n      throw new Error('UnionDiscriminator is abstract');\n    }\n\n    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n     *\n     * The implementation of this method need not store the value if\n     * variant information is maintained through other means. */\n  }, {\n    key: \"encode\",\n    value: function encode() {\n      throw new Error('UnionDiscriminator is abstract');\n    }\n  }]);\n  return UnionDiscriminator;\n}();\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */\nvar UnionLayoutDiscriminator = /*#__PURE__*/function (_UnionDiscriminator) {\n  _inherits(UnionLayoutDiscriminator, _UnionDiscriminator);\n  var _super18 = _createSuper(UnionLayoutDiscriminator);\n  function UnionLayoutDiscriminator(layout, property) {\n    var _this9;\n    _classCallCheck(this, UnionLayoutDiscriminator);\n    if (!(layout instanceof ExternalLayout && layout.isCount())) {\n      throw new TypeError('layout must be an unsigned integer ExternalLayout');\n    }\n    _this9 = _super18.call(this, property || layout.property || 'variant');\n\n    /** The {@link ExternalLayout} used to access the discriminator\n     * value. */\n    _this9.layout = layout;\n    return _this9;\n  }\n\n  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  _createClass(UnionLayoutDiscriminator, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      return this.layout.decode(b, offset);\n    }\n\n    /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      return this.layout.encode(src, b, offset);\n    }\n  }]);\n  return UnionLayoutDiscriminator;\n}(UnionDiscriminator);\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nvar Union = /*#__PURE__*/function (_Layout16) {\n  _inherits(Union, _Layout16);\n  var _super19 = _createSuper(Union);\n  function Union(discr, defaultLayout, property) {\n    var _this10;\n    _classCallCheck(this, Union);\n    var upv = discr instanceof UInt || discr instanceof UIntBE;\n    if (upv) {\n      discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n    } else if (discr instanceof ExternalLayout && discr.isCount()) {\n      discr = new UnionLayoutDiscriminator(discr);\n    } else if (!(discr instanceof UnionDiscriminator)) {\n      throw new TypeError('discr must be a UnionDiscriminator ' + 'or an unsigned integer layout');\n    }\n    if (undefined === defaultLayout) {\n      defaultLayout = null;\n    }\n    if (!(null === defaultLayout || defaultLayout instanceof Layout)) {\n      throw new TypeError('defaultLayout must be null or a Layout');\n    }\n    if (null !== defaultLayout) {\n      if (0 > defaultLayout.span) {\n        throw new Error('defaultLayout must have constant span');\n      }\n      if (undefined === defaultLayout.property) {\n        defaultLayout = defaultLayout.replicate('content');\n      }\n    }\n\n    /* The union span can be estimated only if there's a default\n     * layout.  The union spans its default layout, plus any prefix\n     * variant layout.  By construction both layouts, if present, have\n     * non-negative span. */\n    var span = -1;\n    if (defaultLayout) {\n      span = defaultLayout.span;\n      if (0 <= span && upv) {\n        span += discr.layout.span;\n      }\n    }\n    _this10 = _super19.call(this, span, property);\n\n    /** The interface for the discriminator value in isolation.\n     *\n     * This a {@link UnionDiscriminator} either passed to the\n     * constructor or synthesized from the `discr` constructor\n     * argument.  {@link\n     * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n     * `true` iff the `discr` parameter was a non-offset {@link\n     * Layout} instance. */\n    _this10.discriminator = discr;\n\n    /** `true` if the {@link Union#discriminator|discriminator} is the\n     * first field in the union.\n     *\n     * If `false` the discriminator is obtained from somewhere\n     * else. */\n    _this10.usesPrefixDiscriminator = upv;\n\n    /** The layout for non-discriminator content when the value of the\n     * discriminator is not recognized.\n     *\n     * This is the value passed to the constructor.  It is\n     * structurally equivalent to the second component of {@link\n     * Union#layout|layout} but may have a different property\n     * name. */\n    _this10.defaultLayout = defaultLayout;\n\n    /** A registry of allowed variants.\n     *\n     * The keys are unsigned integers which should be compatible with\n     * {@link Union.discriminator|discriminator}.  The property value\n     * is the corresponding {@link VariantLayout} instances assigned\n     * to this union by {@link Union#addVariant|addVariant}.\n     *\n     * **NOTE** The registry remains mutable so that variants can be\n     * {@link Union#addVariant|added} at any time.  Users should not\n     * manipulate the content of this property. */\n    _this10.registry = {};\n\n    /* Private variable used when invoking getSourceVariant */\n    var boundGetSourceVariant = _this10.defaultGetSourceVariant.bind(_assertThisInitialized(_this10));\n\n    /** Function to infer the variant selected by a source object.\n     *\n     * Defaults to {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n     * be overridden using {@link\n     * Union#configGetSourceVariant|configGetSourceVariant}.\n     *\n     * @param {Object} src - as with {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * @returns {(undefined|VariantLayout)} The default variant\n     * (`undefined`) or first registered variant that uses a property\n     * available in `src`. */\n    _this10.getSourceVariant = function (src) {\n      return boundGetSourceVariant(src);\n    };\n\n    /** Function to override the implementation of {@link\n     * Union#getSourceVariant|getSourceVariant}.\n     *\n     * Use this if the desired variant cannot be identified using the\n     * algorithm of {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * **NOTE** The provided function will be invoked bound to this\n     * Union instance, providing local access to {@link\n     * Union#registry|registry}.\n     *\n     * @param {Function} gsv - a function that follows the API of\n     * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */\n    _this10.configGetSourceVariant = function (gsv) {\n      boundGetSourceVariant = gsv.bind(this);\n    };\n    return _this10;\n  }\n\n  /** @override */\n  _createClass(Union, [{\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      if (0 <= this.span) {\n        return this.span;\n      }\n      if (undefined === offset) {\n        offset = 0;\n      }\n      /* Default layouts always have non-negative span, so we don't have\n       * one and we have to recognize the variant which will in turn\n       * determine the span. */\n      var vlo = this.getVariant(b, offset);\n      if (!vlo) {\n        throw new Error('unable to determine span for unrecognized variant');\n      }\n      return vlo.getSpan(b, offset);\n    }\n\n    /**\n     * Method to infer a registered Union variant compatible with `src`.\n     *\n     * The first satisified rule in the following sequence defines the\n     * return value:\n     * * If `src` has properties matching the Union discriminator and\n     *   the default layout, `undefined` is returned regardless of the\n     *   value of the discriminator property (this ensures the default\n     *   layout will be used);\n     * * If `src` has a property matching the Union discriminator, the\n     *   value of the discriminator identifies a registered variant, and\n     *   either (a) the variant has no layout, or (b) `src` has the\n     *   variant's property, then the variant is returned (because the\n     *   source satisfies the constraints of the variant it identifies);\n     * * If `src` does not have a property matching the Union\n     *   discriminator, but does have a property matching a registered\n     *   variant, then the variant is returned (because the source\n     *   matches a variant without an explicit conflict);\n     * * An error is thrown (because we either can't identify a variant,\n     *   or we were explicitly told the variant but can't satisfy it).\n     *\n     * @param {Object} src - an object presumed to be compatible with\n     * the content of the Union.\n     *\n     * @return {(undefined|VariantLayout)} - as described above.\n     *\n     * @throws {Error} - if `src` cannot be associated with a default or\n     * registered variant.\n     */\n  }, {\n    key: \"defaultGetSourceVariant\",\n    value: function defaultGetSourceVariant(src) {\n      if (src.hasOwnProperty(this.discriminator.property)) {\n        if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {\n          return undefined;\n        }\n        var vlo = this.registry[src[this.discriminator.property]];\n        if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {\n          return vlo;\n        }\n      } else {\n        for (var tag in this.registry) {\n          var _vlo = this.registry[tag];\n          if (src.hasOwnProperty(_vlo.property)) {\n            return _vlo;\n          }\n        }\n      }\n      throw new Error('unable to infer src variant');\n    }\n\n    /** Implement {@link Layout#decode|decode} for {@link Union}.\n     *\n     * If the variant is {@link Union#addVariant|registered} the return\n     * value is an instance of that variant, with no explicit\n     * discriminator.  Otherwise the {@link Union#defaultLayout|default\n     * layout} is used to decode the content. */\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var dest;\n      var dlo = this.discriminator;\n      var discr = dlo.decode(b, offset);\n      var clo = this.registry[discr];\n      if (undefined === clo) {\n        var contentOffset = 0;\n        clo = this.defaultLayout;\n        if (this.usesPrefixDiscriminator) {\n          contentOffset = dlo.layout.span;\n        }\n        dest = this.makeDestinationObject();\n        dest[dlo.property] = discr;\n        dest[clo.property] = this.defaultLayout.decode(b, offset + contentOffset);\n      } else {\n        dest = clo.decode(b, offset);\n      }\n      return dest;\n    }\n\n    /** Implement {@link Layout#encode|encode} for {@link Union}.\n     *\n     * This API assumes the `src` object is consistent with the union's\n     * {@link Union#defaultLayout|default layout}.  To encode variants\n     * use the appropriate variant-specific {@link VariantLayout#encode}\n     * method. */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var vlo = this.getSourceVariant(src);\n      if (undefined === vlo) {\n        var dlo = this.discriminator;\n        var clo = this.defaultLayout;\n        var contentOffset = 0;\n        if (this.usesPrefixDiscriminator) {\n          contentOffset = dlo.layout.span;\n        }\n        dlo.encode(src[dlo.property], b, offset);\n        return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);\n      }\n      return vlo.encode(src, b, offset);\n    }\n\n    /** Register a new variant structure within a union.  The newly\n     * created variant is returned.\n     *\n     * @param {Number} variant - initializer for {@link\n     * VariantLayout#variant|variant}.\n     *\n     * @param {Layout} layout - initializer for {@link\n     * VariantLayout#layout|layout}.\n     *\n     * @param {String} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {VariantLayout} */\n  }, {\n    key: \"addVariant\",\n    value: function addVariant(variant, layout, property) {\n      var rv = new VariantLayout(this, variant, layout, property);\n      this.registry[variant] = rv;\n      return rv;\n    }\n\n    /**\n     * Get the layout associated with a registered variant.\n     *\n     * If `vb` does not produce a registered variant the function returns\n     * `undefined`.\n     *\n     * @param {(Number|Buffer)} vb - either the variant number, or a\n     * buffer from which the discriminator is to be read.\n     *\n     * @param {Number} offset - offset into `vb` for the start of the\n     * union.  Used only when `vb` is an instance of {Buffer}.\n     *\n     * @return {({VariantLayout}|undefined)}\n     */\n  }, {\n    key: \"getVariant\",\n    value: function getVariant(vb, offset) {\n      var variant = vb;\n      if (Buffer.isBuffer(vb)) {\n        if (undefined === offset) {\n          offset = 0;\n        }\n        variant = this.discriminator.decode(vb, offset);\n      }\n      return this.registry[variant];\n    }\n  }]);\n  return Union;\n}(Layout);\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */\nvar VariantLayout = /*#__PURE__*/function (_Layout17) {\n  _inherits(VariantLayout, _Layout17);\n  var _super20 = _createSuper(VariantLayout);\n  function VariantLayout(union, variant, layout, property) {\n    var _this11;\n    _classCallCheck(this, VariantLayout);\n    if (!(union instanceof Union)) {\n      throw new TypeError('union must be a Union');\n    }\n    if (!Number.isInteger(variant) || 0 > variant) {\n      throw new TypeError('variant must be a (non-negative) integer');\n    }\n    if ('string' === typeof layout && undefined === property) {\n      property = layout;\n      layout = null;\n    }\n    if (layout) {\n      if (!(layout instanceof Layout)) {\n        throw new TypeError('layout must be a Layout');\n      }\n      if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) {\n        throw new Error('variant span exceeds span of containing union');\n      }\n      if ('string' !== typeof property) {\n        throw new TypeError('variant must have a String property');\n      }\n    }\n    var span = union.span;\n    if (0 > union.span) {\n      span = layout ? layout.span : 0;\n      if (0 <= span && union.usesPrefixDiscriminator) {\n        span += union.discriminator.layout.span;\n      }\n    }\n    _this11 = _super20.call(this, span, property);\n\n    /** The {@link Union} to which this variant belongs. */\n    _this11.union = union;\n\n    /** The unsigned integral value identifying this variant within\n     * the {@link Union#discriminator|discriminator} of the containing\n     * union. */\n    _this11.variant = variant;\n\n    /** The {@link Layout} to be used when reading/writing the\n     * non-discriminator part of the {@link\n     * VariantLayout#union|union}.  If `null` the variant carries no\n     * data. */\n    _this11.layout = layout || null;\n    return _this11;\n  }\n\n  /** @override */\n  _createClass(VariantLayout, [{\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      if (0 <= this.span) {\n        /* Will be equal to the containing union span if that is not\n         * variable. */\n        return this.span;\n      }\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var contentOffset = 0;\n      if (this.union.usesPrefixDiscriminator) {\n        contentOffset = this.union.discriminator.layout.span;\n      }\n      /* Span is defined solely by the variant (and prefix discriminator) */\n      return contentOffset + this.layout.getSpan(b, offset + contentOffset);\n    }\n\n    /** @override */\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      var dest = this.makeDestinationObject();\n      if (undefined === offset) {\n        offset = 0;\n      }\n      if (this !== this.union.getVariant(b, offset)) {\n        throw new Error('variant mismatch');\n      }\n      var contentOffset = 0;\n      if (this.union.usesPrefixDiscriminator) {\n        contentOffset = this.union.discriminator.layout.span;\n      }\n      if (this.layout) {\n        dest[this.property] = this.layout.decode(b, offset + contentOffset);\n      } else if (this.property) {\n        dest[this.property] = true;\n      } else if (this.union.usesPrefixDiscriminator) {\n        dest[this.union.discriminator.property] = this.variant;\n      }\n      return dest;\n    }\n\n    /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var contentOffset = 0;\n      if (this.union.usesPrefixDiscriminator) {\n        contentOffset = this.union.discriminator.layout.span;\n      }\n      if (this.layout && !src.hasOwnProperty(this.property)) {\n        throw new TypeError('variant lacks property ' + this.property);\n      }\n      this.union.discriminator.encode(this.variant, b, offset);\n      var span = contentOffset;\n      if (this.layout) {\n        this.layout.encode(src[this.property], b, offset + contentOffset);\n        span += this.layout.getSpan(b, offset + contentOffset);\n        if (0 <= this.union.span && span > this.union.span) {\n          throw new Error('encoded variant overruns containing union');\n        }\n      }\n      return span;\n    }\n\n    /** Delegate {@link Layout#fromArray|fromArray} to {@link\n     * VariantLayout#layout|layout}. */\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(values) {\n      if (this.layout) {\n        return this.layout.fromArray(values);\n      }\n    }\n  }]);\n  return VariantLayout;\n}(Layout);\n/** JavaScript chose to define bitwise operations as operating on\n * signed 32-bit values in 2's complement form, meaning any integer\n * with bit 31 set is going to look negative.  For right shifts that's\n * not a problem, because `>>>` is a logical shift, but for every\n * other bitwise operator we have to compensate for possible negative\n * results. */\nfunction fixBitwiseResult(v) {\n  if (0 > v) {\n    v += 0x100000000;\n  }\n  return v;\n}\n\n/**\n * Contain a sequence of bit fields as an unsigned integer.\n *\n * *Factory*: {@link module:Layout.bits|bits}\n *\n * This is a container element; within it there are {@link BitField}\n * instances that provide the extracted properties.  The container\n * simply defines the aggregate representation and its bit ordering.\n * The representation is an object containing properties with numeric\n * or {@link Boolean} values.\n *\n * {@link BitField}s are added with the {@link\n * BitStructure#addField|addField} and {@link\n * BitStructure#addBoolean|addBoolean} methods.\n\n * @param {Layout} word - initializer for {@link\n * BitStructure#word|word}.  The parameter must be an instance of\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\n *\n * @param {bool} [msb] - `true` if the bit numbering starts at the\n * most significant bit of the containing word; `false` (default) if\n * it starts at the least significant bit of the containing word.  If\n * the parameter at this position is a string and `property` is\n * `undefined` the value of this argument will instead be used as the\n * value of `property`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nvar BitStructure = /*#__PURE__*/function (_Layout18) {\n  _inherits(BitStructure, _Layout18);\n  var _super21 = _createSuper(BitStructure);\n  function BitStructure(word, msb, property) {\n    var _this12;\n    _classCallCheck(this, BitStructure);\n    if (!(word instanceof UInt || word instanceof UIntBE)) {\n      throw new TypeError('word must be a UInt or UIntBE layout');\n    }\n    if ('string' === typeof msb && undefined === property) {\n      property = msb;\n      msb = undefined;\n    }\n    if (4 < word.span) {\n      throw new RangeError('word cannot exceed 32 bits');\n    }\n    _this12 = _super21.call(this, word.span, property);\n\n    /** The layout used for the packed value.  {@link BitField}\n     * instances are packed sequentially depending on {@link\n     * BitStructure#msb|msb}. */\n    _this12.word = word;\n\n    /** Whether the bit sequences are packed starting at the most\n     * significant bit growing down (`true`), or the least significant\n     * bit growing up (`false`).\n     *\n     * **NOTE** Regardless of this value, the least significant bit of\n     * any {@link BitField} value is the least significant bit of the\n     * corresponding section of the packed value. */\n    _this12.msb = !!msb;\n\n    /** The sequence of {@link BitField} layouts that comprise the\n     * packed structure.\n     *\n     * **NOTE** The array remains mutable to allow fields to be {@link\n     * BitStructure#addField|added} after construction.  Users should\n     * not manipulate the content of this property.*/\n    _this12.fields = [];\n\n    /* Storage for the value.  Capture a variable instead of using an\n     * instance property because we don't want anything to change the\n     * value without going through the mutator. */\n    var value = 0;\n    _this12._packedSetValue = function (v) {\n      value = fixBitwiseResult(v);\n      return this;\n    };\n    _this12._packedGetValue = function () {\n      return value;\n    };\n    return _this12;\n  }\n\n  /** @override */\n  _createClass(BitStructure, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      var dest = this.makeDestinationObject();\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var value = this.word.decode(b, offset);\n      this._packedSetValue(value);\n      var _iterator7 = _createForOfIteratorHelper(this.fields),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var fd = _step7.value;\n          if (undefined !== fd.property) {\n            dest[fd.property] = fd.decode(value);\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      return dest;\n    }\n\n    /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the packed\n     * value is left unmodified.  Unused bits are also left unmodified. */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var value = this.word.decode(b, offset);\n      this._packedSetValue(value);\n      var _iterator8 = _createForOfIteratorHelper(this.fields),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var fd = _step8.value;\n          if (undefined !== fd.property) {\n            var fv = src[fd.property];\n            if (undefined !== fv) {\n              fd.encode(fv);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n      return this.word.encode(this._packedGetValue(), b, offset);\n    }\n\n    /** Register a new bitfield with a containing bit structure.  The\n     * resulting bitfield is returned.\n     *\n     * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {BitField} */\n  }, {\n    key: \"addField\",\n    value: function addField(bits, property) {\n      var bf = new BitField(this, bits, property);\n      this.fields.push(bf);\n      return bf;\n    }\n\n    /** As with {@link BitStructure#addField|addField} for single-bit\n     * fields with `boolean` value representation.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {Boolean} */\n  }, {\n    key: \"addBoolean\",\n    value: function addBoolean(property) {\n      // This is my Boolean, not the Javascript one.\n      // eslint-disable-next-line no-new-wrappers\n      var bf = new Boolean(this, property);\n      this.fields.push(bf);\n      return bf;\n    }\n\n    /**\n     * Get access to the bit field for a given property.\n     *\n     * @param {String} property - the bit field of interest.\n     *\n     * @return {BitField} - the field associated with `property`, or\n     * undefined if there is no such property.\n     */\n  }, {\n    key: \"fieldFor\",\n    value: function fieldFor(property) {\n      if ('string' !== typeof property) {\n        throw new TypeError('property must be string');\n      }\n      var _iterator9 = _createForOfIteratorHelper(this.fields),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var fd = _step9.value;\n          if (fd.property === property) {\n            return fd;\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    }\n  }]);\n  return BitStructure;\n}(Layout);\n/**\n * Represent a sequence of bits within a {@link BitStructure}.\n *\n * All bit field values are represented as unsigned integers.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addField|addField} helper\n * method.\n *\n * **NOTE** BitField instances are not instances of {@link Layout}\n * since {@link Layout#span|span} measures 8-bit units.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n */\nvar BitField = /*#__PURE__*/function () {\n  function BitField(container, bits, property) {\n    _classCallCheck(this, BitField);\n    if (!(container instanceof BitStructure)) {\n      throw new TypeError('container must be a BitStructure');\n    }\n    if (!Number.isInteger(bits) || 0 >= bits) {\n      throw new TypeError('bits must be positive integer');\n    }\n    var totalBits = 8 * container.span;\n    var usedBits = container.fields.reduce(function (sum, fd) {\n      return sum + fd.bits;\n    }, 0);\n    if (bits + usedBits > totalBits) {\n      throw new Error('bits too long for span remainder (' + (totalBits - usedBits) + ' of ' + totalBits + ' remain)');\n    }\n\n    /** The {@link BitStructure} instance to which this bit field\n     * belongs. */\n    this.container = container;\n\n    /** The span of this value in bits. */\n    this.bits = bits;\n\n    /** A mask of {@link BitField#bits|bits} bits isolating value bits\n     * that fit within the field.\n     *\n     * That is, it masks a value that has not yet been shifted into\n     * position within its containing packed integer. */\n    this.valueMask = (1 << bits) - 1;\n    if (32 === bits) {\n      // shifted value out of range\n      this.valueMask = 0xFFFFFFFF;\n    }\n\n    /** The offset of the value within the containing packed unsigned\n     * integer.  The least significant bit of the packed value is at\n     * offset zero, regardless of bit ordering used. */\n    this.start = usedBits;\n    if (this.container.msb) {\n      this.start = totalBits - usedBits - bits;\n    }\n\n    /** A mask of {@link BitField#bits|bits} isolating the field value\n     * within the containing packed unsigned integer. */\n    this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n\n    /** The property name used when this bitfield is represented in an\n     * Object.\n     *\n     * Intended to be functionally equivalent to {@link\n     * Layout#property}.\n     *\n     * If left undefined the corresponding span of bits will be\n     * treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n    this.property = property;\n  }\n\n  /** Store a value into the corresponding subsequence of the containing\n   * bit field. */\n  _createClass(BitField, [{\n    key: \"decode\",\n    value: function decode() {\n      var word = this.container._packedGetValue();\n      var wordValue = fixBitwiseResult(word & this.wordMask);\n      var value = wordValue >>> this.start;\n      return value;\n    }\n\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field.\n     *\n     * **NOTE** This is not a specialization of {@link\n     * Layout#encode|Layout.encode} and there is no return value. */\n  }, {\n    key: \"encode\",\n    value: function encode(value) {\n      if (!Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {\n        throw new TypeError(nameWithProperty('BitField.encode', this) + ' value must be integer not exceeding ' + this.valueMask);\n      }\n      var word = this.container._packedGetValue();\n      var wordValue = fixBitwiseResult(value << this.start);\n      this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);\n    }\n  }]);\n  return BitField;\n}();\n/**\n * Represent a single bit within a {@link BitStructure} as a\n * JavaScript boolean.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\n * method.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {BitField}\n */\n/* eslint-disable no-extend-native */\nvar Boolean = /*#__PURE__*/function (_BitField) {\n  _inherits(Boolean, _BitField);\n  var _super22 = _createSuper(Boolean);\n  function Boolean(container, property) {\n    _classCallCheck(this, Boolean);\n    return _super22.call(this, container, 1, property);\n  }\n\n  /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n   *\n   * @returns {boolean} */\n  _createClass(Boolean, [{\n    key: \"decode\",\n    value: function decode(b, offset) {\n      return !!BitField.prototype.decode.call(this, b, offset);\n    }\n\n    /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(value) {\n      if ('boolean' === typeof value) {\n        // BitField requires integer values\n        value = +value;\n      }\n      return BitField.prototype.encode.call(this, value);\n    }\n  }]);\n  return Boolean;\n}(BitField);\n/* eslint-enable no-extend-native */\n/**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Buffer.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nvar Blob = /*#__PURE__*/function (_Layout19) {\n  _inherits(Blob, _Layout19);\n  var _super23 = _createSuper(Blob);\n  function Blob(length, property) {\n    var _this13;\n    _classCallCheck(this, Blob);\n    if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {\n      throw new TypeError('length must be positive integer ' + 'or an unsigned integer ExternalLayout');\n    }\n    var span = -1;\n    if (!(length instanceof ExternalLayout)) {\n      span = length;\n    }\n    _this13 = _super23.call(this, span, property);\n\n    /** The number of bytes in the blob.\n     *\n     * This may be a non-negative integer, or an instance of {@link\n     * ExternalLayout} that satisfies {@link\n     * ExternalLayout#isCount|isCount()}. */\n    _this13.length = length;\n    return _this13;\n  }\n\n  /** @override */\n  _createClass(Blob, [{\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      var span = this.span;\n      if (0 > span) {\n        span = this.length.decode(b, offset);\n      }\n      return span;\n    }\n\n    /** @override */\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var span = this.span;\n      if (0 > span) {\n        span = this.length.decode(b, offset);\n      }\n      return b.slice(offset, offset + span);\n    }\n\n    /** Implement {@link Layout#encode|encode} for {@link Blob}.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      var span = this.length;\n      if (this.length instanceof ExternalLayout) {\n        span = src.length;\n      }\n      if (!(Buffer.isBuffer(src) && span === src.length)) {\n        throw new TypeError(nameWithProperty('Blob.encode', this) + ' requires (length ' + span + ') Buffer as src');\n      }\n      if (offset + span > b.length) {\n        throw new RangeError('encoding overruns Buffer');\n      }\n      b.write(src.toString('hex'), offset, span, 'hex');\n      if (this.length instanceof ExternalLayout) {\n        this.length.encode(span, b, offset);\n      }\n      return span;\n    }\n  }]);\n  return Blob;\n}(Layout);\n/**\n * Contain a `NUL`-terminated UTF8 string.\n *\n * *Factory*: {@link module:Layout.cstr|cstr}\n *\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\n * not be correctly decoded by this layout.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nvar CString = /*#__PURE__*/function (_Layout20) {\n  _inherits(CString, _Layout20);\n  var _super24 = _createSuper(CString);\n  function CString(property) {\n    _classCallCheck(this, CString);\n    return _super24.call(this, -1, property);\n  }\n\n  /** @override */\n  _createClass(CString, [{\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      if (!Buffer.isBuffer(b)) {\n        throw new TypeError('b must be a Buffer');\n      }\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var idx = offset;\n      while (idx < b.length && 0 !== b[idx]) {\n        idx += 1;\n      }\n      return 1 + idx - offset;\n    }\n\n    /** @override */\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset, dest) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var span = this.getSpan(b, offset);\n      return b.slice(offset, offset + span - 1).toString('utf-8');\n    }\n\n    /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      /* Must force this to a string, lest it be a number and the\n       * \"utf8-encoding\" below actually allocate a buffer of length\n       * src */\n      if ('string' !== typeof src) {\n        src = src.toString();\n      }\n      var srcb = new Buffer(src, 'utf8');\n      var span = srcb.length;\n      if (offset + span > b.length) {\n        throw new RangeError('encoding overruns Buffer');\n      }\n      srcb.copy(b, offset);\n      b[offset + span] = 0;\n      return span + 1;\n    }\n  }]);\n  return CString;\n}(Layout);\n/**\n * Contain a UTF8 string with implicit length.\n *\n * *Factory*: {@link module:Layout.utf8|utf8}\n *\n * **NOTE** Because the length is implicit in the size of the buffer\n * this layout should be used only in isolation, or in a situation\n * where the length can be expressed by operating on a slice of the\n * containing buffer.\n *\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\n * string content.  If not provided there is no bound on the allowed\n * content.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nvar UTF8 = /*#__PURE__*/function (_Layout21) {\n  _inherits(UTF8, _Layout21);\n  var _super25 = _createSuper(UTF8);\n  function UTF8(maxSpan, property) {\n    var _this14;\n    _classCallCheck(this, UTF8);\n    if ('string' === typeof maxSpan && undefined === property) {\n      property = maxSpan;\n      maxSpan = undefined;\n    }\n    if (undefined === maxSpan) {\n      maxSpan = -1;\n    } else if (!Number.isInteger(maxSpan)) {\n      throw new TypeError('maxSpan must be an integer');\n    }\n    _this14 = _super25.call(this, -1, property);\n\n    /** The maximum span of the layout in bytes.\n     *\n     * Positive values are generally expected.  Zero is abnormal.\n     * Attempts to encode or decode a value that exceeds this length\n     * will throw a `RangeError`.\n     *\n     * A negative value indicates that there is no bound on the length\n     * of the content. */\n    _this14.maxSpan = maxSpan;\n    return _this14;\n  }\n\n  /** @override */\n  _createClass(UTF8, [{\n    key: \"getSpan\",\n    value: function getSpan(b, offset) {\n      if (!Buffer.isBuffer(b)) {\n        throw new TypeError('b must be a Buffer');\n      }\n      if (undefined === offset) {\n        offset = 0;\n      }\n      return b.length - offset;\n    }\n\n    /** @override */\n  }, {\n    key: \"decode\",\n    value: function decode(b, offset, dest) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      var span = this.getSpan(b, offset);\n      if (0 <= this.maxSpan && this.maxSpan < span) {\n        throw new RangeError('text length exceeds maxSpan');\n      }\n      return b.slice(offset, offset + span).toString('utf-8');\n    }\n\n    /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      /* Must force this to a string, lest it be a number and the\n       * \"utf8-encoding\" below actually allocate a buffer of length\n       * src */\n      if ('string' !== typeof src) {\n        src = src.toString();\n      }\n      var srcb = new Buffer(src, 'utf8');\n      var span = srcb.length;\n      if (0 <= this.maxSpan && this.maxSpan < span) {\n        throw new RangeError('text length exceeds maxSpan');\n      }\n      if (offset + span > b.length) {\n        throw new RangeError('encoding overruns Buffer');\n      }\n      srcb.copy(b, offset);\n      return span;\n    }\n  }]);\n  return UTF8;\n}(Layout);\n/**\n * Contain a constant value.\n *\n * This layout may be used in cases where a JavaScript value can be\n * inferred without an expression in the binary encoding.  An example\n * would be a {@link VariantLayout|variant layout} where the content\n * is implied by the union {@link Union#discriminator|discriminator}.\n *\n * @param {Object|Number|String} value - initializer for {@link\n * Constant#value|value}.  If the value is an object (or array) and\n * the application intends the object to remain unchanged regardless\n * of what is done to values decoded by this layout, the value should\n * be frozen prior passing it to this constructor.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nvar Constant = /*#__PURE__*/function (_Layout22) {\n  _inherits(Constant, _Layout22);\n  var _super26 = _createSuper(Constant);\n  function Constant(value, property) {\n    var _this15;\n    _classCallCheck(this, Constant);\n    _this15 = _super26.call(this, 0, property);\n\n    /** The value produced by this constant when the layout is {@link\n     * Constant#decode|decoded}.\n     *\n     * Any JavaScript value including `null` and `undefined` is\n     * permitted.\n     *\n     * **WARNING** If `value` passed in the constructor was not\n     * frozen, it is possible for users of decoded values to change\n     * the content of the value. */\n    _this15.value = value;\n    return _this15;\n  }\n\n  /** @override */\n  _createClass(Constant, [{\n    key: \"decode\",\n    value: function decode(b, offset, dest) {\n      return this.value;\n    }\n\n    /** @override */\n  }, {\n    key: \"encode\",\n    value: function encode(src, b, offset) {\n      /* Constants take no space */\n      return 0;\n    }\n  }]);\n  return Constant;\n}(Layout);\nexports.ExternalLayout = ExternalLayout;\nexports.GreedyCount = GreedyCount;\nexports.OffsetLayout = OffsetLayout;\nexports.UInt = UInt;\nexports.UIntBE = UIntBE;\nexports.Int = Int;\nexports.IntBE = IntBE;\nexports.Float = Float;\nexports.FloatBE = FloatBE;\nexports.Double = Double;\nexports.DoubleBE = DoubleBE;\nexports.Sequence = Sequence;\nexports.Structure = Structure;\nexports.UnionDiscriminator = UnionDiscriminator;\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\nexports.Union = Union;\nexports.VariantLayout = VariantLayout;\nexports.BitStructure = BitStructure;\nexports.BitField = BitField;\nexports.Boolean = Boolean;\nexports.Blob = Blob;\nexports.CString = CString;\nexports.UTF8 = UTF8;\nexports.Constant = Constant;\n\n/** Factory for {@link GreedyCount}. */\nexports.greedy = function (elementSpan, property) {\n  return new GreedyCount(elementSpan, property);\n};\n\n/** Factory for {@link OffsetLayout}. */\nexports.offset = function (layout, offset, property) {\n  return new OffsetLayout(layout, offset, property);\n};\n\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */\nexports.u8 = function (property) {\n  return new UInt(1, property);\n};\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16 = function (property) {\n  return new UInt(2, property);\n};\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24 = function (property) {\n  return new UInt(3, property);\n};\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32 = function (property) {\n  return new UInt(4, property);\n};\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40 = function (property) {\n  return new UInt(5, property);\n};\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48 = function (property) {\n  return new UInt(6, property);\n};\n\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64 = function (property) {\n  return new NearUInt64(property);\n};\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16be = function (property) {\n  return new UIntBE(2, property);\n};\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24be = function (property) {\n  return new UIntBE(3, property);\n};\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32be = function (property) {\n  return new UIntBE(4, property);\n};\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40be = function (property) {\n  return new UIntBE(5, property);\n};\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48be = function (property) {\n  return new UIntBE(6, property);\n};\n\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64be = function (property) {\n  return new NearUInt64BE(property);\n};\n\n/** Factory for {@link Int|signed int layouts} spanning one\n * byte. */\nexports.s8 = function (property) {\n  return new Int(1, property);\n};\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning two bytes. */\nexports.s16 = function (property) {\n  return new Int(2, property);\n};\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning three bytes. */\nexports.s24 = function (property) {\n  return new Int(3, property);\n};\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning four bytes. */\nexports.s32 = function (property) {\n  return new Int(4, property);\n};\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning five bytes. */\nexports.s40 = function (property) {\n  return new Int(5, property);\n};\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning six bytes. */\nexports.s48 = function (property) {\n  return new Int(6, property);\n};\n\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64 = function (property) {\n  return new NearInt64(property);\n};\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning two bytes. */\nexports.s16be = function (property) {\n  return new IntBE(2, property);\n};\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning three bytes. */\nexports.s24be = function (property) {\n  return new IntBE(3, property);\n};\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning four bytes. */\nexports.s32be = function (property) {\n  return new IntBE(4, property);\n};\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning five bytes. */\nexports.s40be = function (property) {\n  return new IntBE(5, property);\n};\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning six bytes. */\nexports.s48be = function (property) {\n  return new IntBE(6, property);\n};\n\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64be = function (property) {\n  return new NearInt64BE(property);\n};\n\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */\nexports.f32 = function (property) {\n  return new Float(property);\n};\n\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */\nexports.f32be = function (property) {\n  return new FloatBE(property);\n};\n\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */\nexports.f64 = function (property) {\n  return new Double(property);\n};\n\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */\nexports.f64be = function (property) {\n  return new DoubleBE(property);\n};\n\n/** Factory for {@link Structure} values. */\nexports.struct = function (fields, property, decodePrefixes) {\n  return new Structure(fields, property, decodePrefixes);\n};\n\n/** Factory for {@link BitStructure} values. */\nexports.bits = function (word, msb, property) {\n  return new BitStructure(word, msb, property);\n};\n\n/** Factory for {@link Sequence} values. */\nexports.seq = function (elementLayout, count, property) {\n  return new Sequence(elementLayout, count, property);\n};\n\n/** Factory for {@link Union} values. */\nexports.union = function (discr, defaultLayout, property) {\n  return new Union(discr, defaultLayout, property);\n};\n\n/** Factory for {@link UnionLayoutDiscriminator} values. */\nexports.unionLayoutDiscriminator = function (layout, property) {\n  return new UnionLayoutDiscriminator(layout, property);\n};\n\n/** Factory for {@link Blob} values. */\nexports.blob = function (length, property) {\n  return new Blob(length, property);\n};\n\n/** Factory for {@link CString} values. */\nexports.cstr = function (property) {\n  return new CString(property);\n};\n\n/** Factory for {@link UTF8} values. */\nexports.utf8 = function (maxSpan, property) {\n  return new UTF8(maxSpan, property);\n};\n\n/** Factory for {@link Constant} values. */\nexports.const = function (value, property) {\n  return new Constant(value, property);\n};","map":{"version":3,"names":["_assertThisInitialized","require","default","_createForOfIteratorHelper","_inherits","_createSuper","_classCallCheck","_createClass","Layout","span","property","Number","isInteger","TypeError","key","value","makeDestinationObject","decode","b","offset","Error","encode","src","getSpan","RangeError","replicate","rv","Object","create","constructor","prototype","assign","fromArray","values","undefined","exports","nameWithProperty","name","lo","bindConstructorLayout","Class","layout","hasOwnProperty","layout_","boundConstructor_","defineProperty","writable","ExternalLayout","_Layout","_super","apply","arguments","isCount","GreedyCount","_ExternalLayout","_super2","elementSpan","_this","call","rem","length","Math","floor","OffsetLayout","_ExternalLayout2","_super3","_this2","UInt","UIntBE","_Layout2","_super4","_this3","readUIntLE","writeUIntLE","_Layout3","_super5","_this4","readUIntBE","writeUIntBE","Int","_Layout4","_super6","_this5","readIntLE","writeIntLE","IntBE","_Layout5","_super7","_this6","readIntBE","writeIntBE","V2E32","pow","divmodInt64","hi32","lo32","roundedInt64","NearUInt64","_Layout6","_super8","readUInt32LE","split","writeUInt32LE","NearUInt64BE","_Layout7","_super9","readUInt32BE","writeUInt32BE","NearInt64","_Layout8","_super10","readInt32LE","writeInt32LE","NearInt64BE","_Layout9","_super11","readInt32BE","writeInt32BE","Float","_Layout10","_super12","readFloatLE","writeFloatLE","FloatBE","_Layout11","_super13","readFloatBE","writeFloatBE","Double","_Layout12","_super14","readDoubleLE","writeDoubleLE","DoubleBE","_Layout13","_super15","readDoubleBE","writeDoubleBE","Sequence","_Layout14","_super16","elementLayout","count","_this7","idx","i","push","elo","reduce","v","Structure","_Layout15","_super17","fields","decodePrefixes","_this8","Array","isArray","acc","_iterator","_step","s","n","done","fd","err","e","f","fsp","dest","_iterator2","_step2","firstOffset","lastOffset","lastWrote","_iterator3","_step3","fv","_iterator4","_step4","shift","layoutFor","_iterator5","_step5","offsetOf","_iterator6","_step6","UnionDiscriminator","UnionLayoutDiscriminator","_UnionDiscriminator","_super18","_this9","Union","_Layout16","_super19","discr","defaultLayout","_this10","upv","discriminator","usesPrefixDiscriminator","registry","boundGetSourceVariant","defaultGetSourceVariant","bind","getSourceVariant","configGetSourceVariant","gsv","vlo","getVariant","tag","dlo","clo","contentOffset","addVariant","variant","VariantLayout","vb","Buffer","isBuffer","_Layout17","_super20","union","_this11","fixBitwiseResult","BitStructure","_Layout18","_super21","word","msb","_this12","_packedSetValue","_packedGetValue","_iterator7","_step7","_iterator8","_step8","addField","bits","bf","BitField","addBoolean","Boolean","fieldFor","_iterator9","_step9","container","totalBits","usedBits","sum","valueMask","start","wordMask","wordValue","_BitField","_super22","Blob","_Layout19","_super23","_this13","slice","write","toString","CString","_Layout20","_super24","srcb","copy","UTF8","_Layout21","_super25","maxSpan","_this14","Constant","_Layout22","_super26","_this15","greedy","u8","u16","u24","u32","u40","u48","nu64","u16be","u24be","u32be","u40be","u48be","nu64be","s8","s16","s24","s32","s40","s48","ns64","s16be","s24be","s32be","s40be","s48be","ns64be","f32","f32be","f64","f64be","struct","seq","unionLayoutDiscriminator","blob","cstr","utf8","const"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/buffer-layout/lib/Layout.js"],"sourcesContent":["/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * Support for translating between Buffer instances and JavaScript\n * native types.\n *\n * {@link module:Layout~Layout|Layout} is the basis of a class\n * hierarchy that associates property names with sequences of encoded\n * bytes.\n *\n * Layouts are supported for these scalar (numeric) types:\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\n *   format} with {@link module:Layout.u8|8-bit}, {@link\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\n *   {@link module:Layout.u32|32-bit}, {@link\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\n *   {@link module:Layout.u40be|40-bit}, and {@link\n *   module:Layout.u48be|48-bit} representation ranges;\n * * {@link module:Layout~Int|Signed integers in little-endian\n *   format} with {@link module:Layout.s8|8-bit}, {@link\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\n *   {@link module:Layout.s32|32-bit}, {@link\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\n *   with {@link module:Layout.s16be|16-bit}, {@link\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\n *   {@link module:Layout.s40be|40-bit}, and {@link\n *   module:Layout.s48be|48-bit} representation ranges;\n * * 64-bit integral values that decode to an exact (if magnitude is\n *   less than 2^53) or nearby integral Number in {@link\n *   module:Layout.nu64|unsigned little-endian}, {@link\n *   module:Layout.nu64be|unsigned big-endian}, {@link\n *   module:Layout.ns64|signed little-endian}, and {@link\n *   module:Layout.ns64be|unsigned big-endian} encodings;\n * * 32-bit floating point values with {@link\n *   module:Layout.f32|little-endian} and {@link\n *   module:Layout.f32be|big-endian} representations;\n * * 64-bit floating point values with {@link\n *   module:Layout.f64|little-endian} and {@link\n *   module:Layout.f64be|big-endian} representations;\n * * {@link module:Layout.const|Constants} that take no space in the\n *   encoded expression.\n *\n * and for these aggregate types:\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\n *   module:Layout~Layout|Layout}, with JavaScript representation as\n *   an Array and constant or data-dependent {@link\n *   module:Layout~Sequence#count|length};\n * * {@link module:Layout.struct|Structure}s that aggregate a\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\n *   instances, with JavaScript representation as an Object;\n * * {@link module:Layout.union|Union}s that support multiple {@link\n *   module:Layout~VariantLayout|variant layouts} over a fixed\n *   (padded) or variable (not padded) span of bytes, using an\n *   unsigned integer at the start of the data or a separate {@link\n *   module:Layout.unionLayoutDiscriminator|layout element} to\n *   determine which layout to use when interpreting the buffer\n *   contents;\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\n *   of individual {@link\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\n *   16, 24, or 32-bit unsigned integer starting at the least- or\n *   most-significant bit;\n * * {@link module:Layout.cstr|C strings} of varying length;\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\n *   module:Layout~Blob#length|length} raw data.\n *\n * All {@link module:Layout~Layout|Layout} instances are immutable\n * after construction, to prevent internal state from becoming\n * inconsistent.\n *\n * @local Layout\n * @local ExternalLayout\n * @local GreedyCount\n * @local OffsetLayout\n * @local UInt\n * @local UIntBE\n * @local Int\n * @local IntBE\n * @local NearUInt64\n * @local NearUInt64BE\n * @local NearInt64\n * @local NearInt64BE\n * @local Float\n * @local FloatBE\n * @local Double\n * @local DoubleBE\n * @local Sequence\n * @local Structure\n * @local UnionDiscriminator\n * @local UnionLayoutDiscriminator\n * @local Union\n * @local VariantLayout\n * @local BitStructure\n * @local BitField\n * @local Boolean\n * @local Blob\n * @local CString\n * @local Constant\n * @local bindConstructorLayout\n * @module Layout\n * @license MIT\n * @author Peter A. Bigot\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\n */\n\n'use strict';\n\n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */\nclass Layout {\n  constructor(span, property) {\n    if (!Number.isInteger(span)) {\n      throw new TypeError('span must be an integer');\n    }\n\n    /** The span of the layout in bytes.\n     *\n     * Positive values are generally expected.\n     *\n     * Zero will only appear in {@link Constant}s and in {@link\n     * Sequence}s where the {@link Sequence#count|count} is zero.\n     *\n     * A negative value indicates that the span is value-specific, and\n     * must be obtained using {@link Layout#getSpan|getSpan}. */\n    this.span = span;\n\n    /** The property name used when this layout is represented in an\n     * Object.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances.  If left undefined the span of the unnamed layout will\n     * be treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n    this.property = property;\n  }\n\n  /** Function to create an Object into which decoded properties will\n   * be written.\n   *\n   * Used only for layouts that {@link Layout#decode|decode} to Object\n   * instances, which means:\n   * * {@link Structure}\n   * * {@link Union}\n   * * {@link VariantLayout}\n   * * {@link BitStructure}\n   *\n   * If left undefined the JavaScript representation of these layouts\n   * will be Object instances.\n   *\n   * See {@link bindConstructorLayout}.\n   */\n  makeDestinationObject() {\n    return {};\n  }\n\n  /**\n   * Decode from a Buffer into an JavaScript value.\n   *\n   * @param {Buffer} b - the buffer from which encoded data is read.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {(Number|Array|Object)} - the value of the decoded data.\n   *\n   * @abstract\n   */\n  decode(b, offset) {\n    throw new Error('Layout is abstract');\n  }\n\n  /**\n   * Encode a JavaScript value into a Buffer.\n   *\n   * @param {(Number|Array|Object)} src - the value to be encoded into\n   * the buffer.  The type accepted depends on the (sub-)type of {@link\n   * Layout}.\n   *\n   * @param {Buffer} b - the buffer into which encoded data will be\n   * written.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {Number} - the number of bytes encoded, including the\n   * space skipped for internal padding, but excluding data such as\n   * {@link Sequence#count|lengths} when stored {@link\n   * ExternalLayout|externally}.  This is the adjustment to `offset`\n   * producing the offset where data for the next layout would be\n   * written.\n   *\n   * @abstract\n   */\n  encode(src, b, offset) {\n    throw new Error('Layout is abstract');\n  }\n\n  /**\n   * Calculate the span of a specific instance of a layout.\n   *\n   * @param {Buffer} b - the buffer that contains an encoded instance.\n   *\n   * @param {Number} [offset] - the offset at which the encoded instance\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @return {Number} - the number of bytes covered by the layout\n   * instance.  If this method is not overridden in a subclass the\n   * definition-time constant {@link Layout#span|span} will be\n   * returned.\n   *\n   * @throws {RangeError} - if the length of the value cannot be\n   * determined.\n   */\n  getSpan(b, offset) {\n    if (0 > this.span) {\n      throw new RangeError('indeterminate span');\n    }\n    return this.span;\n  }\n\n  /**\n   * Replicate the layout using a new property.\n   *\n   * This function must be used to get a structurally-equivalent layout\n   * with a different name since all {@link Layout} instances are\n   * immutable.\n   *\n   * **NOTE** This is a shallow copy.  All fields except {@link\n   * Layout#property|property} are strictly equal to the origin layout.\n   *\n   * @param {String} property - the value for {@link\n   * Layout#property|property} in the replica.\n   *\n   * @returns {Layout} - the copy with {@link Layout#property|property}\n   * set to `property`.\n   */\n  replicate(property) {\n    const rv = Object.create(this.constructor.prototype);\n    Object.assign(rv, this);\n    rv.property = property;\n    return rv;\n  }\n\n  /**\n   * Create an object from layout properties and an array of values.\n   *\n   * **NOTE** This function returns `undefined` if invoked on a layout\n   * that does not return its value as an Object.  Objects are\n   * returned for things that are a {@link Structure}, which includes\n   * {@link VariantLayout|variant layouts} if they are structures, and\n   * excludes {@link Union}s.  If you want this feature for a union\n   * you must use {@link Union.getVariant|getVariant} to select the\n   * desired layout.\n   *\n   * @param {Array} values - an array of values that correspond to the\n   * default order for properties.  As with {@link Layout#decode|decode}\n   * layout elements that have no property name are skipped when\n   * iterating over the array values.  Only the top-level properties are\n   * assigned; arguments are not assigned to properties of contained\n   * layouts.  Any unused values are ignored.\n   *\n   * @return {(Object|undefined)}\n   */\n  fromArray(values) {\n    return undefined;\n  }\n}\nexports.Layout = Layout;\n\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */\nfunction nameWithProperty(name, lo) {\n  if (lo.property) {\n    return name + '[' + lo.property + ']';\n  }\n  return name;\n}\nexports.nameWithProperty = nameWithProperty;\n\n/**\n * Augment a class so that instances can be encoded/decoded using a\n * given layout.\n *\n * Calling this function couples `Class` with `layout` in several ways:\n *\n * * `Class.layout_` becomes a static member property equal to `layout`;\n * * `layout.boundConstructor_` becomes a static member property equal\n *    to `Class`;\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\n *   property of `layout` is set to a function that returns a `new\n *   Class()`;\n * * `Class.decode(b, offset)` becomes a static member function that\n *   delegates to {@link Layout#decode|layout.decode}.  The\n *   synthesized function may be captured and extended.\n * * `Class.prototype.encode(b, offset)` provides an instance member\n *   function that delegates to {@link Layout#encode|layout.encode}\n *   with `src` set to `this`.  The synthesized function may be\n *   captured and extended, but when the extension is invoked `this`\n *   must be explicitly bound to the instance.\n *\n * @param {class} Class - a JavaScript class with a nullary\n * constructor.\n *\n * @param {Layout} layout - the {@link Layout} instance used to encode\n * instances of `Class`.\n */\nfunction bindConstructorLayout(Class, layout) {\n  if ('function' !== typeof Class) {\n    throw new TypeError('Class must be constructor');\n  }\n  if (Class.hasOwnProperty('layout_')) {\n    throw new Error('Class is already bound to a layout');\n  }\n  if (!(layout && (layout instanceof Layout))) {\n    throw new TypeError('layout must be a Layout');\n  }\n  if (layout.hasOwnProperty('boundConstructor_')) {\n    throw new Error('layout is already bound to a constructor');\n  }\n  Class.layout_ = layout;\n  layout.boundConstructor_ = Class;\n  layout.makeDestinationObject = (() => new Class());\n  Object.defineProperty(Class.prototype, 'encode', {\n    value: function(b, offset) {\n      return layout.encode(this, b, offset);\n    },\n    writable: true,\n  });\n  Object.defineProperty(Class, 'decode', {\n    value: function(b, offset) {\n      return layout.decode(b, offset);\n    },\n    writable: true,\n  });\n}\nexports.bindConstructorLayout = bindConstructorLayout;\n\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */\nclass ExternalLayout extends Layout {\n  /**\n   * Return `true` iff the external layout decodes to an unsigned\n   * integer layout.\n   *\n   * In that case it can be used as the source of {@link\n   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n   * or as {@link UnionLayoutDiscriminator#layout|external union\n   * discriminators}.\n   *\n   * @abstract\n   */\n  isCount() {\n    throw new Error('ExternalLayout is abstract');\n  }\n}\n\n/**\n * An {@link ExternalLayout} that determines its {@link\n * Layout#decode|value} based on offset into and length of the buffer\n * on which it is invoked.\n *\n * *Factory*: {@link module:Layout.greedy|greedy}\n *\n * @param {Number} [elementSpan] - initializer for {@link\n * GreedyCount#elementSpan|elementSpan}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {ExternalLayout}\n */\nclass GreedyCount extends ExternalLayout {\n  constructor(elementSpan, property) {\n    if (undefined === elementSpan) {\n      elementSpan = 1;\n    }\n    if ((!Number.isInteger(elementSpan)) || (0 >= elementSpan)) {\n      throw new TypeError('elementSpan must be a (positive) integer');\n    }\n    super(-1, property);\n\n    /** The layout for individual elements of the sequence.  The value\n     * must be a positive integer.  If not provided, the value will be\n     * 1. */\n    this.elementSpan = elementSpan;\n  }\n\n  /** @override */\n  isCount() {\n    return true;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const rem = b.length - offset;\n    return Math.floor(rem / this.elementSpan);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    return 0;\n  }\n}\n\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */\nclass OffsetLayout extends ExternalLayout {\n  constructor(layout, offset, property) {\n    if (!(layout instanceof Layout)) {\n      throw new TypeError('layout must be a Layout');\n    }\n\n    if (undefined === offset) {\n      offset = 0;\n    } else if (!Number.isInteger(offset)) {\n      throw new TypeError('offset must be integer or undefined');\n    }\n\n    super(layout.span, property || layout.property);\n\n    /** The subordinated layout. */\n    this.layout = layout;\n\n    /** The location of {@link OffsetLayout#layout} relative to the\n     * start of another layout.\n     *\n     * The value may be positive or negative, but an error will thrown\n     * if at the point of use it goes outside the span of the Buffer\n     * being accessed.  */\n    this.offset = offset;\n  }\n\n  /** @override */\n  isCount() {\n    return ((this.layout instanceof UInt)\n            || (this.layout instanceof UIntBE));\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return this.layout.decode(b, offset + this.offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return this.layout.encode(src, b, offset + this.offset);\n  }\n}\n\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UInt extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readUIntLE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeUIntLE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UIntBE extends Layout {\n  constructor(span, property) {\n    super( span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readUIntBE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeUIntBE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent a signed integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.s8|s8}, {@link\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\n *  module:Layout.s48|s48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Int extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readIntLE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeIntLE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent a signed integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\n * {@link module:Layout.s32be|s32be}, {@link\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass IntBE extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readIntBE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeIntBE(src, offset, this.span);\n    return this.span;\n  }\n}\n\nconst V2E32 = Math.pow(2, 32);\n\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */\nfunction divmodInt64(src) {\n  const hi32 = Math.floor(src / V2E32);\n  const lo32 = src - (hi32 * V2E32);\n  return {hi32, lo32};\n}\n/* Reconstruct Number from quotient and non-negative remainder */\nfunction roundedInt64(hi32, lo32) {\n  return hi32 * V2E32 + lo32;\n}\n\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const lo32 = b.readUInt32LE(offset);\n    const hi32 = b.readUInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32LE(split.lo32, offset);\n    b.writeUInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent an unsigned 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64be|nu64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64BE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const hi32 = b.readUInt32BE(offset);\n    const lo32 = b.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32BE(split.hi32, offset);\n    b.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const lo32 = b.readUInt32LE(offset);\n    const hi32 = b.readInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32LE(split.lo32, offset);\n    b.writeInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a signed 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64be|ns64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64BE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const hi32 = b.readInt32BE(offset);\n    const lo32 = b.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeInt32BE(split.hi32, offset);\n    b.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a 32-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f32|f32}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Float extends Layout {\n  constructor(property) {\n    super(4, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readFloatLE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeFloatLE(src, offset);\n    return 4;\n  }\n}\n\n/**\n * Represent a 32-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f32be|f32be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass FloatBE extends Layout {\n  constructor(property) {\n    super(4, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readFloatBE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeFloatBE(src, offset);\n    return 4;\n  }\n}\n\n/**\n * Represent a 64-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f64|f64}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Double extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readDoubleLE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeDoubleLE(src, offset);\n    return 8;\n  }\n}\n\n/**\n * Represent a 64-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f64be|f64be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass DoubleBE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readDoubleBE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeDoubleBE(src, offset);\n    return 8;\n  }\n}\n\n/**\n * Represent a contiguous sequence of a specific layout as an Array.\n *\n * *Factory*: {@link module:Layout.seq|seq}\n *\n * @param {Layout} elementLayout - initializer for {@link\n * Sequence#elementLayout|elementLayout}.\n *\n * @param {(Number|ExternalLayout)} count - initializer for {@link\n * Sequence#count|count}.  The parameter must be either a positive\n * integer or an instance of {@link ExternalLayout}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Sequence extends Layout {\n  constructor(elementLayout, count, property) {\n    if (!(elementLayout instanceof Layout)) {\n      throw new TypeError('elementLayout must be a Layout');\n    }\n    if (!(((count instanceof ExternalLayout) && count.isCount())\n          || (Number.isInteger(count) && (0 <= count)))) {\n      throw new TypeError('count must be non-negative integer '\n                          + 'or an unsigned integer ExternalLayout');\n    }\n    let span = -1;\n    if ((!(count instanceof ExternalLayout))\n        && (0 < elementLayout.span)) {\n      span = count * elementLayout.span;\n    }\n\n    super(span, property);\n\n    /** The layout for individual elements of the sequence. */\n    this.elementLayout = elementLayout;\n\n    /** The number of elements in the sequence.\n     *\n     * This will be either a non-negative integer or an instance of\n     * {@link ExternalLayout} for which {@link\n     * ExternalLayout#isCount|isCount()} is `true`. */\n    this.count = count;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = 0;\n    let count = this.count;\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n    if (0 < this.elementLayout.span) {\n      span = count * this.elementLayout.span;\n    } else {\n      let idx = 0;\n      while (idx < count) {\n        span += this.elementLayout.getSpan(b, offset + span);\n        ++idx;\n      }\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const rv = [];\n    let i = 0;\n    let count = this.count;\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n    while (i < count) {\n      rv.push(this.elementLayout.decode(b, offset));\n      offset += this.elementLayout.getSpan(b, offset);\n      i += 1;\n    }\n    return rv;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n   *\n   * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n   * the unused space in the buffer is left unchanged.  If `src` is\n   * longer than {@link Sequence#count|count} the unneeded elements are\n   * ignored.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const elo = this.elementLayout;\n    const span = src.reduce((span, v) => {\n      return span + elo.encode(v, b, offset + span);\n    }, 0);\n    if (this.count instanceof ExternalLayout) {\n      this.count.encode(src.length, b, offset);\n    }\n    return span;\n  }\n}\n\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */\nclass Structure extends Layout {\n  constructor(fields, property, decodePrefixes) {\n    if (!(Array.isArray(fields)\n          && fields.reduce((acc, v) => acc && (v instanceof Layout), true))) {\n      throw new TypeError('fields must be array of Layout instances');\n    }\n    if (('boolean' === typeof property)\n        && (undefined === decodePrefixes)) {\n      decodePrefixes = property;\n      property = undefined;\n    }\n\n    /* Verify absence of unnamed variable-length fields. */\n    for (const fd of fields) {\n      if ((0 > fd.span)\n          && (undefined === fd.property)) {\n        throw new Error('fields cannot contain unnamed variable-length layout');\n      }\n    }\n\n    let span = -1;\n    try {\n      span = fields.reduce((span, fd) => span + fd.getSpan(), 0);\n    } catch (e) {\n    }\n    super(span, property);\n\n    /** The sequence of {@link Layout} values that comprise the\n     * structure.\n     *\n     * The individual elements need not be the same type, and may be\n     * either scalar or aggregate layouts.  If a member layout leaves\n     * its {@link Layout#property|property} undefined the\n     * corresponding region of the buffer associated with the element\n     * will not be mutated.\n     *\n     * @type {Layout[]} */\n    this.fields = fields;\n\n    /** Control behavior of {@link Layout#decode|decode()} given short\n     * buffers.\n     *\n     * In some situations a structure many be extended with additional\n     * fields over time, with older installations providing only a\n     * prefix of the full structure.  If this property is `true`\n     * decoding will accept those buffers and leave subsequent fields\n     * undefined, as long as the buffer ends at a field boundary.\n     * Defaults to `false`. */\n    this.decodePrefixes = !!decodePrefixes;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = 0;\n    try {\n      span = this.fields.reduce((span, fd) => {\n        const fsp = fd.getSpan(b, offset);\n        offset += fsp;\n        return span + fsp;\n      }, 0);\n    } catch (e) {\n      throw new RangeError('indeterminate span');\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const dest = this.makeDestinationObject();\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(b, offset);\n      }\n      offset += fd.getSpan(b, offset);\n      if (this.decodePrefixes\n          && (b.length === offset)) {\n        break;\n      }\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Structure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the buffer is\n   * left unmodified. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const firstOffset = offset;\n    let lastOffset = 0;\n    let lastWrote = 0;\n    for (const fd of this.fields) {\n      let span = fd.span;\n      lastWrote = (0 < span) ? span : 0;\n      if (undefined !== fd.property) {\n        const fv = src[fd.property];\n        if (undefined !== fv) {\n          lastWrote = fd.encode(fv, b, offset);\n          if (0 > span) {\n            /* Read the as-encoded span, which is not necessarily the\n             * same as what we wrote. */\n            span = fd.getSpan(b, offset);\n          }\n        }\n      }\n      lastOffset = offset;\n      offset += span;\n    }\n    /* Use (lastOffset + lastWrote) instead of offset because the last\n     * item may have had a dynamic length and we don't want to include\n     * the padding between it and the end of the space reserved for\n     * it. */\n    return (lastOffset + lastWrote) - firstOffset;\n  }\n\n  /** @override */\n  fromArray(values) {\n    const dest = this.makeDestinationObject();\n    for (const fd of this.fields) {\n      if ((undefined !== fd.property)\n          && (0 < values.length)) {\n        dest[fd.property] = values.shift();\n      }\n    }\n    return dest;\n  }\n\n  /**\n   * Get access to the layout of a given property.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Layout} - the layout associated with `property`, or\n   * undefined if there is no such property.\n   */\n  layoutFor(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n  }\n\n  /**\n   * Get the offset of a structure member.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Number} - the offset in bytes to the start of `property`\n   * within the structure, or undefined if `property` is not a field\n   * within the structure.  If the property is a member but follows a\n   * variable-length structure member a negative number will be\n   * returned.\n   */\n  offsetOf(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    let offset = 0;\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return offset;\n      }\n      if (0 > fd.span) {\n        offset = -1;\n      } else if (0 <= offset) {\n        offset += fd.span;\n      }\n    }\n  }\n}\n\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */\nclass UnionDiscriminator {\n  constructor(property) {\n    /** The {@link Layout#property|property} to be used when the\n     * discriminator is referenced in isolation (generally when {@link\n     * Union#decode|Union decode} cannot delegate to a specific\n     * variant). */\n    this.property = property;\n  }\n\n  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n   *\n   * The implementation of this method need not reference the buffer if\n   * variant information is available through other means. */\n  decode() {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n\n  /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n   *\n   * The implementation of this method need not store the value if\n   * variant information is maintained through other means. */\n  encode() {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n}\n\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */\nclass UnionLayoutDiscriminator extends UnionDiscriminator {\n  constructor(layout, property) {\n    if (!((layout instanceof ExternalLayout)\n          && layout.isCount())) {\n      throw new TypeError('layout must be an unsigned integer ExternalLayout');\n    }\n\n    super(property || layout.property || 'variant');\n\n    /** The {@link ExternalLayout} used to access the discriminator\n     * value. */\n    this.layout = layout;\n  }\n\n  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  decode(b, offset) {\n    return this.layout.decode(b, offset);\n  }\n\n  /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  encode(src, b, offset) {\n    return this.layout.encode(src, b, offset);\n  }\n}\n\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Union extends Layout {\n  constructor(discr, defaultLayout, property) {\n    const upv = ((discr instanceof UInt)\n               || (discr instanceof UIntBE));\n    if (upv) {\n      discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n    } else if ((discr instanceof ExternalLayout)\n               && discr.isCount()) {\n      discr = new UnionLayoutDiscriminator(discr);\n    } else if (!(discr instanceof UnionDiscriminator)) {\n      throw new TypeError('discr must be a UnionDiscriminator '\n                          + 'or an unsigned integer layout');\n    }\n    if (undefined === defaultLayout) {\n      defaultLayout = null;\n    }\n    if (!((null === defaultLayout)\n          || (defaultLayout instanceof Layout))) {\n      throw new TypeError('defaultLayout must be null or a Layout');\n    }\n    if (null !== defaultLayout) {\n      if (0 > defaultLayout.span) {\n        throw new Error('defaultLayout must have constant span');\n      }\n      if (undefined === defaultLayout.property) {\n        defaultLayout = defaultLayout.replicate('content');\n      }\n    }\n\n    /* The union span can be estimated only if there's a default\n     * layout.  The union spans its default layout, plus any prefix\n     * variant layout.  By construction both layouts, if present, have\n     * non-negative span. */\n    let span = -1;\n    if (defaultLayout) {\n      span = defaultLayout.span;\n      if ((0 <= span) && upv) {\n        span += discr.layout.span;\n      }\n    }\n    super(span, property);\n\n    /** The interface for the discriminator value in isolation.\n     *\n     * This a {@link UnionDiscriminator} either passed to the\n     * constructor or synthesized from the `discr` constructor\n     * argument.  {@link\n     * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n     * `true` iff the `discr` parameter was a non-offset {@link\n     * Layout} instance. */\n    this.discriminator = discr;\n\n    /** `true` if the {@link Union#discriminator|discriminator} is the\n     * first field in the union.\n     *\n     * If `false` the discriminator is obtained from somewhere\n     * else. */\n    this.usesPrefixDiscriminator = upv;\n\n    /** The layout for non-discriminator content when the value of the\n     * discriminator is not recognized.\n     *\n     * This is the value passed to the constructor.  It is\n     * structurally equivalent to the second component of {@link\n     * Union#layout|layout} but may have a different property\n     * name. */\n    this.defaultLayout = defaultLayout;\n\n    /** A registry of allowed variants.\n     *\n     * The keys are unsigned integers which should be compatible with\n     * {@link Union.discriminator|discriminator}.  The property value\n     * is the corresponding {@link VariantLayout} instances assigned\n     * to this union by {@link Union#addVariant|addVariant}.\n     *\n     * **NOTE** The registry remains mutable so that variants can be\n     * {@link Union#addVariant|added} at any time.  Users should not\n     * manipulate the content of this property. */\n    this.registry = {};\n\n    /* Private variable used when invoking getSourceVariant */\n    let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n\n    /** Function to infer the variant selected by a source object.\n     *\n     * Defaults to {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n     * be overridden using {@link\n     * Union#configGetSourceVariant|configGetSourceVariant}.\n     *\n     * @param {Object} src - as with {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * @returns {(undefined|VariantLayout)} The default variant\n     * (`undefined`) or first registered variant that uses a property\n     * available in `src`. */\n    this.getSourceVariant = function(src) {\n      return boundGetSourceVariant(src);\n    };\n\n    /** Function to override the implementation of {@link\n     * Union#getSourceVariant|getSourceVariant}.\n     *\n     * Use this if the desired variant cannot be identified using the\n     * algorithm of {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * **NOTE** The provided function will be invoked bound to this\n     * Union instance, providing local access to {@link\n     * Union#registry|registry}.\n     *\n     * @param {Function} gsv - a function that follows the API of\n     * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */\n    this.configGetSourceVariant = function(gsv) {\n      boundGetSourceVariant = gsv.bind(this);\n    };\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Default layouts always have non-negative span, so we don't have\n     * one and we have to recognize the variant which will in turn\n     * determine the span. */\n    const vlo = this.getVariant(b, offset);\n    if (!vlo) {\n      throw new Error('unable to determine span for unrecognized variant');\n    }\n    return vlo.getSpan(b, offset);\n  }\n\n  /**\n   * Method to infer a registered Union variant compatible with `src`.\n   *\n   * The first satisified rule in the following sequence defines the\n   * return value:\n   * * If `src` has properties matching the Union discriminator and\n   *   the default layout, `undefined` is returned regardless of the\n   *   value of the discriminator property (this ensures the default\n   *   layout will be used);\n   * * If `src` has a property matching the Union discriminator, the\n   *   value of the discriminator identifies a registered variant, and\n   *   either (a) the variant has no layout, or (b) `src` has the\n   *   variant's property, then the variant is returned (because the\n   *   source satisfies the constraints of the variant it identifies);\n   * * If `src` does not have a property matching the Union\n   *   discriminator, but does have a property matching a registered\n   *   variant, then the variant is returned (because the source\n   *   matches a variant without an explicit conflict);\n   * * An error is thrown (because we either can't identify a variant,\n   *   or we were explicitly told the variant but can't satisfy it).\n   *\n   * @param {Object} src - an object presumed to be compatible with\n   * the content of the Union.\n   *\n   * @return {(undefined|VariantLayout)} - as described above.\n   *\n   * @throws {Error} - if `src` cannot be associated with a default or\n   * registered variant.\n   */\n  defaultGetSourceVariant(src) {\n    if (src.hasOwnProperty(this.discriminator.property)) {\n      if (this.defaultLayout\n          && src.hasOwnProperty(this.defaultLayout.property)) {\n        return undefined;\n      }\n      const vlo = this.registry[src[this.discriminator.property]];\n      if (vlo\n          && ((!vlo.layout)\n              || src.hasOwnProperty(vlo.property))) {\n        return vlo;\n      }\n    } else {\n      for (const tag in this.registry) {\n        const vlo = this.registry[tag];\n        if (src.hasOwnProperty(vlo.property)) {\n          return vlo;\n        }\n      }\n    }\n    throw new Error('unable to infer src variant');\n  }\n\n  /** Implement {@link Layout#decode|decode} for {@link Union}.\n   *\n   * If the variant is {@link Union#addVariant|registered} the return\n   * value is an instance of that variant, with no explicit\n   * discriminator.  Otherwise the {@link Union#defaultLayout|default\n   * layout} is used to decode the content. */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let dest;\n    const dlo = this.discriminator;\n    const discr = dlo.decode(b, offset);\n    let clo = this.registry[discr];\n    if (undefined === clo) {\n      let contentOffset = 0;\n      clo = this.defaultLayout;\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n      dest = this.makeDestinationObject();\n      dest[dlo.property] = discr;\n      dest[clo.property] = this.defaultLayout.decode(b, offset + contentOffset);\n    } else {\n      dest = clo.decode(b, offset);\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Union}.\n   *\n   * This API assumes the `src` object is consistent with the union's\n   * {@link Union#defaultLayout|default layout}.  To encode variants\n   * use the appropriate variant-specific {@link VariantLayout#encode}\n   * method. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const vlo = this.getSourceVariant(src);\n    if (undefined === vlo) {\n      const dlo = this.discriminator;\n      const clo = this.defaultLayout;\n      let contentOffset = 0;\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n      dlo.encode(src[dlo.property], b, offset);\n      return contentOffset + clo.encode(src[clo.property], b,\n                                        offset + contentOffset);\n    }\n    return vlo.encode(src, b, offset);\n  }\n\n  /** Register a new variant structure within a union.  The newly\n   * created variant is returned.\n   *\n   * @param {Number} variant - initializer for {@link\n   * VariantLayout#variant|variant}.\n   *\n   * @param {Layout} layout - initializer for {@link\n   * VariantLayout#layout|layout}.\n   *\n   * @param {String} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {VariantLayout} */\n  addVariant(variant, layout, property) {\n    const rv = new VariantLayout(this, variant, layout, property);\n    this.registry[variant] = rv;\n    return rv;\n  }\n\n  /**\n   * Get the layout associated with a registered variant.\n   *\n   * If `vb` does not produce a registered variant the function returns\n   * `undefined`.\n   *\n   * @param {(Number|Buffer)} vb - either the variant number, or a\n   * buffer from which the discriminator is to be read.\n   *\n   * @param {Number} offset - offset into `vb` for the start of the\n   * union.  Used only when `vb` is an instance of {Buffer}.\n   *\n   * @return {({VariantLayout}|undefined)}\n   */\n  getVariant(vb, offset) {\n    let variant = vb;\n    if (Buffer.isBuffer(vb)) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      variant = this.discriminator.decode(vb, offset);\n    }\n    return this.registry[variant];\n  }\n}\n\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */\nclass VariantLayout extends Layout {\n  constructor(union, variant, layout, property) {\n    if (!(union instanceof Union)) {\n      throw new TypeError('union must be a Union');\n    }\n    if ((!Number.isInteger(variant)) || (0 > variant)) {\n      throw new TypeError('variant must be a (non-negative) integer');\n    }\n    if (('string' === typeof layout)\n        && (undefined === property)) {\n      property = layout;\n      layout = null;\n    }\n    if (layout) {\n      if (!(layout instanceof Layout)) {\n        throw new TypeError('layout must be a Layout');\n      }\n      if ((null !== union.defaultLayout)\n          && (0 <= layout.span)\n          && (layout.span > union.defaultLayout.span)) {\n        throw new Error('variant span exceeds span of containing union');\n      }\n      if ('string' !== typeof property) {\n        throw new TypeError('variant must have a String property');\n      }\n    }\n    let span = union.span;\n    if (0 > union.span) {\n      span = layout ? layout.span : 0;\n      if ((0 <= span) && union.usesPrefixDiscriminator) {\n        span += union.discriminator.layout.span;\n      }\n    }\n    super(span, property);\n\n    /** The {@link Union} to which this variant belongs. */\n    this.union = union;\n\n    /** The unsigned integral value identifying this variant within\n     * the {@link Union#discriminator|discriminator} of the containing\n     * union. */\n    this.variant = variant;\n\n    /** The {@link Layout} to be used when reading/writing the\n     * non-discriminator part of the {@link\n     * VariantLayout#union|union}.  If `null` the variant carries no\n     * data. */\n    this.layout = layout || null;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      /* Will be equal to the containing union span if that is not\n       * variable. */\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    /* Span is defined solely by the variant (and prefix discriminator) */\n    return contentOffset + this.layout.getSpan(b, offset + contentOffset);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    const dest = this.makeDestinationObject();\n    if (undefined === offset) {\n      offset = 0;\n    }\n    if (this !== this.union.getVariant(b, offset)) {\n      throw new Error('variant mismatch');\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    if (this.layout) {\n      dest[this.property] = this.layout.decode(b, offset + contentOffset);\n    } else if (this.property) {\n      dest[this.property] = true;\n    } else if (this.union.usesPrefixDiscriminator) {\n      dest[this.union.discriminator.property] = this.variant;\n    }\n    return dest;\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    if (this.layout\n        && (!src.hasOwnProperty(this.property))) {\n      throw new TypeError('variant lacks property ' + this.property);\n    }\n    this.union.discriminator.encode(this.variant, b, offset);\n    let span = contentOffset;\n    if (this.layout) {\n      this.layout.encode(src[this.property], b, offset + contentOffset);\n      span += this.layout.getSpan(b, offset + contentOffset);\n      if ((0 <= this.union.span)\n          && (span > this.union.span)) {\n        throw new Error('encoded variant overruns containing union');\n      }\n    }\n    return span;\n  }\n\n  /** Delegate {@link Layout#fromArray|fromArray} to {@link\n   * VariantLayout#layout|layout}. */\n  fromArray(values) {\n    if (this.layout) {\n      return this.layout.fromArray(values);\n    }\n  }\n}\n\n/** JavaScript chose to define bitwise operations as operating on\n * signed 32-bit values in 2's complement form, meaning any integer\n * with bit 31 set is going to look negative.  For right shifts that's\n * not a problem, because `>>>` is a logical shift, but for every\n * other bitwise operator we have to compensate for possible negative\n * results. */\nfunction fixBitwiseResult(v) {\n  if (0 > v) {\n    v += 0x100000000;\n  }\n  return v;\n}\n\n/**\n * Contain a sequence of bit fields as an unsigned integer.\n *\n * *Factory*: {@link module:Layout.bits|bits}\n *\n * This is a container element; within it there are {@link BitField}\n * instances that provide the extracted properties.  The container\n * simply defines the aggregate representation and its bit ordering.\n * The representation is an object containing properties with numeric\n * or {@link Boolean} values.\n *\n * {@link BitField}s are added with the {@link\n * BitStructure#addField|addField} and {@link\n * BitStructure#addBoolean|addBoolean} methods.\n\n * @param {Layout} word - initializer for {@link\n * BitStructure#word|word}.  The parameter must be an instance of\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\n *\n * @param {bool} [msb] - `true` if the bit numbering starts at the\n * most significant bit of the containing word; `false` (default) if\n * it starts at the least significant bit of the containing word.  If\n * the parameter at this position is a string and `property` is\n * `undefined` the value of this argument will instead be used as the\n * value of `property`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass BitStructure extends Layout {\n  constructor(word, msb, property) {\n    if (!((word instanceof UInt)\n          || (word instanceof UIntBE))) {\n      throw new TypeError('word must be a UInt or UIntBE layout');\n    }\n    if (('string' === typeof msb)\n        && (undefined === property)) {\n      property = msb;\n      msb = undefined;\n    }\n    if (4 < word.span) {\n      throw new RangeError('word cannot exceed 32 bits');\n    }\n    super(word.span, property);\n\n    /** The layout used for the packed value.  {@link BitField}\n     * instances are packed sequentially depending on {@link\n     * BitStructure#msb|msb}. */\n    this.word = word;\n\n    /** Whether the bit sequences are packed starting at the most\n     * significant bit growing down (`true`), or the least significant\n     * bit growing up (`false`).\n     *\n     * **NOTE** Regardless of this value, the least significant bit of\n     * any {@link BitField} value is the least significant bit of the\n     * corresponding section of the packed value. */\n    this.msb = !!msb;\n\n    /** The sequence of {@link BitField} layouts that comprise the\n     * packed structure.\n     *\n     * **NOTE** The array remains mutable to allow fields to be {@link\n     * BitStructure#addField|added} after construction.  Users should\n     * not manipulate the content of this property.*/\n    this.fields = [];\n\n    /* Storage for the value.  Capture a variable instead of using an\n     * instance property because we don't want anything to change the\n     * value without going through the mutator. */\n    let value = 0;\n    this._packedSetValue = function(v) {\n      value = fixBitwiseResult(v);\n      return this;\n    };\n    this._packedGetValue = function() {\n      return value;\n    };\n  }\n\n  /** @override */\n  decode(b, offset) {\n    const dest = this.makeDestinationObject();\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const value = this.word.decode(b, offset);\n    this._packedSetValue(value);\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(value);\n      }\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the packed\n   * value is left unmodified.  Unused bits are also left unmodified. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const value = this.word.decode(b, offset);\n    this._packedSetValue(value);\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        const fv = src[fd.property];\n        if (undefined !== fv) {\n          fd.encode(fv);\n        }\n      }\n    }\n    return this.word.encode(this._packedGetValue(), b, offset);\n  }\n\n  /** Register a new bitfield with a containing bit structure.  The\n   * resulting bitfield is returned.\n   *\n   * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {BitField} */\n  addField(bits, property) {\n    const bf = new BitField(this, bits, property);\n    this.fields.push(bf);\n    return bf;\n  }\n\n  /** As with {@link BitStructure#addField|addField} for single-bit\n   * fields with `boolean` value representation.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {Boolean} */\n  addBoolean(property) {\n    // This is my Boolean, not the Javascript one.\n    // eslint-disable-next-line no-new-wrappers\n    const bf = new Boolean(this, property);\n    this.fields.push(bf);\n    return bf;\n  }\n\n  /**\n   * Get access to the bit field for a given property.\n   *\n   * @param {String} property - the bit field of interest.\n   *\n   * @return {BitField} - the field associated with `property`, or\n   * undefined if there is no such property.\n   */\n  fieldFor(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n  }\n}\n\n/**\n * Represent a sequence of bits within a {@link BitStructure}.\n *\n * All bit field values are represented as unsigned integers.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addField|addField} helper\n * method.\n *\n * **NOTE** BitField instances are not instances of {@link Layout}\n * since {@link Layout#span|span} measures 8-bit units.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n */\nclass BitField {\n  constructor(container, bits, property) {\n    if (!(container instanceof BitStructure)) {\n      throw new TypeError('container must be a BitStructure');\n    }\n    if ((!Number.isInteger(bits)) || (0 >= bits)) {\n      throw new TypeError('bits must be positive integer');\n    }\n    const totalBits = 8 * container.span;\n    const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);\n    if ((bits + usedBits) > totalBits) {\n      throw new Error('bits too long for span remainder ('\n                      + (totalBits - usedBits) + ' of '\n                      + totalBits + ' remain)');\n    }\n\n    /** The {@link BitStructure} instance to which this bit field\n     * belongs. */\n    this.container = container;\n\n    /** The span of this value in bits. */\n    this.bits = bits;\n\n    /** A mask of {@link BitField#bits|bits} bits isolating value bits\n     * that fit within the field.\n     *\n     * That is, it masks a value that has not yet been shifted into\n     * position within its containing packed integer. */\n    this.valueMask = (1 << bits) - 1;\n    if (32 === bits) { // shifted value out of range\n      this.valueMask = 0xFFFFFFFF;\n    }\n\n    /** The offset of the value within the containing packed unsigned\n     * integer.  The least significant bit of the packed value is at\n     * offset zero, regardless of bit ordering used. */\n    this.start = usedBits;\n    if (this.container.msb) {\n      this.start = totalBits - usedBits - bits;\n    }\n\n    /** A mask of {@link BitField#bits|bits} isolating the field value\n     * within the containing packed unsigned integer. */\n    this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n\n    /** The property name used when this bitfield is represented in an\n     * Object.\n     *\n     * Intended to be functionally equivalent to {@link\n     * Layout#property}.\n     *\n     * If left undefined the corresponding span of bits will be\n     * treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n    this.property = property;\n  }\n\n  /** Store a value into the corresponding subsequence of the containing\n   * bit field. */\n  decode() {\n    const word = this.container._packedGetValue();\n    const wordValue = fixBitwiseResult(word & this.wordMask);\n    const value = wordValue >>> this.start;\n    return value;\n  }\n\n  /** Store a value into the corresponding subsequence of the containing\n   * bit field.\n   *\n   * **NOTE** This is not a specialization of {@link\n   * Layout#encode|Layout.encode} and there is no return value. */\n  encode(value) {\n    if ((!Number.isInteger(value))\n        || (value !== fixBitwiseResult(value & this.valueMask))) {\n      throw new TypeError(nameWithProperty('BitField.encode', this)\n                          + ' value must be integer not exceeding ' + this.valueMask);\n    }\n    const word = this.container._packedGetValue();\n    const wordValue = fixBitwiseResult(value << this.start);\n    this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask)\n                                   | wordValue);\n  };\n}\n\n/**\n * Represent a single bit within a {@link BitStructure} as a\n * JavaScript boolean.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\n * method.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {BitField}\n */\n/* eslint-disable no-extend-native */\nclass Boolean extends BitField {\n  constructor(container, property) {\n    super(container, 1, property);\n  }\n\n  /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n   *\n   * @returns {boolean} */\n  decode(b, offset) {\n    return !!BitField.prototype.decode.call(this, b, offset);\n  }\n\n  /** @override */\n  encode(value) {\n    if ('boolean' === typeof value) {\n      // BitField requires integer values\n      value = +value;\n    }\n    return BitField.prototype.encode.call(this, value);\n  }\n}\n/* eslint-enable no-extend-native */\n\n/**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Buffer.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Blob extends Layout {\n  constructor(length, property) {\n    if (!(((length instanceof ExternalLayout) && length.isCount())\n          || (Number.isInteger(length) && (0 <= length)))) {\n      throw new TypeError('length must be positive integer '\n                          + 'or an unsigned integer ExternalLayout');\n    }\n\n    let span = -1;\n    if (!(length instanceof ExternalLayout)) {\n      span = length;\n    }\n    super(span, property);\n\n    /** The number of bytes in the blob.\n     *\n     * This may be a non-negative integer, or an instance of {@link\n     * ExternalLayout} that satisfies {@link\n     * ExternalLayout#isCount|isCount()}. */\n    this.length = length;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    let span = this.span;\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.span;\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n    return b.slice(offset, offset + span);\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Blob}.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */\n  encode(src, b, offset) {\n    let span = this.length;\n    if (this.length instanceof ExternalLayout) {\n      span = src.length;\n    }\n    if (!(Buffer.isBuffer(src)\n          && (span === src.length))) {\n      throw new TypeError(nameWithProperty('Blob.encode', this)\n                          + ' requires (length ' + span + ') Buffer as src');\n    }\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    b.write(src.toString('hex'), offset, span, 'hex');\n    if (this.length instanceof ExternalLayout) {\n      this.length.encode(span, b, offset);\n    }\n    return span;\n  }\n}\n\n/**\n * Contain a `NUL`-terminated UTF8 string.\n *\n * *Factory*: {@link module:Layout.cstr|cstr}\n *\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\n * not be correctly decoded by this layout.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass CString extends Layout {\n  constructor(property) {\n    super(-1, property);\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (!Buffer.isBuffer(b)) {\n      throw new TypeError('b must be a Buffer');\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let idx = offset;\n    while ((idx < b.length) && (0 !== b[idx])) {\n      idx += 1;\n    }\n    return 1 + idx - offset;\n  }\n\n  /** @override */\n  decode(b, offset, dest) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.getSpan(b, offset);\n    return b.slice(offset, offset + span - 1).toString('utf-8');\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */\n    if ('string' !== typeof src) {\n      src = src.toString();\n    }\n    const srcb = new Buffer(src, 'utf8');\n    const span = srcb.length;\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    srcb.copy(b, offset);\n    b[offset + span] = 0;\n    return span + 1;\n  }\n}\n\n/**\n * Contain a UTF8 string with implicit length.\n *\n * *Factory*: {@link module:Layout.utf8|utf8}\n *\n * **NOTE** Because the length is implicit in the size of the buffer\n * this layout should be used only in isolation, or in a situation\n * where the length can be expressed by operating on a slice of the\n * containing buffer.\n *\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\n * string content.  If not provided there is no bound on the allowed\n * content.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UTF8 extends Layout {\n  constructor(maxSpan, property) {\n    if (('string' === typeof maxSpan)\n        && (undefined === property)) {\n      property = maxSpan;\n      maxSpan = undefined;\n    }\n    if (undefined === maxSpan) {\n      maxSpan = -1;\n    } else if (!Number.isInteger(maxSpan)) {\n      throw new TypeError('maxSpan must be an integer');\n    }\n\n    super(-1, property);\n\n    /** The maximum span of the layout in bytes.\n     *\n     * Positive values are generally expected.  Zero is abnormal.\n     * Attempts to encode or decode a value that exceeds this length\n     * will throw a `RangeError`.\n     *\n     * A negative value indicates that there is no bound on the length\n     * of the content. */\n    this.maxSpan = maxSpan;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (!Buffer.isBuffer(b)) {\n      throw new TypeError('b must be a Buffer');\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.length - offset;\n  }\n\n  /** @override */\n  decode(b, offset, dest) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.getSpan(b, offset);\n    if ((0 <= this.maxSpan)\n        && (this.maxSpan < span)) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n    return b.slice(offset, offset + span).toString('utf-8');\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */\n    if ('string' !== typeof src) {\n      src = src.toString();\n    }\n    const srcb = new Buffer(src, 'utf8');\n    const span = srcb.length;\n    if ((0 <= this.maxSpan)\n        && (this.maxSpan < span)) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    srcb.copy(b, offset);\n    return span;\n  }\n}\n\n/**\n * Contain a constant value.\n *\n * This layout may be used in cases where a JavaScript value can be\n * inferred without an expression in the binary encoding.  An example\n * would be a {@link VariantLayout|variant layout} where the content\n * is implied by the union {@link Union#discriminator|discriminator}.\n *\n * @param {Object|Number|String} value - initializer for {@link\n * Constant#value|value}.  If the value is an object (or array) and\n * the application intends the object to remain unchanged regardless\n * of what is done to values decoded by this layout, the value should\n * be frozen prior passing it to this constructor.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Constant extends Layout {\n  constructor(value, property) {\n    super(0, property);\n\n    /** The value produced by this constant when the layout is {@link\n     * Constant#decode|decoded}.\n     *\n     * Any JavaScript value including `null` and `undefined` is\n     * permitted.\n     *\n     * **WARNING** If `value` passed in the constructor was not\n     * frozen, it is possible for users of decoded values to change\n     * the content of the value. */\n    this.value = value;\n  }\n\n  /** @override */\n  decode(b, offset, dest) {\n    return this.value;\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    /* Constants take no space */\n    return 0;\n  }\n}\n\nexports.ExternalLayout = ExternalLayout;\nexports.GreedyCount = GreedyCount;\nexports.OffsetLayout = OffsetLayout;\nexports.UInt = UInt;\nexports.UIntBE = UIntBE;\nexports.Int = Int;\nexports.IntBE = IntBE;\nexports.Float = Float;\nexports.FloatBE = FloatBE;\nexports.Double = Double;\nexports.DoubleBE = DoubleBE;\nexports.Sequence = Sequence;\nexports.Structure = Structure;\nexports.UnionDiscriminator = UnionDiscriminator;\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\nexports.Union = Union;\nexports.VariantLayout = VariantLayout;\nexports.BitStructure = BitStructure;\nexports.BitField = BitField;\nexports.Boolean = Boolean;\nexports.Blob = Blob;\nexports.CString = CString;\nexports.UTF8 = UTF8;\nexports.Constant = Constant;\n\n/** Factory for {@link GreedyCount}. */\nexports.greedy = ((elementSpan, property) => new GreedyCount(elementSpan, property));\n\n/** Factory for {@link OffsetLayout}. */\nexports.offset = ((layout, offset, property) => new OffsetLayout(layout, offset, property));\n\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */\nexports.u8 = (property => new UInt(1, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16 = (property => new UInt(2, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24 = (property => new UInt(3, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32 = (property => new UInt(4, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40 = (property => new UInt(5, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48 = (property => new UInt(6, property));\n\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64 = (property => new NearUInt64(property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16be = (property => new UIntBE(2, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24be = (property => new UIntBE(3, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32be = (property => new UIntBE(4, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40be = (property => new UIntBE(5, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48be = (property => new UIntBE(6, property));\n\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64be = (property => new NearUInt64BE(property));\n\n/** Factory for {@link Int|signed int layouts} spanning one\n * byte. */\nexports.s8 = (property => new Int(1, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning two bytes. */\nexports.s16 = (property => new Int(2, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning three bytes. */\nexports.s24 = (property => new Int(3, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning four bytes. */\nexports.s32 = (property => new Int(4, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning five bytes. */\nexports.s40 = (property => new Int(5, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning six bytes. */\nexports.s48 = (property => new Int(6, property));\n\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64 = (property => new NearInt64(property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning two bytes. */\nexports.s16be = (property => new IntBE(2, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning three bytes. */\nexports.s24be = (property => new IntBE(3, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning four bytes. */\nexports.s32be = (property => new IntBE(4, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning five bytes. */\nexports.s40be = (property => new IntBE(5, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning six bytes. */\nexports.s48be = (property => new IntBE(6, property));\n\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64be = (property => new NearInt64BE(property));\n\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */\nexports.f32 = (property => new Float(property));\n\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */\nexports.f32be = (property => new FloatBE(property));\n\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */\nexports.f64 = (property => new Double(property));\n\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */\nexports.f64be = (property => new DoubleBE(property));\n\n/** Factory for {@link Structure} values. */\nexports.struct = ((fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes));\n\n/** Factory for {@link BitStructure} values. */\nexports.bits = ((word, msb, property) => new BitStructure(word, msb, property));\n\n/** Factory for {@link Sequence} values. */\nexports.seq = ((elementLayout, count, property) => new Sequence(elementLayout, count, property));\n\n/** Factory for {@link Union} values. */\nexports.union = ((discr, defaultLayout, property) => new Union(discr, defaultLayout, property));\n\n/** Factory for {@link UnionLayoutDiscriminator} values. */\nexports.unionLayoutDiscriminator = ((layout, property) => new UnionLayoutDiscriminator(layout, property));\n\n/** Factory for {@link Blob} values. */\nexports.blob = ((length, property) => new Blob(length, property));\n\n/** Factory for {@link CString} values. */\nexports.cstr = (property => new CString(property));\n\n/** Factory for {@link UTF8} values. */\nexports.utf8 = ((maxSpan, property) => new UTF8(maxSpan, property));\n\n/** Factory for {@link Constant} values. */\nexports.const = ((value, property) => new Constant(value, property));\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA,IAAAA,sBAAA,GAAAC,OAAA,kGAAAC,OAAA;AAAA,IAAAC,0BAAA,GAAAF,OAAA,sGAAAC,OAAA;AAAA,IAAAE,SAAA,GAAAH,OAAA,qFAAAC,OAAA;AAAA,IAAAG,YAAA,GAAAJ,OAAA,wFAAAC,OAAA;AAAA,IAAAI,eAAA,GAAAL,OAAA,2FAAAC,OAAA;AAAA,IAAAK,YAAA,GAAAN,OAAA,wFAAAC,OAAA;AAAA,IAgBMM,MAAM;EACV,SAAAA,OAAYC,IAAI,EAAEC,QAAQ,EAAE;IAAAJ,eAAA,OAAAE,MAAA;IAC1B,IAAI,CAACG,MAAM,CAACC,SAAS,CAACH,IAAI,CAAC,EAAE;MAC3B,MAAM,IAAII,SAAS,CAAC,yBAAyB,CAAC;IAChD;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA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"},"metadata":{},"sourceType":"script","externalDependencies":[]}