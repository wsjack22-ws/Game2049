{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.accountBodyToRLP = exports.accountBodyToSlim = exports.accountBodyFromSlim = exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\nconst rlp_1 = require(\"@ethereumjs/rlp\");\nconst keccak_1 = require(\"ethereum-cryptography/keccak\");\nconst secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\nconst utils_1 = require(\"ethereum-cryptography/utils\");\nconst bytes_1 = require(\"./bytes\");\nconst constants_1 = require(\"./constants\");\nconst helpers_1 = require(\"./helpers\");\nconst internal_1 = require(\"./internal\");\nconst _0n = BigInt(0);\nclass Account {\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating an Account from varying data types.\n   */\n  constructor(nonce = _0n, balance = _0n, storageRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL) {\n    this.nonce = nonce;\n    this.balance = balance;\n    this.storageRoot = storageRoot;\n    this.codeHash = codeHash;\n    this._validate();\n  }\n  static fromAccountData(accountData) {\n    const {\n      nonce,\n      balance,\n      storageRoot,\n      codeHash\n    } = accountData;\n    return new Account(nonce !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(nonce)) : undefined, balance !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(balance)) : undefined, storageRoot !== undefined ? (0, bytes_1.toBuffer)(storageRoot) : undefined, codeHash !== undefined ? (0, bytes_1.toBuffer)(codeHash) : undefined);\n  }\n  static fromRlpSerializedAccount(serialized) {\n    const values = (0, bytes_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized)));\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array');\n    }\n    return this.fromValuesArray(values);\n  }\n  static fromValuesArray(values) {\n    const [nonce, balance, storageRoot, codeHash] = values;\n    return new Account((0, bytes_1.bufferToBigInt)(nonce), (0, bytes_1.bufferToBigInt)(balance), storageRoot, codeHash);\n  }\n  _validate() {\n    if (this.nonce < _0n) {\n      throw new Error('nonce must be greater than zero');\n    }\n    if (this.balance < _0n) {\n      throw new Error('balance must be greater than zero');\n    }\n    if (this.storageRoot.length !== 32) {\n      throw new Error('storageRoot must have a length of 32');\n    }\n    if (this.codeHash.length !== 32) {\n      throw new Error('codeHash must have a length of 32');\n    }\n  }\n  /**\n   * Returns a Buffer Array of the raw Buffers for the account, in order.\n   */\n  raw() {\n    return [(0, bytes_1.bigIntToUnpaddedBuffer)(this.nonce), (0, bytes_1.bigIntToUnpaddedBuffer)(this.balance), this.storageRoot, this.codeHash];\n  }\n  /**\n   * Returns the RLP serialization of the account as a `Buffer`.\n   */\n  serialize() {\n    return Buffer.from(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)(this.raw())));\n  }\n  /**\n   * Returns a `Boolean` determining if the account is a contract.\n   */\n  isContract() {\n    return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n  }\n  /**\n   * Returns a `Boolean` determining if the account is empty complying to the definition of\n   * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n   * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n   */\n  isEmpty() {\n    return this.balance === _0n && this.nonce === _0n && this.codeHash.equals(constants_1.KECCAK256_NULL);\n  }\n}\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nconst isValidAddress = function (hexAddress) {\n  try {\n    (0, helpers_1.assertIsString)(hexAddress);\n  } catch (e) {\n    return false;\n  }\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\nexports.isValidAddress = isValidAddress;\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\nconst toChecksumAddress = function (hexAddress, eip1191ChainId) {\n  (0, helpers_1.assertIsHexString)(hexAddress);\n  const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\n  let prefix = '';\n  if (eip1191ChainId !== undefined) {\n    const chainId = (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(eip1191ChainId));\n    prefix = chainId.toString() + '0x';\n  }\n  const buf = Buffer.from(prefix + address, 'utf8');\n  const hash = (0, utils_1.bytesToHex)((0, keccak_1.keccak256)(buf));\n  let ret = '0x';\n  for (let i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n  return ret;\n};\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nconst isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n  return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\n};\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nconst generateAddress = function (from, nonce) {\n  (0, helpers_1.assertIsBuffer)(from);\n  (0, helpers_1.assertIsBuffer)(nonce);\n  if ((0, bytes_1.bufferToBigInt)(nonce) === BigInt(0)) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, null])))).slice(-20);\n  }\n  // Only take the lower 160bits of the hash\n  return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, nonce])))).slice(-20);\n};\nexports.generateAddress = generateAddress;\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nconst generateAddress2 = function (from, salt, initCode) {\n  (0, helpers_1.assertIsBuffer)(from);\n  (0, helpers_1.assertIsBuffer)(salt);\n  (0, helpers_1.assertIsBuffer)(initCode);\n  if (from.length !== 20) {\n    throw new Error('Expected from to be of length 20');\n  }\n  if (salt.length !== 32) {\n    throw new Error('Expected salt to be of length 32');\n  }\n  const address = (0, keccak_1.keccak256)(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, (0, keccak_1.keccak256)(initCode)]));\n  return (0, bytes_1.toBuffer)(address).slice(-20);\n};\nexports.generateAddress2 = generateAddress2;\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nconst isValidPrivate = function (privateKey) {\n  return secp256k1_1.secp256k1.utils.isValidPrivateKey(privateKey);\n};\nexports.isValidPrivate = isValidPrivate;\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nconst isValidPublic = function (publicKey, sanitize = false) {\n  (0, helpers_1.assertIsBuffer)(publicKey);\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    // Automatically checks whether point is on curve\n    try {\n      secp256k1_1.secp256k1.ProjectivePoint.fromHex(Buffer.concat([Buffer.from([4]), publicKey]));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  if (!sanitize) {\n    return false;\n  }\n  try {\n    secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nexports.isValidPublic = isValidPublic;\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nconst pubToAddress = function (pubKey, sanitize = false) {\n  (0, helpers_1.assertIsBuffer)(pubKey);\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1));\n  }\n  if (pubKey.length !== 64) {\n    throw new Error('Expected pubKey to be of length 64');\n  }\n  // Only take the lower 160bits of the hash\n  return Buffer.from((0, keccak_1.keccak256)(pubKey)).slice(-20);\n};\nexports.pubToAddress = pubToAddress;\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nconst privateToPublic = function (privateKey) {\n  (0, helpers_1.assertIsBuffer)(privateKey);\n  // skip the type flag and use the X, Y points\n  return Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1));\n};\nexports.privateToPublic = privateToPublic;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nconst privateToAddress = function (privateKey) {\n  return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\n};\nexports.privateToAddress = privateToAddress;\n/**\n * Converts a public key to the Ethereum format.\n */\nconst importPublic = function (publicKey) {\n  (0, helpers_1.assertIsBuffer)(publicKey);\n  if (publicKey.length !== 64) {\n    publicKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(false).slice(1));\n  }\n  return publicKey;\n};\nexports.importPublic = importPublic;\n/**\n * Returns the zero address.\n */\nconst zeroAddress = function () {\n  const addressLength = 20;\n  const addr = (0, bytes_1.zeros)(addressLength);\n  return (0, bytes_1.bufferToHex)(addr);\n};\nexports.zeroAddress = zeroAddress;\n/**\n * Checks if a given address is the zero address.\n */\nconst isZeroAddress = function (hexAddress) {\n  try {\n    (0, helpers_1.assertIsString)(hexAddress);\n  } catch (e) {\n    return false;\n  }\n  const zeroAddr = (0, exports.zeroAddress)();\n  return zeroAddr === hexAddress;\n};\nexports.isZeroAddress = isZeroAddress;\nfunction accountBodyFromSlim(body) {\n  const [nonce, balance, storageRoot, codeHash] = body;\n  return [nonce, balance, (0, bytes_1.arrToBufArr)(storageRoot).length === 0 ? constants_1.KECCAK256_RLP : storageRoot, (0, bytes_1.arrToBufArr)(codeHash).length === 0 ? constants_1.KECCAK256_NULL : codeHash];\n}\nexports.accountBodyFromSlim = accountBodyFromSlim;\nconst emptyUint8Arr = new Uint8Array(0);\nfunction accountBodyToSlim(body) {\n  const [nonce, balance, storageRoot, codeHash] = body;\n  return [nonce, balance, (0, bytes_1.arrToBufArr)(storageRoot).equals(constants_1.KECCAK256_RLP) ? emptyUint8Arr : storageRoot, (0, bytes_1.arrToBufArr)(codeHash).equals(constants_1.KECCAK256_NULL) ? emptyUint8Arr : codeHash];\n}\nexports.accountBodyToSlim = accountBodyToSlim;\n/**\n * Converts a slim account (per snap protocol spec) to the RLP encoded version of the account\n * @param body Array of 4 Buffer-like items to represent the account\n * @returns RLP encoded version of the account\n */\nfunction accountBodyToRLP(body, couldBeSlim = true) {\n  const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body;\n  return (0, bytes_1.arrToBufArr)(rlp_1.RLP.encode(accountBody));\n}\nexports.accountBodyToRLP = accountBodyToRLP;","map":{"version":3,"names":["rlp_1","require","keccak_1","secp256k1_1","utils_1","bytes_1","constants_1","helpers_1","internal_1","_0n","BigInt","Account","constructor","nonce","balance","storageRoot","KECCAK256_RLP","codeHash","KECCAK256_NULL","_validate","fromAccountData","accountData","undefined","bufferToBigInt","toBuffer","fromRlpSerializedAccount","serialized","values","arrToBufArr","RLP","decode","Uint8Array","from","Array","isArray","Error","fromValuesArray","length","raw","bigIntToUnpaddedBuffer","serialize","Buffer","encode","bufArrToArr","isContract","equals","isEmpty","exports","isValidAddress","hexAddress","assertIsString","e","test","toChecksumAddress","eip1191ChainId","assertIsHexString","address","stripHexPrefix","toLowerCase","prefix","chainId","toString","buf","hash","bytesToHex","keccak256","ret","i","parseInt","toUpperCase","isValidChecksumAddress","generateAddress","assertIsBuffer","slice","generateAddress2","salt","initCode","concat","isValidPrivate","privateKey","secp256k1","utils","isValidPrivateKey","isValidPublic","publicKey","sanitize","ProjectivePoint","fromHex","pubToAddress","pubKey","toRawBytes","publicToAddress","privateToPublic","fromPrivateKey","privateToAddress","importPublic","zeroAddress","addressLength","addr","zeros","bufferToHex","isZeroAddress","zeroAddr","accountBodyFromSlim","body","emptyUint8Arr","accountBodyToSlim","accountBodyToRLP","couldBeSlim","accountBody"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@ethereumjs/util/src/account.ts"],"sourcesContent":["import { RLP } from '@ethereumjs/rlp'\nimport { keccak256 } from 'ethereum-cryptography/keccak'\nimport { secp256k1 } from 'ethereum-cryptography/secp256k1'\nimport { bytesToHex } from 'ethereum-cryptography/utils'\n\nimport {\n  arrToBufArr,\n  bigIntToUnpaddedBuffer,\n  bufArrToArr,\n  bufferToBigInt,\n  bufferToHex,\n  toBuffer,\n  zeros,\n} from './bytes'\nimport { KECCAK256_NULL, KECCAK256_RLP } from './constants'\nimport { assertIsBuffer, assertIsHexString, assertIsString } from './helpers'\nimport { stripHexPrefix } from './internal'\n\nimport type { BigIntLike, BufferLike } from './types'\n\nconst _0n = BigInt(0)\n\nexport interface AccountData {\n  nonce?: BigIntLike\n  balance?: BigIntLike\n  storageRoot?: BufferLike\n  codeHash?: BufferLike\n}\n\nexport type AccountBodyBuffer = [Buffer, Buffer, Buffer | Uint8Array, Buffer | Uint8Array]\n\nexport class Account {\n  nonce: bigint\n  balance: bigint\n  storageRoot: Buffer\n  codeHash: Buffer\n\n  static fromAccountData(accountData: AccountData) {\n    const { nonce, balance, storageRoot, codeHash } = accountData\n\n    return new Account(\n      nonce !== undefined ? bufferToBigInt(toBuffer(nonce)) : undefined,\n      balance !== undefined ? bufferToBigInt(toBuffer(balance)) : undefined,\n      storageRoot !== undefined ? toBuffer(storageRoot) : undefined,\n      codeHash !== undefined ? toBuffer(codeHash) : undefined\n    )\n  }\n\n  public static fromRlpSerializedAccount(serialized: Buffer) {\n    const values = arrToBufArr(RLP.decode(Uint8Array.from(serialized)) as Uint8Array[]) as Buffer[]\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array')\n    }\n\n    return this.fromValuesArray(values)\n  }\n\n  public static fromValuesArray(values: Buffer[]) {\n    const [nonce, balance, storageRoot, codeHash] = values\n\n    return new Account(bufferToBigInt(nonce), bufferToBigInt(balance), storageRoot, codeHash)\n  }\n\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating an Account from varying data types.\n   */\n  constructor(nonce = _0n, balance = _0n, storageRoot = KECCAK256_RLP, codeHash = KECCAK256_NULL) {\n    this.nonce = nonce\n    this.balance = balance\n    this.storageRoot = storageRoot\n    this.codeHash = codeHash\n\n    this._validate()\n  }\n\n  private _validate() {\n    if (this.nonce < _0n) {\n      throw new Error('nonce must be greater than zero')\n    }\n    if (this.balance < _0n) {\n      throw new Error('balance must be greater than zero')\n    }\n    if (this.storageRoot.length !== 32) {\n      throw new Error('storageRoot must have a length of 32')\n    }\n    if (this.codeHash.length !== 32) {\n      throw new Error('codeHash must have a length of 32')\n    }\n  }\n\n  /**\n   * Returns a Buffer Array of the raw Buffers for the account, in order.\n   */\n  raw(): Buffer[] {\n    return [\n      bigIntToUnpaddedBuffer(this.nonce),\n      bigIntToUnpaddedBuffer(this.balance),\n      this.storageRoot,\n      this.codeHash,\n    ]\n  }\n\n  /**\n   * Returns the RLP serialization of the account as a `Buffer`.\n   */\n  serialize(): Buffer {\n    return Buffer.from(RLP.encode(bufArrToArr(this.raw())))\n  }\n\n  /**\n   * Returns a `Boolean` determining if the account is a contract.\n   */\n  isContract(): boolean {\n    return !this.codeHash.equals(KECCAK256_NULL)\n  }\n\n  /**\n   * Returns a `Boolean` determining if the account is empty complying to the definition of\n   * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n   * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n   */\n  isEmpty(): boolean {\n    return this.balance === _0n && this.nonce === _0n && this.codeHash.equals(KECCAK256_NULL)\n  }\n}\n\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nexport const isValidAddress = function (hexAddress: string): boolean {\n  try {\n    assertIsString(hexAddress)\n  } catch (e: any) {\n    return false\n  }\n\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress)\n}\n\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\nexport const toChecksumAddress = function (\n  hexAddress: string,\n  eip1191ChainId?: BigIntLike\n): string {\n  assertIsHexString(hexAddress)\n  const address = stripHexPrefix(hexAddress).toLowerCase()\n\n  let prefix = ''\n  if (eip1191ChainId !== undefined) {\n    const chainId = bufferToBigInt(toBuffer(eip1191ChainId))\n    prefix = chainId.toString() + '0x'\n  }\n\n  const buf = Buffer.from(prefix + address, 'utf8')\n  const hash = bytesToHex(keccak256(buf))\n  let ret = '0x'\n\n  for (let i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase()\n    } else {\n      ret += address[i]\n    }\n  }\n\n  return ret\n}\n\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nexport const isValidChecksumAddress = function (\n  hexAddress: string,\n  eip1191ChainId?: BigIntLike\n): boolean {\n  return isValidAddress(hexAddress) && toChecksumAddress(hexAddress, eip1191ChainId) === hexAddress\n}\n\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexport const generateAddress = function (from: Buffer, nonce: Buffer): Buffer {\n  assertIsBuffer(from)\n  assertIsBuffer(nonce)\n\n  if (bufferToBigInt(nonce) === BigInt(0)) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return Buffer.from(keccak256(RLP.encode(bufArrToArr([from, null] as any)))).slice(-20)\n  }\n\n  // Only take the lower 160bits of the hash\n  return Buffer.from(keccak256(RLP.encode(bufArrToArr([from, nonce])))).slice(-20)\n}\n\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexport const generateAddress2 = function (from: Buffer, salt: Buffer, initCode: Buffer): Buffer {\n  assertIsBuffer(from)\n  assertIsBuffer(salt)\n  assertIsBuffer(initCode)\n\n  if (from.length !== 20) {\n    throw new Error('Expected from to be of length 20')\n  }\n  if (salt.length !== 32) {\n    throw new Error('Expected salt to be of length 32')\n  }\n\n  const address = keccak256(\n    Buffer.concat([Buffer.from('ff', 'hex'), from, salt, keccak256(initCode)])\n  )\n\n  return toBuffer(address).slice(-20)\n}\n\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nexport const isValidPrivate = function (privateKey: Buffer): boolean {\n  return secp256k1.utils.isValidPrivateKey(privateKey)\n}\n\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexport const isValidPublic = function (publicKey: Buffer, sanitize: boolean = false): boolean {\n  assertIsBuffer(publicKey)\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    // Automatically checks whether point is on curve\n    try {\n      secp256k1.ProjectivePoint.fromHex(Buffer.concat([Buffer.from([4]), publicKey]))\n      return true\n    } catch (e) {\n      return false\n    }\n  }\n\n  if (!sanitize) {\n    return false\n  }\n\n  try {\n    secp256k1.ProjectivePoint.fromHex(publicKey)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexport const pubToAddress = function (pubKey: Buffer, sanitize: boolean = false): Buffer {\n  assertIsBuffer(pubKey)\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = Buffer.from(secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1))\n  }\n  if (pubKey.length !== 64) {\n    throw new Error('Expected pubKey to be of length 64')\n  }\n  // Only take the lower 160bits of the hash\n  return Buffer.from(keccak256(pubKey)).slice(-20)\n}\nexport const publicToAddress = pubToAddress\n\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexport const privateToPublic = function (privateKey: Buffer): Buffer {\n  assertIsBuffer(privateKey)\n  // skip the type flag and use the X, Y points\n  return Buffer.from(\n    secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1)\n  )\n}\n\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexport const privateToAddress = function (privateKey: Buffer): Buffer {\n  return publicToAddress(privateToPublic(privateKey))\n}\n\n/**\n * Converts a public key to the Ethereum format.\n */\nexport const importPublic = function (publicKey: Buffer): Buffer {\n  assertIsBuffer(publicKey)\n  if (publicKey.length !== 64) {\n    publicKey = Buffer.from(secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(false).slice(1))\n  }\n  return publicKey\n}\n\n/**\n * Returns the zero address.\n */\nexport const zeroAddress = function (): string {\n  const addressLength = 20\n  const addr = zeros(addressLength)\n  return bufferToHex(addr)\n}\n\n/**\n * Checks if a given address is the zero address.\n */\nexport const isZeroAddress = function (hexAddress: string): boolean {\n  try {\n    assertIsString(hexAddress)\n  } catch (e: any) {\n    return false\n  }\n\n  const zeroAddr = zeroAddress()\n  return zeroAddr === hexAddress\n}\n\nexport function accountBodyFromSlim(body: AccountBodyBuffer) {\n  const [nonce, balance, storageRoot, codeHash] = body\n  return [\n    nonce,\n    balance,\n    arrToBufArr(storageRoot).length === 0 ? KECCAK256_RLP : storageRoot,\n    arrToBufArr(codeHash).length === 0 ? KECCAK256_NULL : codeHash,\n  ]\n}\n\nconst emptyUint8Arr = new Uint8Array(0)\nexport function accountBodyToSlim(body: AccountBodyBuffer) {\n  const [nonce, balance, storageRoot, codeHash] = body\n  return [\n    nonce,\n    balance,\n    arrToBufArr(storageRoot).equals(KECCAK256_RLP) ? emptyUint8Arr : storageRoot,\n    arrToBufArr(codeHash).equals(KECCAK256_NULL) ? emptyUint8Arr : codeHash,\n  ]\n}\n\n/**\n * Converts a slim account (per snap protocol spec) to the RLP encoded version of the account\n * @param body Array of 4 Buffer-like items to represent the account\n * @returns RLP encoded version of the account\n */\nexport function accountBodyToRLP(body: AccountBodyBuffer, couldBeSlim = true) {\n  const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body\n  return arrToBufArr(RLP.encode(accountBody))\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}