{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _regeneratorRuntime = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _slicedToArray = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EventParser = exports.EventManager = void 0;\nvar assert = __importStar(require(\"assert\"));\nvar PROGRAM_LOG = \"Program log: \";\nvar PROGRAM_DATA = \"Program data: \";\nvar PROGRAM_LOG_START_INDEX = PROGRAM_LOG.length;\nvar PROGRAM_DATA_START_INDEX = PROGRAM_DATA.length;\nvar EventManager = /*#__PURE__*/function () {\n  function EventManager(programId, provider, coder) {\n    _classCallCheck(this, EventManager);\n    this._programId = programId;\n    this._provider = provider;\n    this._eventParser = new EventParser(programId, coder);\n    this._eventCallbacks = new Map();\n    this._eventListeners = new Map();\n    this._listenerIdCount = 0;\n  }\n  _createClass(EventManager, [{\n    key: \"addEventListener\",\n    value: function addEventListener(eventName, callback) {\n      var _this = this;\n      var _a;\n      var listener = this._listenerIdCount;\n      this._listenerIdCount += 1;\n      // Store the listener into the event map.\n      if (!(eventName in this._eventCallbacks)) {\n        this._eventListeners.set(eventName, []);\n      }\n      this._eventListeners.set(eventName, ((_a = this._eventListeners.get(eventName)) !== null && _a !== void 0 ? _a : []).concat(listener));\n      // Store the callback into the listener map.\n      this._eventCallbacks.set(listener, [eventName, callback]);\n      // Create the subscription singleton, if needed.\n      if (this._onLogsSubscriptionId !== undefined) {\n        return listener;\n      }\n      this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, function (logs, ctx) {\n        if (logs.err) {\n          return;\n        }\n        _this._eventParser.parseLogs(logs.logs, function (event) {\n          var allListeners = _this._eventListeners.get(event.name);\n          if (allListeners) {\n            allListeners.forEach(function (listener) {\n              var listenerCb = _this._eventCallbacks.get(listener);\n              if (listenerCb) {\n                var _listenerCb = _slicedToArray(listenerCb, 2),\n                  _callback = _listenerCb[1];\n                _callback(event.data, ctx.slot);\n              }\n            });\n          }\n        });\n      });\n      return listener;\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function () {\n      var _removeEventListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(listener) {\n        var callback, _callback2, eventName, listeners;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              // Get the callback.\n              callback = this._eventCallbacks.get(listener);\n              if (callback) {\n                _context.next = 3;\n                break;\n              }\n              throw new Error(\"Event listener \".concat(listener, \" doesn't exist!\"));\n            case 3:\n              _callback2 = _slicedToArray(callback, 1), eventName = _callback2[0]; // Get the listeners.\n              listeners = this._eventListeners.get(eventName);\n              if (listeners) {\n                _context.next = 7;\n                break;\n              }\n              throw new Error(\"Event listeners don't exist for \".concat(eventName, \"!\"));\n            case 7:\n              // Update both maps.\n              this._eventCallbacks.delete(listener);\n              listeners = listeners.filter(function (l) {\n                return l !== listener;\n              });\n              if (listeners.length === 0) {\n                this._eventListeners.delete(eventName);\n              }\n              // Kill the websocket connection if all listeners have been removed.\n              if (!(this._eventCallbacks.size == 0)) {\n                _context.next = 16;\n                break;\n              }\n              assert.ok(this._eventListeners.size === 0);\n              if (!(this._onLogsSubscriptionId !== undefined)) {\n                _context.next = 16;\n                break;\n              }\n              _context.next = 15;\n              return this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);\n            case 15:\n              this._onLogsSubscriptionId = undefined;\n            case 16:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function removeEventListener(_x) {\n        return _removeEventListener.apply(this, arguments);\n      }\n      return removeEventListener;\n    }()\n  }]);\n  return EventManager;\n}();\nexports.EventManager = EventManager;\nvar EventParser = /*#__PURE__*/function () {\n  function EventParser(programId, coder) {\n    _classCallCheck(this, EventParser);\n    this.coder = coder;\n    this.programId = programId;\n  }\n  // Each log given, represents an array of messages emitted by\n  // a single transaction, which can execute many different programs across\n  // CPI boundaries. However, the subscription is only interested in the\n  // events emitted by *this* program. In achieving this, we keep track of the\n  // program execution context by parsing each log and looking for a CPI\n  // `invoke` call. If one exists, we know a new program is executing. So we\n  // push the programId onto a stack and switch the program context. This\n  // allows us to track, for a given log, which program was executing during\n  // its emission, thereby allowing us to know if a given log event was\n  // emitted by *this* program. If it was, then we parse the raw string and\n  // emit the event if the string matches the event being subscribed to.\n  _createClass(EventParser, [{\n    key: \"parseLogs\",\n    value: function parseLogs(logs, callback) {\n      var logScanner = new LogScanner(logs);\n      var execution = new ExecutionContext();\n      var log = logScanner.next();\n      while (log !== null) {\n        var _this$handleLog = this.handleLog(execution, log),\n          _this$handleLog2 = _slicedToArray(_this$handleLog, 3),\n          event = _this$handleLog2[0],\n          newProgram = _this$handleLog2[1],\n          didPop = _this$handleLog2[2];\n        if (event) {\n          callback(event);\n        }\n        if (newProgram) {\n          execution.push(newProgram);\n        }\n        if (didPop) {\n          execution.pop();\n        }\n        log = logScanner.next();\n      }\n    }\n    // Main log handler. Returns a three element array of the event, the\n    // next program that was invoked for CPI, and a boolean indicating if\n    // a program has completed execution (and thus should be popped off the\n    // execution stack).\n  }, {\n    key: \"handleLog\",\n    value: function handleLog(execution, log) {\n      // Executing program is this program.\n      if (execution.stack.length > 0 && execution.program() === this.programId.toString()) {\n        return this.handleProgramLog(log);\n      }\n      // Executing program is not this program.\n      else {\n        return [null].concat(_toConsumableArray(this.handleSystemLog(log)));\n      }\n    }\n    // Handles logs from *this* program.\n  }, {\n    key: \"handleProgramLog\",\n    value: function handleProgramLog(log) {\n      // This is a `msg!` log or a `sol_log_data` log.\n      if (log.startsWith(PROGRAM_LOG) || log.startsWith(PROGRAM_DATA)) {\n        var logStr = log.startsWith(PROGRAM_LOG) ? log.slice(PROGRAM_LOG_START_INDEX) : log.slice(PROGRAM_DATA_START_INDEX);\n        var event = this.coder.events.decode(logStr);\n        return [event, null, false];\n      }\n      // System log.\n      else {\n        return [null].concat(_toConsumableArray(this.handleSystemLog(log)));\n      }\n    }\n    // Handles logs when the current program being executing is *not* this.\n  }, {\n    key: \"handleSystemLog\",\n    value: function handleSystemLog(log) {\n      // System component.\n      var logStart = log.split(\":\")[0];\n      // Did the program finish executing?\n      if (logStart.match(/^Program (.*) success/g) !== null) {\n        return [null, true];\n        // Recursive call.\n      } else if (logStart.startsWith(\"Program \".concat(this.programId.toString(), \" invoke\"))) {\n        return [this.programId.toString(), false];\n      }\n      // CPI call.\n      else if (logStart.includes(\"invoke\")) {\n        return [\"cpi\", false]; // Any string will do.\n      } else {\n        return [null, false];\n      }\n    }\n  }]);\n  return EventParser;\n}();\nexports.EventParser = EventParser;\n// Stack frame execution context, allowing one to track what program is\n// executing for a given log.\nvar ExecutionContext = /*#__PURE__*/function () {\n  function ExecutionContext() {\n    _classCallCheck(this, ExecutionContext);\n    this.stack = [];\n  }\n  _createClass(ExecutionContext, [{\n    key: \"program\",\n    value: function program() {\n      assert.ok(this.stack.length > 0);\n      return this.stack[this.stack.length - 1];\n    }\n  }, {\n    key: \"push\",\n    value: function push(newProgram) {\n      this.stack.push(newProgram);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      assert.ok(this.stack.length > 0);\n      this.stack.pop();\n    }\n  }]);\n  return ExecutionContext;\n}();\nvar LogScanner = /*#__PURE__*/function () {\n  function LogScanner(logs) {\n    _classCallCheck(this, LogScanner);\n    this.logs = logs;\n  }\n  _createClass(LogScanner, [{\n    key: \"next\",\n    value: function next() {\n      if (this.logs.length === 0) {\n        return null;\n      }\n      var l = this.logs[0];\n      this.logs = this.logs.slice(1);\n      return l;\n    }\n  }]);\n  return LogScanner;\n}();","map":{"version":3,"names":["assert","__importStar","require","PROGRAM_LOG","PROGRAM_DATA","PROGRAM_LOG_START_INDEX","length","PROGRAM_DATA_START_INDEX","EventManager","programId","provider","coder","_classCallCheck","_programId","_provider","_eventParser","EventParser","_eventCallbacks","Map","_eventListeners","_listenerIdCount","_createClass","key","value","addEventListener","eventName","callback","_this","listener","set","_a","get","concat","_onLogsSubscriptionId","undefined","connection","onLogs","logs","ctx","err","parseLogs","event","allListeners","name","forEach","listenerCb","_listenerCb","_slicedToArray","data","slot","_removeEventListener","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_callback2","listeners","wrap","_callee$","_context","prev","next","Error","delete","filter","l","size","ok","removeOnLogsListener","stop","removeEventListener","_x","apply","arguments","exports","logScanner","LogScanner","execution","ExecutionContext","log","_this$handleLog","handleLog","_this$handleLog2","newProgram","didPop","push","pop","stack","program","toString","handleProgramLog","_toConsumableArray","handleSystemLog","startsWith","logStr","slice","events","decode","logStart","split","match","includes"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/program/event.ts"],"sourcesContent":["import { PublicKey } from \"@solana/web3.js\";\nimport * as assert from \"assert\";\nimport { IdlEvent, IdlEventField } from \"../idl.js\";\nimport { Coder } from \"../coder/index.js\";\nimport { DecodeType } from \"./namespace/types.js\";\nimport Provider from \"../provider.js\";\n\nconst PROGRAM_LOG = \"Program log: \";\nconst PROGRAM_DATA = \"Program data: \";\nconst PROGRAM_LOG_START_INDEX = PROGRAM_LOG.length;\nconst PROGRAM_DATA_START_INDEX = PROGRAM_DATA.length;\n\n// Deserialized event.\nexport type Event<\n  E extends IdlEvent = IdlEvent,\n  Defined = Record<string, never>\n> = {\n  name: E[\"name\"];\n  data: EventData<E[\"fields\"][number], Defined>;\n};\n\nexport type EventData<T extends IdlEventField, Defined> = {\n  [N in T[\"name\"]]: DecodeType<(T & { name: N })[\"type\"], Defined>;\n};\n\ntype EventCallback = (event: any, slot: number) => void;\n\nexport class EventManager {\n  /**\n   * Program ID for event subscriptions.\n   */\n  private _programId: PublicKey;\n\n  /**\n   * Network and wallet provider.\n   */\n  private _provider: Provider;\n\n  /**\n   * Event parser to handle onLogs callbacks.\n   */\n  private _eventParser: EventParser;\n\n  /**\n   * Maps event listener id to [event-name, callback].\n   */\n  private _eventCallbacks: Map<number, [string, EventCallback]>;\n\n  /**\n   * Maps event name to all listeners for the event.\n   */\n  private _eventListeners: Map<string, Array<number>>;\n\n  /**\n   * The next listener id to allocate.\n   */\n  private _listenerIdCount: number;\n\n  /**\n   * The subscription id from the connection onLogs subscription.\n   */\n  private _onLogsSubscriptionId: number | undefined;\n\n  constructor(programId: PublicKey, provider: Provider, coder: Coder) {\n    this._programId = programId;\n    this._provider = provider;\n    this._eventParser = new EventParser(programId, coder);\n    this._eventCallbacks = new Map();\n    this._eventListeners = new Map();\n    this._listenerIdCount = 0;\n  }\n\n  public addEventListener(\n    eventName: string,\n    callback: (event: any, slot: number) => void\n  ): number {\n    let listener = this._listenerIdCount;\n    this._listenerIdCount += 1;\n\n    // Store the listener into the event map.\n    if (!(eventName in this._eventCallbacks)) {\n      this._eventListeners.set(eventName, []);\n    }\n    this._eventListeners.set(\n      eventName,\n      (this._eventListeners.get(eventName) ?? []).concat(listener)\n    );\n\n    // Store the callback into the listener map.\n    this._eventCallbacks.set(listener, [eventName, callback]);\n\n    // Create the subscription singleton, if needed.\n    if (this._onLogsSubscriptionId !== undefined) {\n      return listener;\n    }\n\n    this._onLogsSubscriptionId = this._provider!.connection.onLogs(\n      this._programId,\n      (logs, ctx) => {\n        if (logs.err) {\n          return;\n        }\n        this._eventParser.parseLogs(logs.logs, (event) => {\n          const allListeners = this._eventListeners.get(event.name);\n          if (allListeners) {\n            allListeners.forEach((listener) => {\n              const listenerCb = this._eventCallbacks.get(listener);\n              if (listenerCb) {\n                const [, callback] = listenerCb;\n                callback(event.data, ctx.slot);\n              }\n            });\n          }\n        });\n      }\n    );\n\n    return listener;\n  }\n\n  public async removeEventListener(listener: number): Promise<void> {\n    // Get the callback.\n    const callback = this._eventCallbacks.get(listener);\n    if (!callback) {\n      throw new Error(`Event listener ${listener} doesn't exist!`);\n    }\n    const [eventName] = callback;\n\n    // Get the listeners.\n    let listeners = this._eventListeners.get(eventName);\n    if (!listeners) {\n      throw new Error(`Event listeners don't exist for ${eventName}!`);\n    }\n\n    // Update both maps.\n    this._eventCallbacks.delete(listener);\n    listeners = listeners.filter((l) => l !== listener);\n    if (listeners.length === 0) {\n      this._eventListeners.delete(eventName);\n    }\n\n    // Kill the websocket connection if all listeners have been removed.\n    if (this._eventCallbacks.size == 0) {\n      assert.ok(this._eventListeners.size === 0);\n      if (this._onLogsSubscriptionId !== undefined) {\n        await this._provider!.connection.removeOnLogsListener(\n          this._onLogsSubscriptionId\n        );\n        this._onLogsSubscriptionId = undefined;\n      }\n    }\n  }\n}\n\nexport class EventParser {\n  private coder: Coder;\n  private programId: PublicKey;\n\n  constructor(programId: PublicKey, coder: Coder) {\n    this.coder = coder;\n    this.programId = programId;\n  }\n\n  // Each log given, represents an array of messages emitted by\n  // a single transaction, which can execute many different programs across\n  // CPI boundaries. However, the subscription is only interested in the\n  // events emitted by *this* program. In achieving this, we keep track of the\n  // program execution context by parsing each log and looking for a CPI\n  // `invoke` call. If one exists, we know a new program is executing. So we\n  // push the programId onto a stack and switch the program context. This\n  // allows us to track, for a given log, which program was executing during\n  // its emission, thereby allowing us to know if a given log event was\n  // emitted by *this* program. If it was, then we parse the raw string and\n  // emit the event if the string matches the event being subscribed to.\n  public parseLogs(logs: string[], callback: (log: Event) => void) {\n    const logScanner = new LogScanner(logs);\n    const execution = new ExecutionContext();\n    let log = logScanner.next();\n    while (log !== null) {\n      let [event, newProgram, didPop] = this.handleLog(execution, log);\n      if (event) {\n        callback(event);\n      }\n      if (newProgram) {\n        execution.push(newProgram);\n      }\n      if (didPop) {\n        execution.pop();\n      }\n      log = logScanner.next();\n    }\n  }\n\n  // Main log handler. Returns a three element array of the event, the\n  // next program that was invoked for CPI, and a boolean indicating if\n  // a program has completed execution (and thus should be popped off the\n  // execution stack).\n  private handleLog(\n    execution: ExecutionContext,\n    log: string\n  ): [Event | null, string | null, boolean] {\n    // Executing program is this program.\n    if (\n      execution.stack.length > 0 &&\n      execution.program() === this.programId.toString()\n    ) {\n      return this.handleProgramLog(log);\n    }\n    // Executing program is not this program.\n    else {\n      return [null, ...this.handleSystemLog(log)];\n    }\n  }\n\n  // Handles logs from *this* program.\n  private handleProgramLog(\n    log: string\n  ): [Event | null, string | null, boolean] {\n    // This is a `msg!` log or a `sol_log_data` log.\n    if (log.startsWith(PROGRAM_LOG) || log.startsWith(PROGRAM_DATA)) {\n      const logStr = log.startsWith(PROGRAM_LOG)\n        ? log.slice(PROGRAM_LOG_START_INDEX)\n        : log.slice(PROGRAM_DATA_START_INDEX);\n      const event = this.coder.events.decode(logStr);\n      return [event, null, false];\n    }\n    // System log.\n    else {\n      return [null, ...this.handleSystemLog(log)];\n    }\n  }\n\n  // Handles logs when the current program being executing is *not* this.\n  private handleSystemLog(log: string): [string | null, boolean] {\n    // System component.\n    const logStart = log.split(\":\")[0];\n\n    // Did the program finish executing?\n    if (logStart.match(/^Program (.*) success/g) !== null) {\n      return [null, true];\n      // Recursive call.\n    } else if (\n      logStart.startsWith(`Program ${this.programId.toString()} invoke`)\n    ) {\n      return [this.programId.toString(), false];\n    }\n    // CPI call.\n    else if (logStart.includes(\"invoke\")) {\n      return [\"cpi\", false]; // Any string will do.\n    } else {\n      return [null, false];\n    }\n  }\n}\n\n// Stack frame execution context, allowing one to track what program is\n// executing for a given log.\nclass ExecutionContext {\n  stack: string[] = [];\n\n  program(): string {\n    assert.ok(this.stack.length > 0);\n    return this.stack[this.stack.length - 1];\n  }\n\n  push(newProgram: string) {\n    this.stack.push(newProgram);\n  }\n\n  pop() {\n    assert.ok(this.stack.length > 0);\n    this.stack.pop();\n  }\n}\n\nclass LogScanner {\n  constructor(public logs: string[]) {}\n\n  next(): string | null {\n    if (this.logs.length === 0) {\n      return null;\n    }\n    let l = this.logs[0];\n    this.logs = this.logs.slice(1);\n    return l;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}