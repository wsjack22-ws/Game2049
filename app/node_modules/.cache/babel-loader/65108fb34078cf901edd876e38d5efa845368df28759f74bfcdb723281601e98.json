{"ast":null,"code":"import { inflate } from \"pako\";\nimport { idlAddress, decodeIdlAccount } from \"../idl\";\nimport Coder from \"../coder\";\nimport NamespaceFactory from \"./namespace\";\nimport { getProvider } from \"../\";\nimport { utf8 } from \"../utils/bytes\";\nimport { EventManager } from \"./event\";\nimport { translateAddress } from \"./common\";\nexport * from \"./common\";\nexport * from \"./context\";\nexport * from \"./event\";\nexport * from \"./namespace\";\n/**\n * ## Program\n *\n * Program provides the IDL deserialized client representation of an Anchor\n * program.\n *\n * This API is the one stop shop for all things related to communicating with\n * on-chain programs. Among other things, one can send transactions, fetch\n * deserialized accounts, decode instruction data, subscribe to account\n * changes, and listen to events.\n *\n * In addition to field accessors and methods, the object provides a set of\n * dynamically generated properties, also known as namespaces, that\n * map one-to-one to program methods and accounts. These namespaces generally\n *  can be used as follows:\n *\n * ## Usage\n *\n * ```javascript\n * program.<namespace>.<program-specific-method>\n * ```\n *\n * API specifics are namespace dependent. The examples used in the documentation\n * below will refer to the two counter examples found\n * [here](https://github.com/project-serum/anchor#examples).\n */\nexport class Program {\n  /**\n   * @param idl       The interface definition.\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context to use. If not provided\n   *                  then uses [[getProvider]].\n   */\n  constructor(idl, programId, provider) {\n    programId = translateAddress(programId);\n    if (!provider) {\n      provider = getProvider();\n    }\n    // Fields.\n    this._idl = idl;\n    this._provider = provider;\n    this._programId = programId;\n    this._coder = new Coder(idl);\n    this._events = new EventManager(this._programId, provider, this._coder);\n    // Dynamic namespaces.\n    const [rpc, instruction, transaction, account, simulate, state] = NamespaceFactory.build(idl, this._coder, programId, provider);\n    this.rpc = rpc;\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.account = account;\n    this.simulate = simulate;\n    this.state = state;\n  }\n  /**\n   * Address of the program.\n   */\n  get programId() {\n    return this._programId;\n  }\n  /**\n   * IDL defining the program's interface.\n   */\n  get idl() {\n    return this._idl;\n  }\n  /**\n   * Coder for serializing requests.\n   */\n  get coder() {\n    return this._coder;\n  }\n  /**\n   * Wallet and network provider.\n   */\n  get provider() {\n    return this._provider;\n  }\n  /**\n   * Generates a Program client by fetching the IDL from the network.\n   *\n   * In order to use this method, an IDL must have been previously initialized\n   * via the anchor CLI's `anchor idl init` command.\n   *\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context.\n   */\n  static async at(address, provider) {\n    const programId = translateAddress(address);\n    const idl = await Program.fetchIdl(programId, provider);\n    if (!idl) {\n      throw new Error(`IDL not found for program: ${address.toString()}`);\n    }\n    return new Program(idl, programId, provider);\n  }\n  /**\n   * Fetches an idl from the blockchain.\n   *\n   * In order to use this method, an IDL must have been previously initialized\n   * via the anchor CLI's `anchor idl init` command.\n   *\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context.\n   */\n  static async fetchIdl(address, provider) {\n    provider = provider !== null && provider !== void 0 ? provider : getProvider();\n    const programId = translateAddress(address);\n    const idlAddr = await idlAddress(programId);\n    const accountInfo = await provider.connection.getAccountInfo(idlAddr);\n    if (!accountInfo) {\n      return null;\n    }\n    // Chop off account discriminator.\n    let idlAccount = decodeIdlAccount(accountInfo.data.slice(8));\n    const inflatedIdl = inflate(idlAccount.data);\n    return JSON.parse(utf8.decode(inflatedIdl));\n  }\n  /**\n   * Invokes the given callback every time the given event is emitted.\n   *\n   * @param eventName The PascalCase name of the event, provided by the IDL.\n   * @param callback  The function to invoke whenever the event is emitted from\n   *                  program logs.\n   */\n  addEventListener(eventName, callback) {\n    return this._events.addEventListener(eventName, callback);\n  }\n  /**\n   * Unsubscribes from the given eventName.\n   */\n  async removeEventListener(listener) {\n    return await this._events.removeEventListener(listener);\n  }\n}","map":{"version":3,"names":["inflate","idlAddress","decodeIdlAccount","Coder","NamespaceFactory","getProvider","utf8","EventManager","translateAddress","Program","constructor","idl","programId","provider","_idl","_provider","_programId","_coder","_events","rpc","instruction","transaction","account","simulate","state","build","coder","at","address","fetchIdl","Error","toString","idlAddr","accountInfo","connection","getAccountInfo","idlAccount","data","slice","inflatedIdl","JSON","parse","decode","addEventListener","eventName","callback","removeEventListener","listener"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/program/index.ts"],"sourcesContent":["import { inflate } from \"pako\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport Provider from \"../provider\";\nimport { Idl, idlAddress, decodeIdlAccount } from \"../idl\";\nimport Coder from \"../coder\";\nimport NamespaceFactory, {\n  RpcNamespace,\n  InstructionNamespace,\n  TransactionNamespace,\n  AccountNamespace,\n  StateClient,\n  SimulateNamespace,\n} from \"./namespace\";\nimport { getProvider } from \"../\";\nimport { utf8 } from \"../utils/bytes\";\nimport { EventManager } from \"./event\";\nimport { Address, translateAddress } from \"./common\";\n\nexport * from \"./common\";\nexport * from \"./context\";\nexport * from \"./event\";\nexport * from \"./namespace\";\n\n/**\n * ## Program\n *\n * Program provides the IDL deserialized client representation of an Anchor\n * program.\n *\n * This API is the one stop shop for all things related to communicating with\n * on-chain programs. Among other things, one can send transactions, fetch\n * deserialized accounts, decode instruction data, subscribe to account\n * changes, and listen to events.\n *\n * In addition to field accessors and methods, the object provides a set of\n * dynamically generated properties, also known as namespaces, that\n * map one-to-one to program methods and accounts. These namespaces generally\n *  can be used as follows:\n *\n * ## Usage\n *\n * ```javascript\n * program.<namespace>.<program-specific-method>\n * ```\n *\n * API specifics are namespace dependent. The examples used in the documentation\n * below will refer to the two counter examples found\n * [here](https://github.com/project-serum/anchor#examples).\n */\nexport class Program<IDL extends Idl = Idl> {\n  /**\n   * Async methods to send signed transactions to *non*-state methods on the\n   * program, returning a [[TransactionSignature]].\n   *\n   * ## Usage\n   *\n   * ```javascript\n   * rpc.<method>(...args, ctx);\n   * ```\n   *\n   * ## Parameters\n   *\n   * 1. `args` - The positional arguments for the program. The type and number\n   *    of these arguments depend on the program being used.\n   * 2. `ctx`  - [[Context]] non-argument parameters to pass to the method.\n   *    Always the last parameter in the method call.\n   *\n   * ## Example\n   *\n   * To send a transaction invoking the `increment` method above,\n   *\n   * ```javascript\n   * const txSignature = await program.rpc.increment({\n   *   accounts: {\n   *     counter,\n   *     authority,\n   *   },\n   * });\n   * ```\n   */\n  readonly rpc: RpcNamespace<IDL>;\n\n  /**\n   * The namespace provides handles to an [[AccountClient]] object for each\n   * account in the program.\n   *\n   * ## Usage\n   *\n   * ```javascript\n   * program.account.<account-client>\n   * ```\n   *\n   * ## Example\n   *\n   * To fetch a `Counter` account from the above example,\n   *\n   * ```javascript\n   * const counter = await program.account.counter.fetch(address);\n   * ```\n   *\n   * For the full API, see the [[AccountClient]] reference.\n   */\n  readonly account: AccountNamespace<IDL>;\n\n  /**\n   * The namespace provides functions to build [[TransactionInstruction]]\n   * objects for each method of a program.\n   *\n   * ## Usage\n   *\n   * ```javascript\n   * program.instruction.<method>(...args, ctx);\n   * ```\n   *\n   * ## Parameters\n   *\n   * 1. `args` - The positional arguments for the program. The type and number\n   *    of these arguments depend on the program being used.\n   * 2. `ctx`  - [[Context]] non-argument parameters to pass to the method.\n   *    Always the last parameter in the method call.\n   *\n   * ## Example\n   *\n   * To create an instruction for the `increment` method above,\n   *\n   * ```javascript\n   * const tx = await program.instruction.increment({\n   *   accounts: {\n   *     counter,\n   *   },\n   * });\n   * ```\n   */\n  readonly instruction: InstructionNamespace<IDL>;\n\n  /**\n   * The namespace provides functions to build [[Transaction]] objects for each\n   * method of a program.\n   *\n   * ## Usage\n   *\n   * ```javascript\n   * program.transaction.<method>(...args, ctx);\n   * ```\n   *\n   * ## Parameters\n   *\n   * 1. `args` - The positional arguments for the program. The type and number\n   *    of these arguments depend on the program being used.\n   * 2. `ctx`  - [[Context]] non-argument parameters to pass to the method.\n   *    Always the last parameter in the method call.\n   *\n   * ## Example\n   *\n   * To create an instruction for the `increment` method above,\n   *\n   * ```javascript\n   * const tx = await program.transaction.increment({\n   *   accounts: {\n   *     counter,\n   *   },\n   * });\n   * ```\n   */\n  readonly transaction: TransactionNamespace<IDL>;\n\n  /**\n   * The namespace provides functions to simulate transactions for each method\n   * of a program, returning a list of deserialized events *and* raw program\n   * logs.\n   *\n   * One can use this to read data calculated from a program on chain, by\n   * emitting an event in the program and reading the emitted event client side\n   * via the `simulate` namespace.\n   *\n   * ## simulate\n   *\n   * ```javascript\n   * program.simulate.<method>(...args, ctx);\n   * ```\n   *\n   * ## Parameters\n   *\n   * 1. `args` - The positional arguments for the program. The type and number\n   *    of these arguments depend on the program being used.\n   * 2. `ctx`  - [[Context]] non-argument parameters to pass to the method.\n   *    Always the last parameter in the method call.\n   *\n   * ## Example\n   *\n   * To simulate the `increment` method above,\n   *\n   * ```javascript\n   * const events = await program.simulate.increment({\n   *   accounts: {\n   *     counter,\n   *   },\n   * });\n   * ```\n   */\n  readonly simulate: SimulateNamespace<IDL>;\n\n  /**\n   * A client for the program state. Similar to the base [[Program]] client,\n   * one can use this to send transactions and read accounts for the state\n   * abstraction.\n   */\n  readonly state?: StateClient<IDL>;\n\n  /**\n   * Address of the program.\n   */\n  public get programId(): PublicKey {\n    return this._programId;\n  }\n  private _programId: PublicKey;\n\n  /**\n   * IDL defining the program's interface.\n   */\n  public get idl(): IDL {\n    return this._idl;\n  }\n  private _idl: IDL;\n\n  /**\n   * Coder for serializing requests.\n   */\n  public get coder(): Coder {\n    return this._coder;\n  }\n  private _coder: Coder;\n\n  /**\n   * Wallet and network provider.\n   */\n  public get provider(): Provider {\n    return this._provider;\n  }\n  private _provider: Provider;\n\n  /**\n   * Handles event subscriptions.\n   */\n  private _events: EventManager;\n\n  /**\n   * @param idl       The interface definition.\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context to use. If not provided\n   *                  then uses [[getProvider]].\n   */\n  public constructor(idl: IDL, programId: Address, provider?: Provider) {\n    programId = translateAddress(programId);\n\n    if (!provider) {\n      provider = getProvider();\n    }\n\n    // Fields.\n    this._idl = idl;\n    this._provider = provider;\n    this._programId = programId;\n    this._coder = new Coder(idl);\n    this._events = new EventManager(this._programId, provider, this._coder);\n\n    // Dynamic namespaces.\n    const [\n      rpc,\n      instruction,\n      transaction,\n      account,\n      simulate,\n      state,\n    ] = NamespaceFactory.build(idl, this._coder, programId, provider);\n    this.rpc = rpc;\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.account = account;\n    this.simulate = simulate;\n    this.state = state;\n  }\n\n  /**\n   * Generates a Program client by fetching the IDL from the network.\n   *\n   * In order to use this method, an IDL must have been previously initialized\n   * via the anchor CLI's `anchor idl init` command.\n   *\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context.\n   */\n  public static async at<IDL extends Idl = Idl>(\n    address: Address,\n    provider?: Provider\n  ): Promise<Program<IDL>> {\n    const programId = translateAddress(address);\n\n    const idl = await Program.fetchIdl<IDL>(programId, provider);\n    if (!idl) {\n      throw new Error(`IDL not found for program: ${address.toString()}`);\n    }\n\n    return new Program(idl, programId, provider);\n  }\n\n  /**\n   * Fetches an idl from the blockchain.\n   *\n   * In order to use this method, an IDL must have been previously initialized\n   * via the anchor CLI's `anchor idl init` command.\n   *\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context.\n   */\n  public static async fetchIdl<IDL extends Idl = Idl>(\n    address: Address,\n    provider?: Provider\n  ): Promise<IDL | null> {\n    provider = provider ?? getProvider();\n    const programId = translateAddress(address);\n\n    const idlAddr = await idlAddress(programId);\n    const accountInfo = await provider.connection.getAccountInfo(idlAddr);\n    if (!accountInfo) {\n      return null;\n    }\n    // Chop off account discriminator.\n    let idlAccount = decodeIdlAccount(accountInfo.data.slice(8));\n    const inflatedIdl = inflate(idlAccount.data);\n    return JSON.parse(utf8.decode(inflatedIdl));\n  }\n\n  /**\n   * Invokes the given callback every time the given event is emitted.\n   *\n   * @param eventName The PascalCase name of the event, provided by the IDL.\n   * @param callback  The function to invoke whenever the event is emitted from\n   *                  program logs.\n   */\n  public addEventListener(\n    eventName: string,\n    callback: (event: any, slot: number) => void\n  ): number {\n    return this._events.addEventListener(eventName, callback);\n  }\n\n  /**\n   * Unsubscribes from the given eventName.\n   */\n  public async removeEventListener(listener: number): Promise<void> {\n    return await this._events.removeEventListener(listener);\n  }\n}\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,MAAM;AAG9B,SAAcC,UAAU,EAAEC,gBAAgB,QAAQ,QAAQ;AAC1D,OAAOC,KAAK,MAAM,UAAU;AAC5B,OAAOC,gBAON,MAAM,aAAa;AACpB,SAASC,WAAW,QAAQ,KAAK;AACjC,SAASC,IAAI,QAAQ,gBAAgB;AACrC,SAASC,YAAY,QAAQ,SAAS;AACtC,SAAkBC,gBAAgB,QAAQ,UAAU;AAEpD,cAAc,UAAU;AACxB,cAAc,WAAW;AACzB,cAAc,SAAS;AACvB,cAAc,aAAa;AAE3B;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,OAAM,MAAOC,OAAO;EAqMlB;;;;;;EAMAC,YAAmBC,GAAQ,EAAEC,SAAkB,EAAEC,QAAmB;IAClED,SAAS,GAAGJ,gBAAgB,CAACI,SAAS,CAAC;IAEvC,IAAI,CAACC,QAAQ,EAAE;MACbA,QAAQ,GAAGR,WAAW,EAAE;;IAG1B;IACA,IAAI,CAACS,IAAI,GAAGH,GAAG;IACf,IAAI,CAACI,SAAS,GAAGF,QAAQ;IACzB,IAAI,CAACG,UAAU,GAAGJ,SAAS;IAC3B,IAAI,CAACK,MAAM,GAAG,IAAId,KAAK,CAACQ,GAAG,CAAC;IAC5B,IAAI,CAACO,OAAO,GAAG,IAAIX,YAAY,CAAC,IAAI,CAACS,UAAU,EAAEH,QAAQ,EAAE,IAAI,CAACI,MAAM,CAAC;IAEvE;IACA,MAAM,CACJE,GAAG,EACHC,WAAW,EACXC,WAAW,EACXC,OAAO,EACPC,QAAQ,EACRC,KAAK,CACN,GAAGpB,gBAAgB,CAACqB,KAAK,CAACd,GAAG,EAAE,IAAI,CAACM,MAAM,EAAEL,SAAS,EAAEC,QAAQ,CAAC;IACjE,IAAI,CAACM,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,KAAK,GAAGA,KAAK;EACpB;EAxEA;;;EAGA,IAAWZ,SAASA,CAAA;IAClB,OAAO,IAAI,CAACI,UAAU;EACxB;EAGA;;;EAGA,IAAWL,GAAGA,CAAA;IACZ,OAAO,IAAI,CAACG,IAAI;EAClB;EAGA;;;EAGA,IAAWY,KAAKA,CAAA;IACd,OAAO,IAAI,CAACT,MAAM;EACpB;EAGA;;;EAGA,IAAWJ,QAAQA,CAAA;IACjB,OAAO,IAAI,CAACE,SAAS;EACvB;EA6CA;;;;;;;;;EASO,aAAaY,EAAEA,CACpBC,OAAgB,EAChBf,QAAmB;IAEnB,MAAMD,SAAS,GAAGJ,gBAAgB,CAACoB,OAAO,CAAC;IAE3C,MAAMjB,GAAG,GAAG,MAAMF,OAAO,CAACoB,QAAQ,CAAMjB,SAAS,EAAEC,QAAQ,CAAC;IAC5D,IAAI,CAACF,GAAG,EAAE;MACR,MAAM,IAAImB,KAAK,CAAC,8BAA8BF,OAAO,CAACG,QAAQ,EAAE,EAAE,CAAC;;IAGrE,OAAO,IAAItB,OAAO,CAACE,GAAG,EAAEC,SAAS,EAAEC,QAAQ,CAAC;EAC9C;EAEA;;;;;;;;;EASO,aAAagB,QAAQA,CAC1BD,OAAgB,EAChBf,QAAmB;IAEnBA,QAAQ,GAAGA,QAAQ,aAARA,QAAQ,cAARA,QAAQ,GAAIR,WAAW,EAAE;IACpC,MAAMO,SAAS,GAAGJ,gBAAgB,CAACoB,OAAO,CAAC;IAE3C,MAAMI,OAAO,GAAG,MAAM/B,UAAU,CAACW,SAAS,CAAC;IAC3C,MAAMqB,WAAW,GAAG,MAAMpB,QAAQ,CAACqB,UAAU,CAACC,cAAc,CAACH,OAAO,CAAC;IACrE,IAAI,CAACC,WAAW,EAAE;MAChB,OAAO,IAAI;;IAEb;IACA,IAAIG,UAAU,GAAGlC,gBAAgB,CAAC+B,WAAW,CAACI,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC;IAC5D,MAAMC,WAAW,GAAGvC,OAAO,CAACoC,UAAU,CAACC,IAAI,CAAC;IAC5C,OAAOG,IAAI,CAACC,KAAK,CAACnC,IAAI,CAACoC,MAAM,CAACH,WAAW,CAAC,CAAC;EAC7C;EAEA;;;;;;;EAOOI,gBAAgBA,CACrBC,SAAiB,EACjBC,QAA4C;IAE5C,OAAO,IAAI,CAAC3B,OAAO,CAACyB,gBAAgB,CAACC,SAAS,EAAEC,QAAQ,CAAC;EAC3D;EAEA;;;EAGO,MAAMC,mBAAmBA,CAACC,QAAgB;IAC/C,OAAO,MAAM,IAAI,CAAC7B,OAAO,CAAC4B,mBAAmB,CAACC,QAAQ,CAAC;EACzD"},"metadata":{},"sourceType":"module","externalDependencies":[]}