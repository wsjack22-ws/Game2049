{"ast":null,"code":"import { Connection, Keypair, sendAndConfirmRawTransaction } from \"@solana/web3.js\";\nimport { isBrowser } from \"./utils/common\";\n/**\n * The network and wallet context used to send transactions paid for and signed\n * by the provider.\n */\nexport default class Provider {\n  /**\n   * @param connection The cluster connection where the program is deployed.\n   * @param wallet     The wallet used to pay for and sign all transactions.\n   * @param opts       Transaction confirmation options to use by default.\n   */\n  constructor(connection, wallet, opts) {\n    this.connection = connection;\n    this.wallet = wallet;\n    this.opts = opts;\n  }\n  static defaultOptions() {\n    return {\n      preflightCommitment: \"recent\",\n      commitment: \"recent\"\n    };\n  }\n  /**\n   * Returns a `Provider` with a wallet read from the local filesystem.\n   *\n   * @param url  The network cluster url.\n   * @param opts The default transaction confirmation options.\n   *\n   * (This api is for Node only.)\n   */\n  static local(url, opts) {\n    opts = opts !== null && opts !== void 0 ? opts : Provider.defaultOptions();\n    const connection = new Connection(url !== null && url !== void 0 ? url : \"http://localhost:8899\", opts.preflightCommitment);\n    const wallet = NodeWallet.local();\n    return new Provider(connection, wallet, opts);\n  }\n  /**\n   * Returns a `Provider` read from the `ANCHOR_PROVIDER_URL` environment\n   * variable\n   *\n   * (This api is for Node only.)\n   */\n  static env() {\n    if (isBrowser) {\n      throw new Error(`Provider env is not available on browser.`);\n    }\n    const process = require(\"process\");\n    const url = process.env.ANCHOR_PROVIDER_URL;\n    if (url === undefined) {\n      throw new Error(\"ANCHOR_PROVIDER_URL is not defined\");\n    }\n    const options = Provider.defaultOptions();\n    const connection = new Connection(url, options.commitment);\n    const wallet = NodeWallet.local();\n    return new Provider(connection, wallet, options);\n  }\n  /**\n   * Sends the given transaction, paid for and signed by the provider's wallet.\n   *\n   * @param tx      The transaction to send.\n   * @param signers The set of signers in addition to the provider wallet that\n   *                will sign the transaction.\n   * @param opts    Transaction confirmation options.\n   */\n  async send(tx, signers, opts) {\n    if (signers === undefined) {\n      signers = [];\n    }\n    if (opts === undefined) {\n      opts = this.opts;\n    }\n    tx.feePayer = this.wallet.publicKey;\n    tx.recentBlockhash = (await this.connection.getRecentBlockhash(opts.preflightCommitment)).blockhash;\n    await this.wallet.signTransaction(tx);\n    signers.filter(s => s !== undefined).forEach(kp => {\n      tx.partialSign(kp);\n    });\n    const rawTx = tx.serialize();\n    const txId = await sendAndConfirmRawTransaction(this.connection, rawTx, opts);\n    return txId;\n  }\n  /**\n   * Similar to `send`, but for an array of transactions and signers.\n   */\n  async sendAll(reqs, opts) {\n    if (opts === undefined) {\n      opts = this.opts;\n    }\n    const blockhash = await this.connection.getRecentBlockhash(opts.preflightCommitment);\n    let txs = reqs.map(r => {\n      let tx = r.tx;\n      let signers = r.signers;\n      if (signers === undefined) {\n        signers = [];\n      }\n      tx.feePayer = this.wallet.publicKey;\n      tx.recentBlockhash = blockhash.blockhash;\n      signers.filter(s => s !== undefined).forEach(kp => {\n        tx.partialSign(kp);\n      });\n      return tx;\n    });\n    const signedTxs = await this.wallet.signAllTransactions(txs);\n    const sigs = [];\n    for (let k = 0; k < txs.length; k += 1) {\n      const tx = signedTxs[k];\n      const rawTx = tx.serialize();\n      sigs.push(await sendAndConfirmRawTransaction(this.connection, rawTx, opts));\n    }\n    return sigs;\n  }\n  /**\n   * Simulates the given transaction, returning emitted logs from execution.\n   *\n   * @param tx      The transaction to send.\n   * @param signers The set of signers in addition to the provdier wallet that\n   *                will sign the transaction.\n   * @param opts    Transaction confirmation options.\n   */\n  async simulate(tx, signers, opts = this.opts) {\n    var _a, _b, _c;\n    if (signers === undefined) {\n      signers = [];\n    }\n    tx.feePayer = this.wallet.publicKey;\n    tx.recentBlockhash = (await this.connection.getRecentBlockhash((_a = opts.preflightCommitment) !== null && _a !== void 0 ? _a : this.opts.preflightCommitment)).blockhash;\n    await this.wallet.signTransaction(tx);\n    signers.filter(s => s !== undefined).forEach(kp => {\n      tx.partialSign(kp);\n    });\n    return await simulateTransaction(this.connection, tx, (_c = (_b = opts.commitment) !== null && _b !== void 0 ? _b : this.opts.commitment) !== null && _c !== void 0 ? _c : \"recent\");\n  }\n}\n/**\n * Node only wallet.\n */\nexport class NodeWallet {\n  constructor(payer) {\n    this.payer = payer;\n  }\n  static local() {\n    const process = require(\"process\");\n    const payer = Keypair.fromSecretKey(Buffer.from(JSON.parse(require(\"fs\").readFileSync(process.env.ANCHOR_WALLET, {\n      encoding: \"utf-8\"\n    }))));\n    return new NodeWallet(payer);\n  }\n  async signTransaction(tx) {\n    tx.partialSign(this.payer);\n    return tx;\n  }\n  async signAllTransactions(txs) {\n    return txs.map(t => {\n      t.partialSign(this.payer);\n      return t;\n    });\n  }\n  get publicKey() {\n    return this.payer.publicKey;\n  }\n}\n// Copy of Connection.simulateTransaction that takes a commitment parameter.\nasync function simulateTransaction(connection, transaction, commitment) {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n  // @ts-ignore\n  connection._disableBlockhashCaching);\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString(\"base64\");\n  const config = {\n    encoding: \"base64\",\n    commitment\n  };\n  const args = [encodedTransaction, config];\n  // @ts-ignore\n  const res = await connection._rpcRequest(\"simulateTransaction\", args);\n  if (res.error) {\n    throw new Error(\"failed to simulate transaction: \" + res.error.message);\n  }\n  return res.result;\n}\n/**\n * Sets the default provider on the client.\n */\nexport function setProvider(provider) {\n  _provider = provider;\n}\n/**\n * Returns the default provider being used by the client.\n */\nexport function getProvider() {\n  if (_provider === null) {\n    return Provider.local();\n  }\n  return _provider;\n}\n// Global provider used as the default when a provider is not given.\nlet _provider = null;","map":{"version":3,"names":["Connection","Keypair","sendAndConfirmRawTransaction","isBrowser","Provider","constructor","connection","wallet","opts","defaultOptions","preflightCommitment","commitment","local","url","NodeWallet","env","Error","process","require","ANCHOR_PROVIDER_URL","undefined","options","send","tx","signers","feePayer","publicKey","recentBlockhash","getRecentBlockhash","blockhash","signTransaction","filter","s","forEach","kp","partialSign","rawTx","serialize","txId","sendAll","reqs","txs","map","r","signedTxs","signAllTransactions","sigs","k","length","push","simulate","_a","simulateTransaction","_c","_b","payer","fromSecretKey","Buffer","from","JSON","parse","readFileSync","ANCHOR_WALLET","encoding","t","transaction","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","config","args","res","_rpcRequest","error","message","result","setProvider","provider","_provider","getProvider"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/provider.ts"],"sourcesContent":["import {\n  Connection,\n  Keypair,\n  Signer,\n  PublicKey,\n  Transaction,\n  TransactionSignature,\n  ConfirmOptions,\n  sendAndConfirmRawTransaction,\n  RpcResponseAndContext,\n  SimulatedTransactionResponse,\n  Commitment,\n} from \"@solana/web3.js\";\nimport { isBrowser } from \"./utils/common\";\n\n/**\n * The network and wallet context used to send transactions paid for and signed\n * by the provider.\n */\nexport default class Provider {\n  /**\n   * @param connection The cluster connection where the program is deployed.\n   * @param wallet     The wallet used to pay for and sign all transactions.\n   * @param opts       Transaction confirmation options to use by default.\n   */\n  constructor(\n    readonly connection: Connection,\n    readonly wallet: Wallet,\n    readonly opts: ConfirmOptions\n  ) {}\n\n  static defaultOptions(): ConfirmOptions {\n    return {\n      preflightCommitment: \"recent\",\n      commitment: \"recent\",\n    };\n  }\n\n  /**\n   * Returns a `Provider` with a wallet read from the local filesystem.\n   *\n   * @param url  The network cluster url.\n   * @param opts The default transaction confirmation options.\n   *\n   * (This api is for Node only.)\n   */\n  static local(url?: string, opts?: ConfirmOptions): Provider {\n    opts = opts ?? Provider.defaultOptions();\n    const connection = new Connection(\n      url ?? \"http://localhost:8899\",\n      opts.preflightCommitment\n    );\n    const wallet = NodeWallet.local();\n    return new Provider(connection, wallet, opts);\n  }\n\n  /**\n   * Returns a `Provider` read from the `ANCHOR_PROVIDER_URL` environment\n   * variable\n   *\n   * (This api is for Node only.)\n   */\n  static env(): Provider {\n    if (isBrowser) {\n      throw new Error(`Provider env is not available on browser.`);\n    }\n\n    const process = require(\"process\");\n    const url = process.env.ANCHOR_PROVIDER_URL;\n    if (url === undefined) {\n      throw new Error(\"ANCHOR_PROVIDER_URL is not defined\");\n    }\n    const options = Provider.defaultOptions();\n    const connection = new Connection(url, options.commitment);\n    const wallet = NodeWallet.local();\n\n    return new Provider(connection, wallet, options);\n  }\n\n  /**\n   * Sends the given transaction, paid for and signed by the provider's wallet.\n   *\n   * @param tx      The transaction to send.\n   * @param signers The set of signers in addition to the provider wallet that\n   *                will sign the transaction.\n   * @param opts    Transaction confirmation options.\n   */\n  async send(\n    tx: Transaction,\n    signers?: Array<Signer | undefined>,\n    opts?: ConfirmOptions\n  ): Promise<TransactionSignature> {\n    if (signers === undefined) {\n      signers = [];\n    }\n    if (opts === undefined) {\n      opts = this.opts;\n    }\n\n    tx.feePayer = this.wallet.publicKey;\n    tx.recentBlockhash = (\n      await this.connection.getRecentBlockhash(opts.preflightCommitment)\n    ).blockhash;\n\n    await this.wallet.signTransaction(tx);\n    signers\n      .filter((s): s is Signer => s !== undefined)\n      .forEach((kp) => {\n        tx.partialSign(kp);\n      });\n\n    const rawTx = tx.serialize();\n\n    const txId = await sendAndConfirmRawTransaction(\n      this.connection,\n      rawTx,\n      opts\n    );\n\n    return txId;\n  }\n\n  /**\n   * Similar to `send`, but for an array of transactions and signers.\n   */\n  async sendAll(\n    reqs: Array<SendTxRequest>,\n    opts?: ConfirmOptions\n  ): Promise<Array<TransactionSignature>> {\n    if (opts === undefined) {\n      opts = this.opts;\n    }\n    const blockhash = await this.connection.getRecentBlockhash(\n      opts.preflightCommitment\n    );\n\n    let txs = reqs.map((r) => {\n      let tx = r.tx;\n      let signers = r.signers;\n\n      if (signers === undefined) {\n        signers = [];\n      }\n\n      tx.feePayer = this.wallet.publicKey;\n      tx.recentBlockhash = blockhash.blockhash;\n\n      signers\n        .filter((s): s is Signer => s !== undefined)\n        .forEach((kp) => {\n          tx.partialSign(kp);\n        });\n\n      return tx;\n    });\n\n    const signedTxs = await this.wallet.signAllTransactions(txs);\n\n    const sigs: TransactionSignature[] = [];\n\n    for (let k = 0; k < txs.length; k += 1) {\n      const tx = signedTxs[k];\n      const rawTx = tx.serialize();\n      sigs.push(\n        await sendAndConfirmRawTransaction(this.connection, rawTx, opts)\n      );\n    }\n\n    return sigs;\n  }\n\n  /**\n   * Simulates the given transaction, returning emitted logs from execution.\n   *\n   * @param tx      The transaction to send.\n   * @param signers The set of signers in addition to the provdier wallet that\n   *                will sign the transaction.\n   * @param opts    Transaction confirmation options.\n   */\n  async simulate(\n    tx: Transaction,\n    signers?: Array<Signer | undefined>,\n    opts: ConfirmOptions = this.opts\n  ): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n    if (signers === undefined) {\n      signers = [];\n    }\n\n    tx.feePayer = this.wallet.publicKey;\n    tx.recentBlockhash = (\n      await this.connection.getRecentBlockhash(\n        opts.preflightCommitment ?? this.opts.preflightCommitment\n      )\n    ).blockhash;\n\n    await this.wallet.signTransaction(tx);\n    signers\n      .filter((s): s is Signer => s !== undefined)\n      .forEach((kp) => {\n        tx.partialSign(kp);\n      });\n\n    return await simulateTransaction(\n      this.connection,\n      tx,\n      opts.commitment ?? this.opts.commitment ?? \"recent\"\n    );\n  }\n}\n\nexport type SendTxRequest = {\n  tx: Transaction;\n  signers: Array<Signer | undefined>;\n};\n\n/**\n * Wallet interface for objects that can be used to sign provider transactions.\n */\nexport interface Wallet {\n  signTransaction(tx: Transaction): Promise<Transaction>;\n  signAllTransactions(txs: Transaction[]): Promise<Transaction[]>;\n  publicKey: PublicKey;\n}\n\n/**\n * Node only wallet.\n */\nexport class NodeWallet implements Wallet {\n  constructor(readonly payer: Keypair) {}\n\n  static local(): NodeWallet {\n    const process = require(\"process\");\n    const payer = Keypair.fromSecretKey(\n      Buffer.from(\n        JSON.parse(\n          require(\"fs\").readFileSync(process.env.ANCHOR_WALLET, {\n            encoding: \"utf-8\",\n          })\n        )\n      )\n    );\n    return new NodeWallet(payer);\n  }\n\n  async signTransaction(tx: Transaction): Promise<Transaction> {\n    tx.partialSign(this.payer);\n    return tx;\n  }\n\n  async signAllTransactions(txs: Transaction[]): Promise<Transaction[]> {\n    return txs.map((t) => {\n      t.partialSign(this.payer);\n      return t;\n    });\n  }\n\n  get publicKey(): PublicKey {\n    return this.payer.publicKey;\n  }\n}\n\n// Copy of Connection.simulateTransaction that takes a commitment parameter.\nasync function simulateTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  commitment: Commitment\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString(\"base64\");\n  const config: any = { encoding: \"base64\", commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest(\"simulateTransaction\", args);\n  if (res.error) {\n    throw new Error(\"failed to simulate transaction: \" + res.error.message);\n  }\n  return res.result;\n}\n\n/**\n * Sets the default provider on the client.\n */\nexport function setProvider(provider: Provider) {\n  _provider = provider;\n}\n\n/**\n * Returns the default provider being used by the client.\n */\nexport function getProvider(): Provider {\n  if (_provider === null) {\n    return Provider.local();\n  }\n  return _provider;\n}\n\n// Global provider used as the default when a provider is not given.\nlet _provider: Provider | null = null;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}