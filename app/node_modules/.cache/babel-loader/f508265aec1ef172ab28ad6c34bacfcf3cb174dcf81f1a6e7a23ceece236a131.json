{"ast":null,"code":"\"use strict\";\n\nconst EC = require(\"elliptic\").ec;\nconst ec = new EC(\"secp256k1\");\nconst browserCrypto = global.crypto || global.msCrypto || {};\nconst subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\nconst nodeCrypto = require(\"crypto\");\nconst EC_GROUP_ORDER = Buffer.from(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", \"hex\");\nconst ZERO32 = Buffer.alloc(32, 0);\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\nfunction isScalar(x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\nfunction isValidPrivateKey(privateKey) {\n  if (!isScalar(privateKey)) {\n    return false;\n  }\n  return privateKey.compare(ZERO32) > 0 &&\n  // > 0\n  privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  let res = 0;\n  for (let i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n\n  return res === 0;\n}\n\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\nfunction randomBytes(size) {\n  const arr = new Uint8Array(size);\n  if (typeof browserCrypto.getRandomValues === \"undefined\") {\n    return Buffer.from(nodeCrypto.randomBytes(size));\n  } else {\n    browserCrypto.getRandomValues(arr);\n  }\n  return Buffer.from(arr);\n}\nasync function sha512(msg) {\n  if (subtle) {\n    const hash = await subtle.digest(\"SHA-512\", msg);\n    const result = new Uint8Array(hash);\n    return result;\n  }\n  const hash = nodeCrypto.createHash(\"sha512\");\n  const result = hash.update(msg).digest();\n  return new Uint8Array(result);\n}\nfunction getAes(op) {\n  return async function (iv, key, data) {\n    if (subtle) {\n      const importAlgorithm = {\n        name: \"AES-CBC\"\n      };\n      const cryptoKey = await subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n      const encAlgorithm = {\n        name: \"AES-CBC\",\n        iv: iv\n      };\n      const result = await subtle[op](encAlgorithm, cryptoKey, data);\n      return Buffer.from(new Uint8Array(result));\n    } else if (op === \"encrypt\") {\n      const cipher = nodeCrypto.createCipheriv(\"aes-256-cbc\", key, iv);\n      let firstChunk = cipher.update(data);\n      let secondChunk = cipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    } else if (op === \"decrypt\") {\n      const decipher = nodeCrypto.createDecipheriv(\"aes-256-cbc\", key, iv);\n      let firstChunk = decipher.update(data);\n      let secondChunk = decipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    }\n  };\n}\nconst aesCbcEncrypt = getAes(\"encrypt\");\nconst aesCbcDecrypt = getAes(\"decrypt\");\nasync function hmacSha256Sign(key, msg) {\n  if (subtle) {\n    const importAlgorithm = {\n      name: \"HMAC\",\n      hash: {\n        name: \"SHA-256\"\n      }\n    };\n    const cryptoKey = await subtle.importKey(\"raw\", new Uint8Array(key), importAlgorithm, false, [\"sign\", \"verify\"]);\n    const sig = await subtle.sign(\"HMAC\", cryptoKey, msg);\n    const result = Buffer.from(new Uint8Array(sig));\n    return result;\n  }\n  const hmac = nodeCrypto.createHmac(\"sha256\", Buffer.from(key));\n  hmac.update(msg);\n  const result = hmac.digest();\n  return result;\n}\nasync function hmacSha256Verify(key, msg, sig) {\n  const expectedSig = await hmacSha256Sign(key, msg);\n  return equalConstTime(expectedSig, sig);\n}\n\n/**\n * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n * depending on your browser.\n * @return {Buffer} A 32-byte private key.\n * @function\n */\nexports.generatePrivate = function () {\n  let privateKey = randomBytes(32);\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n  return privateKey;\n};\nconst getPublic = exports.getPublic = function (privateKey) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"arr\"));\n};\n\n/**\n * Get compressed version of public key.\n */\nexports.getPublicCompressed = function (privateKey) {\n  // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // See https://github.com/wanderer/secp256k1-node/issues/46\n  let compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"arr\"));\n};\n\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nexports.sign = async function (privateKey, msg) {\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  return Buffer.from(ec.sign(msg, privateKey, {\n    canonical: true\n  }).toDER());\n};\nexports.verify = async function (publicKey, msg, sig) {\n  assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n  if (publicKey.length === 65) {\n    assert(publicKey[0] === 4, \"Bad public key\");\n  }\n  if (publicKey.length === 33) {\n    assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n  }\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  if (ec.verify(msg, sig, publicKey)) {\n    return null;\n  } else {\n    throw new Error(\"Bad signature\");\n  }\n};\nconst deriveUnpadded = exports.derive = async function (privateKeyA, publicKeyB) {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toArray());\n};\nconst derivePadded = exports.derivePadded = async function (privateKeyA, publicKeyB) {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toString(16, 64), \"hex\");\n};\nexports.encrypt = async function (publicKeyTo, msg, opts) {\n  opts = opts || {};\n  // Tmp variables to save context from flat promises;\n  let iv, ephemPublicKey, ciphertext, macKey;\n  let ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  // There is a very unlikely possibility that it is not a valid key\n  while (!isValidPrivateKey(ephemPrivateKey)) {\n    ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  }\n  ephemPublicKey = getPublic(ephemPrivateKey);\n  const Px = await deriveUnpadded(ephemPrivateKey, publicKeyTo);\n  const hash = await sha512(Px);\n  iv = opts.iv || randomBytes(16);\n  const encryptionKey = hash.slice(0, 32);\n  macKey = hash.slice(32);\n  const data = await aesCbcEncrypt(iv, encryptionKey, msg);\n  ciphertext = data;\n  const dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n  const mac = await hmacSha256Sign(macKey, dataToMac);\n  return {\n    iv: iv,\n    ephemPublicKey: ephemPublicKey,\n    ciphertext: ciphertext,\n    mac: mac\n  };\n};\nconst decrypt = async function (privateKey, opts) {\n  let padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // Tmp variable to save context from flat promises;\n  let encryptionKey;\n  const derive = padding ? derivePadded : deriveUnpadded;\n  const Px = await derive(privateKey, opts.ephemPublicKey);\n  const hash = await sha512(Px);\n  encryptionKey = hash.slice(0, 32);\n  const macKey = hash.slice(32);\n  const dataToMac = Buffer.concat([opts.iv, opts.ephemPublicKey, opts.ciphertext]);\n  const macGood = await hmacSha256Verify(macKey, dataToMac, opts.mac);\n  if (!macGood && padding === false) {\n    return decrypt(privateKey, opts, true);\n  } else if (!macGood && padding === true) {\n    throw new Error(\"bad MAC after trying padded\");\n  }\n  const msg = await aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);\n  return Buffer.from(new Uint8Array(msg));\n};\nexports.decrypt = decrypt;","map":{"version":3,"names":["EC","require","ec","browserCrypto","global","crypto","msCrypto","subtle","webkitSubtle","nodeCrypto","EC_GROUP_ORDER","Buffer","from","ZERO32","alloc","assert","condition","message","Error","isScalar","x","isBuffer","length","isValidPrivateKey","privateKey","compare","equalConstTime","b1","b2","res","i","randomBytes","size","arr","Uint8Array","getRandomValues","sha512","msg","hash","digest","result","createHash","update","getAes","op","iv","key","data","importAlgorithm","name","cryptoKey","importKey","encAlgorithm","cipher","createCipheriv","firstChunk","secondChunk","final","concat","decipher","createDecipheriv","aesCbcEncrypt","aesCbcDecrypt","hmacSha256Sign","sig","sign","hmac","createHmac","hmacSha256Verify","expectedSig","exports","generatePrivate","getPublic","keyFromPrivate","getPublicCompressed","compressed","canonical","toDER","verify","publicKey","deriveUnpadded","derive","privateKeyA","publicKeyB","keyA","keyB","keyFromPublic","Px","toArray","derivePadded","toString","encrypt","publicKeyTo","opts","ephemPublicKey","ciphertext","macKey","ephemPrivateKey","encryptionKey","slice","dataToMac","mac","decrypt","padding","arguments","undefined","macGood"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@toruslabs/eccrypto/dist/browser.js"],"sourcesContent":["\"use strict\";\n\nconst EC = require(\"elliptic\").ec;\nconst ec = new EC(\"secp256k1\");\nconst browserCrypto = global.crypto || global.msCrypto || {};\nconst subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\nconst nodeCrypto = require(\"crypto\");\nconst EC_GROUP_ORDER = Buffer.from(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", \"hex\");\nconst ZERO32 = Buffer.alloc(32, 0);\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\nfunction isScalar(x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\nfunction isValidPrivateKey(privateKey) {\n  if (!isScalar(privateKey)) {\n    return false;\n  }\n  return privateKey.compare(ZERO32) > 0 &&\n  // > 0\n  privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  let res = 0;\n  for (let i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n\n  return res === 0;\n}\n\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\nfunction randomBytes(size) {\n  const arr = new Uint8Array(size);\n  if (typeof browserCrypto.getRandomValues === \"undefined\") {\n    return Buffer.from(nodeCrypto.randomBytes(size));\n  } else {\n    browserCrypto.getRandomValues(arr);\n  }\n  return Buffer.from(arr);\n}\nasync function sha512(msg) {\n  if (subtle) {\n    const hash = await subtle.digest(\"SHA-512\", msg);\n    const result = new Uint8Array(hash);\n    return result;\n  }\n  const hash = nodeCrypto.createHash(\"sha512\");\n  const result = hash.update(msg).digest();\n  return new Uint8Array(result);\n}\nfunction getAes(op) {\n  return async function (iv, key, data) {\n    if (subtle) {\n      const importAlgorithm = {\n        name: \"AES-CBC\"\n      };\n      const cryptoKey = await subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n      const encAlgorithm = {\n        name: \"AES-CBC\",\n        iv: iv\n      };\n      const result = await subtle[op](encAlgorithm, cryptoKey, data);\n      return Buffer.from(new Uint8Array(result));\n    } else if (op === \"encrypt\") {\n      const cipher = nodeCrypto.createCipheriv(\"aes-256-cbc\", key, iv);\n      let firstChunk = cipher.update(data);\n      let secondChunk = cipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    } else if (op === \"decrypt\") {\n      const decipher = nodeCrypto.createDecipheriv(\"aes-256-cbc\", key, iv);\n      let firstChunk = decipher.update(data);\n      let secondChunk = decipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    }\n  };\n}\nconst aesCbcEncrypt = getAes(\"encrypt\");\nconst aesCbcDecrypt = getAes(\"decrypt\");\nasync function hmacSha256Sign(key, msg) {\n  if (subtle) {\n    const importAlgorithm = {\n      name: \"HMAC\",\n      hash: {\n        name: \"SHA-256\"\n      }\n    };\n    const cryptoKey = await subtle.importKey(\"raw\", new Uint8Array(key), importAlgorithm, false, [\"sign\", \"verify\"]);\n    const sig = await subtle.sign(\"HMAC\", cryptoKey, msg);\n    const result = Buffer.from(new Uint8Array(sig));\n    return result;\n  }\n  const hmac = nodeCrypto.createHmac(\"sha256\", Buffer.from(key));\n  hmac.update(msg);\n  const result = hmac.digest();\n  return result;\n}\nasync function hmacSha256Verify(key, msg, sig) {\n  const expectedSig = await hmacSha256Sign(key, msg);\n  return equalConstTime(expectedSig, sig);\n}\n\n/**\n * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n * depending on your browser.\n * @return {Buffer} A 32-byte private key.\n * @function\n */\nexports.generatePrivate = function () {\n  let privateKey = randomBytes(32);\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n  return privateKey;\n};\nconst getPublic = exports.getPublic = function (privateKey) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"arr\"));\n};\n\n/**\n * Get compressed version of public key.\n */\nexports.getPublicCompressed = function (privateKey) {\n  // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // See https://github.com/wanderer/secp256k1-node/issues/46\n  let compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"arr\"));\n};\n\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nexports.sign = async function (privateKey, msg) {\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  return Buffer.from(ec.sign(msg, privateKey, {\n    canonical: true\n  }).toDER());\n};\nexports.verify = async function (publicKey, msg, sig) {\n  assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n  if (publicKey.length === 65) {\n    assert(publicKey[0] === 4, \"Bad public key\");\n  }\n  if (publicKey.length === 33) {\n    assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n  }\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  if (ec.verify(msg, sig, publicKey)) {\n    return null;\n  } else {\n    throw new Error(\"Bad signature\");\n  }\n};\nconst deriveUnpadded = exports.derive = async function (privateKeyA, publicKeyB) {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toArray());\n};\nconst derivePadded = exports.derivePadded = async function (privateKeyA, publicKeyB) {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toString(16, 64), \"hex\");\n};\nexports.encrypt = async function (publicKeyTo, msg, opts) {\n  opts = opts || {};\n  // Tmp variables to save context from flat promises;\n  let iv, ephemPublicKey, ciphertext, macKey;\n  let ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  // There is a very unlikely possibility that it is not a valid key\n  while (!isValidPrivateKey(ephemPrivateKey)) {\n    ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  }\n  ephemPublicKey = getPublic(ephemPrivateKey);\n  const Px = await deriveUnpadded(ephemPrivateKey, publicKeyTo);\n  const hash = await sha512(Px);\n  iv = opts.iv || randomBytes(16);\n  const encryptionKey = hash.slice(0, 32);\n  macKey = hash.slice(32);\n  const data = await aesCbcEncrypt(iv, encryptionKey, msg);\n  ciphertext = data;\n  const dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n  const mac = await hmacSha256Sign(macKey, dataToMac);\n  return {\n    iv: iv,\n    ephemPublicKey: ephemPublicKey,\n    ciphertext: ciphertext,\n    mac: mac\n  };\n};\nconst decrypt = async function (privateKey, opts) {\n  let padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // Tmp variable to save context from flat promises;\n  let encryptionKey;\n  const derive = padding ? derivePadded : deriveUnpadded;\n  const Px = await derive(privateKey, opts.ephemPublicKey);\n  const hash = await sha512(Px);\n  encryptionKey = hash.slice(0, 32);\n  const macKey = hash.slice(32);\n  const dataToMac = Buffer.concat([opts.iv, opts.ephemPublicKey, opts.ciphertext]);\n  const macGood = await hmacSha256Verify(macKey, dataToMac, opts.mac);\n  if (!macGood && padding === false) {\n    return decrypt(privateKey, opts, true);\n  } else if (!macGood && padding === true) {\n    throw new Error(\"bad MAC after trying padded\");\n  }\n  const msg = await aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);\n  return Buffer.from(new Uint8Array(msg));\n};\nexports.decrypt = decrypt;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}