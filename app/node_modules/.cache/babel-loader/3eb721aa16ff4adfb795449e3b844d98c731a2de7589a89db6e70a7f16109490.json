{"ast":null,"code":"/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n;\n\n'use strict';\nconst {\n  ArrayIsArray,\n  Promise,\n  SymbolAsyncIterator\n} = require('../../ours/primordials');\nconst eos = require('./end-of-stream');\nconst {\n  once\n} = require('../../ours/util');\nconst destroyImpl = require('./destroy');\nconst Duplex = require('./duplex');\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_RETURN_VALUE,\n    ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED,\n    ERR_STREAM_PREMATURE_CLOSE\n  },\n  AbortError\n} = require('../../ours/errors');\nconst {\n  validateFunction,\n  validateAbortSignal\n} = require('../validators');\nconst {\n  isIterable,\n  isReadable,\n  isReadableNodeStream,\n  isNodeStream,\n  isTransformStream,\n  isWebStream,\n  isReadableStream,\n  isReadableEnded\n} = require('./utils');\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController;\nlet PassThrough;\nlet Readable;\nfunction destroyer(stream, reading, writing) {\n  let finished = false;\n  stream.on('close', () => {\n    finished = true;\n  });\n  const cleanup = eos(stream, {\n    readable: reading,\n    writable: writing\n  }, err => {\n    finished = !err;\n  });\n  return {\n    destroy: err => {\n      if (finished) return;\n      finished = true;\n      destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED('pipe'));\n    },\n    cleanup\n  };\n}\nfunction popCallback(streams) {\n  // Streams should never be an empty array. It should always contain at least\n  // a single stream. Therefore optimize for the average case instead of\n  // checking for length === 0 as well.\n  validateFunction(streams[streams.length - 1], 'streams[stream.length - 1]');\n  return streams.pop();\n}\nfunction makeAsyncIterable(val) {\n  if (isIterable(val)) {\n    return val;\n  } else if (isReadableNodeStream(val)) {\n    // Legacy streams are not Iterable.\n    return fromReadable(val);\n  }\n  throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], val);\n}\nasync function* fromReadable(val) {\n  if (!Readable) {\n    Readable = require('./readable');\n  }\n  yield* Readable.prototype[SymbolAsyncIterator].call(val);\n}\nasync function pumpToNode(iterable, writable, finish, {\n  end\n}) {\n  let error;\n  let onresolve = null;\n  const resume = err => {\n    if (err) {\n      error = err;\n    }\n    if (onresolve) {\n      const callback = onresolve;\n      onresolve = null;\n      callback();\n    }\n  };\n  const wait = () => new Promise((resolve, reject) => {\n    if (error) {\n      reject(error);\n    } else {\n      onresolve = () => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      };\n    }\n  });\n  writable.on('drain', resume);\n  const cleanup = eos(writable, {\n    readable: false\n  }, resume);\n  try {\n    if (writable.writableNeedDrain) {\n      await wait();\n    }\n    for await (const chunk of iterable) {\n      if (!writable.write(chunk)) {\n        await wait();\n      }\n    }\n    if (end) {\n      writable.end();\n    }\n    await wait();\n    finish();\n  } catch (err) {\n    finish(error !== err ? aggregateTwoErrors(error, err) : err);\n  } finally {\n    cleanup();\n    writable.off('drain', resume);\n  }\n}\nasync function pumpToWeb(readable, writable, finish, {\n  end\n}) {\n  if (isTransformStream(writable)) {\n    writable = writable.writable;\n  }\n  // https://streams.spec.whatwg.org/#example-manual-write-with-backpressure\n  const writer = writable.getWriter();\n  try {\n    for await (const chunk of readable) {\n      await writer.ready;\n      writer.write(chunk).catch(() => {});\n    }\n    await writer.ready;\n    if (end) {\n      await writer.close();\n    }\n    finish();\n  } catch (err) {\n    try {\n      await writer.abort(err);\n      finish(err);\n    } catch (err) {\n      finish(err);\n    }\n  }\n}\nfunction pipeline(...streams) {\n  return pipelineImpl(streams, once(popCallback(streams)));\n}\nfunction pipelineImpl(streams, callback, opts) {\n  if (streams.length === 1 && ArrayIsArray(streams[0])) {\n    streams = streams[0];\n  }\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n  const ac = new AbortController();\n  const signal = ac.signal;\n  const outerSignal = opts === null || opts === undefined ? undefined : opts.signal;\n\n  // Need to cleanup event listeners if last stream is readable\n  // https://github.com/nodejs/node/issues/35452\n  const lastStreamCleanup = [];\n  validateAbortSignal(outerSignal, 'options.signal');\n  function abort() {\n    finishImpl(new AbortError());\n  }\n  outerSignal === null || outerSignal === undefined ? undefined : outerSignal.addEventListener('abort', abort);\n  let error;\n  let value;\n  const destroys = [];\n  let finishCount = 0;\n  function finish(err) {\n    finishImpl(err, --finishCount === 0);\n  }\n  function finishImpl(err, final) {\n    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {\n      error = err;\n    }\n    if (!error && !final) {\n      return;\n    }\n    while (destroys.length) {\n      destroys.shift()(error);\n    }\n    outerSignal === null || outerSignal === undefined ? undefined : outerSignal.removeEventListener('abort', abort);\n    ac.abort();\n    if (final) {\n      if (!error) {\n        lastStreamCleanup.forEach(fn => fn());\n      }\n      process.nextTick(callback, error, value);\n    }\n  }\n  let ret;\n  for (let i = 0; i < streams.length; i++) {\n    const stream = streams[i];\n    const reading = i < streams.length - 1;\n    const writing = i > 0;\n    const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false;\n    const isLastStream = i === streams.length - 1;\n    if (isNodeStream(stream)) {\n      if (end) {\n        const {\n          destroy,\n          cleanup\n        } = destroyer(stream, reading, writing);\n        destroys.push(destroy);\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup);\n        }\n      }\n\n      // Catch stream errors that occur after pipe/pump has completed.\n      function onError(err) {\n        if (err && err.name !== 'AbortError' && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n          finish(err);\n        }\n      }\n      stream.on('error', onError);\n      if (isReadable(stream) && isLastStream) {\n        lastStreamCleanup.push(() => {\n          stream.removeListener('error', onError);\n        });\n      }\n    }\n    if (i === 0) {\n      if (typeof stream === 'function') {\n        ret = stream({\n          signal\n        });\n        if (!isIterable(ret)) {\n          throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or Stream', 'source', ret);\n        }\n      } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {\n        ret = stream;\n      } else {\n        ret = Duplex.from(stream);\n      }\n    } else if (typeof stream === 'function') {\n      if (isTransformStream(ret)) {\n        var _ret;\n        ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable);\n      } else {\n        ret = makeAsyncIterable(ret);\n      }\n      ret = stream(ret, {\n        signal\n      });\n      if (reading) {\n        if (!isIterable(ret, true)) {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable', `transform[${i - 1}]`, ret);\n        }\n      } else {\n        var _ret2;\n        if (!PassThrough) {\n          PassThrough = require('./passthrough');\n        }\n\n        // If the last argument to pipeline is not a stream\n        // we must create a proxy stream so that pipeline(...)\n        // always returns a stream which can be further\n        // composed through `.pipe(stream)`.\n\n        const pt = new PassThrough({\n          objectMode: true\n        });\n\n        // Handle Promises/A+ spec, `then` could be a getter that throws on\n        // second use.\n        const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then;\n        if (typeof then === 'function') {\n          finishCount++;\n          then.call(ret, val => {\n            value = val;\n            if (val != null) {\n              pt.write(val);\n            }\n            if (end) {\n              pt.end();\n            }\n            process.nextTick(finish);\n          }, err => {\n            pt.destroy(err);\n            process.nextTick(finish, err);\n          });\n        } else if (isIterable(ret, true)) {\n          finishCount++;\n          pumpToNode(ret, pt, finish, {\n            end\n          });\n        } else if (isReadableStream(ret) || isTransformStream(ret)) {\n          const toRead = ret.readable || ret;\n          finishCount++;\n          pumpToNode(toRead, pt, finish, {\n            end\n          });\n        } else {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable or Promise', 'destination', ret);\n        }\n        ret = pt;\n        const {\n          destroy,\n          cleanup\n        } = destroyer(ret, false, true);\n        destroys.push(destroy);\n        if (isLastStream) {\n          lastStreamCleanup.push(cleanup);\n        }\n      }\n    } else if (isNodeStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount += 2;\n        const cleanup = pipe(ret, stream, finish, {\n          end\n        });\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup);\n        }\n      } else if (isTransformStream(ret) || isReadableStream(ret)) {\n        const toRead = ret.readable || ret;\n        finishCount++;\n        pumpToNode(toRead, stream, finish, {\n          end\n        });\n      } else if (isIterable(ret)) {\n        finishCount++;\n        pumpToNode(ret, stream, finish, {\n          end\n        });\n      } else {\n        throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'], ret);\n      }\n      ret = stream;\n    } else if (isWebStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount++;\n        pumpToWeb(makeAsyncIterable(ret), stream, finish, {\n          end\n        });\n      } else if (isReadableStream(ret) || isIterable(ret)) {\n        finishCount++;\n        pumpToWeb(ret, stream, finish, {\n          end\n        });\n      } else if (isTransformStream(ret)) {\n        finishCount++;\n        pumpToWeb(ret.readable, stream, finish, {\n          end\n        });\n      } else {\n        throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'], ret);\n      }\n      ret = stream;\n    } else {\n      ret = Duplex.from(stream);\n    }\n  }\n  if (signal !== null && signal !== undefined && signal.aborted || outerSignal !== null && outerSignal !== undefined && outerSignal.aborted) {\n    process.nextTick(abort);\n  }\n  return ret;\n}\nfunction pipe(src, dst, finish, {\n  end\n}) {\n  let ended = false;\n  dst.on('close', () => {\n    if (!ended) {\n      // Finish if the destination closes before the source has completed.\n      finish(new ERR_STREAM_PREMATURE_CLOSE());\n    }\n  });\n  src.pipe(dst, {\n    end: false\n  }); // If end is true we already will have a listener to end dst.\n\n  if (end) {\n    // Compat. Before node v10.12.0 stdio used to throw an error so\n    // pipe() did/does not end() stdio destinations.\n    // Now they allow it but \"secretly\" don't close the underlying fd.\n\n    function endFn() {\n      ended = true;\n      dst.end();\n    }\n    if (isReadableEnded(src)) {\n      // End the destination if the source has already ended.\n      process.nextTick(endFn);\n    } else {\n      src.once('end', endFn);\n    }\n  } else {\n    finish();\n  }\n  eos(src, {\n    readable: true,\n    writable: false\n  }, err => {\n    const rState = src._readableState;\n    if (err && err.code === 'ERR_STREAM_PREMATURE_CLOSE' && rState && rState.ended && !rState.errored && !rState.errorEmitted) {\n      // Some readable streams will emit 'close' before 'end'. However, since\n      // this is on the readable side 'end' should still be emitted if the\n      // stream has been ended and no error emitted. This should be allowed in\n      // favor of backwards compatibility. Since the stream is piped to a\n      // destination this should not result in any observable difference.\n      // We don't need to check if this is a writable premature close since\n      // eos will only fail with premature close on the reading side for\n      // duplex streams.\n      src.once('end', finish).once('error', finish);\n    } else {\n      finish(err);\n    }\n  });\n  return eos(dst, {\n    readable: false,\n    writable: true\n  }, finish);\n}\nmodule.exports = {\n  pipelineImpl,\n  pipeline\n};","map":{"version":3,"names":["process","require","ArrayIsArray","Promise","SymbolAsyncIterator","eos","once","destroyImpl","Duplex","aggregateTwoErrors","codes","ERR_INVALID_ARG_TYPE","ERR_INVALID_RETURN_VALUE","ERR_MISSING_ARGS","ERR_STREAM_DESTROYED","ERR_STREAM_PREMATURE_CLOSE","AbortError","validateFunction","validateAbortSignal","isIterable","isReadable","isReadableNodeStream","isNodeStream","isTransformStream","isWebStream","isReadableStream","isReadableEnded","AbortController","globalThis","PassThrough","Readable","destroyer","stream","reading","writing","finished","on","cleanup","readable","writable","err","destroy","popCallback","streams","length","pop","makeAsyncIterable","val","fromReadable","prototype","call","pumpToNode","iterable","finish","end","error","onresolve","resume","callback","wait","resolve","reject","writableNeedDrain","chunk","write","off","pumpToWeb","writer","getWriter","ready","catch","close","abort","pipeline","pipelineImpl","opts","ac","signal","outerSignal","undefined","lastStreamCleanup","finishImpl","addEventListener","value","destroys","finishCount","final","code","shift","removeEventListener","forEach","fn","nextTick","ret","i","isLastStream","push","onError","name","removeListener","from","_ret","_ret2","pt","objectMode","then","toRead","pipe","aborted","src","dst","ended","endFn","rState","_readableState","errored","errorEmitted","module","exports"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@toruslabs/base-controllers/node_modules/readable-stream/lib/internal/streams/pipeline.js"],"sourcesContent":["/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n;('use strict')\nconst { ArrayIsArray, Promise, SymbolAsyncIterator } = require('../../ours/primordials')\nconst eos = require('./end-of-stream')\nconst { once } = require('../../ours/util')\nconst destroyImpl = require('./destroy')\nconst Duplex = require('./duplex')\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_RETURN_VALUE,\n    ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED,\n    ERR_STREAM_PREMATURE_CLOSE\n  },\n  AbortError\n} = require('../../ours/errors')\nconst { validateFunction, validateAbortSignal } = require('../validators')\nconst {\n  isIterable,\n  isReadable,\n  isReadableNodeStream,\n  isNodeStream,\n  isTransformStream,\n  isWebStream,\n  isReadableStream,\n  isReadableEnded\n} = require('./utils')\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController\nlet PassThrough\nlet Readable\nfunction destroyer(stream, reading, writing) {\n  let finished = false\n  stream.on('close', () => {\n    finished = true\n  })\n  const cleanup = eos(\n    stream,\n    {\n      readable: reading,\n      writable: writing\n    },\n    (err) => {\n      finished = !err\n    }\n  )\n  return {\n    destroy: (err) => {\n      if (finished) return\n      finished = true\n      destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED('pipe'))\n    },\n    cleanup\n  }\n}\nfunction popCallback(streams) {\n  // Streams should never be an empty array. It should always contain at least\n  // a single stream. Therefore optimize for the average case instead of\n  // checking for length === 0 as well.\n  validateFunction(streams[streams.length - 1], 'streams[stream.length - 1]')\n  return streams.pop()\n}\nfunction makeAsyncIterable(val) {\n  if (isIterable(val)) {\n    return val\n  } else if (isReadableNodeStream(val)) {\n    // Legacy streams are not Iterable.\n    return fromReadable(val)\n  }\n  throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], val)\n}\nasync function* fromReadable(val) {\n  if (!Readable) {\n    Readable = require('./readable')\n  }\n  yield* Readable.prototype[SymbolAsyncIterator].call(val)\n}\nasync function pumpToNode(iterable, writable, finish, { end }) {\n  let error\n  let onresolve = null\n  const resume = (err) => {\n    if (err) {\n      error = err\n    }\n    if (onresolve) {\n      const callback = onresolve\n      onresolve = null\n      callback()\n    }\n  }\n  const wait = () =>\n    new Promise((resolve, reject) => {\n      if (error) {\n        reject(error)\n      } else {\n        onresolve = () => {\n          if (error) {\n            reject(error)\n          } else {\n            resolve()\n          }\n        }\n      }\n    })\n  writable.on('drain', resume)\n  const cleanup = eos(\n    writable,\n    {\n      readable: false\n    },\n    resume\n  )\n  try {\n    if (writable.writableNeedDrain) {\n      await wait()\n    }\n    for await (const chunk of iterable) {\n      if (!writable.write(chunk)) {\n        await wait()\n      }\n    }\n    if (end) {\n      writable.end()\n    }\n    await wait()\n    finish()\n  } catch (err) {\n    finish(error !== err ? aggregateTwoErrors(error, err) : err)\n  } finally {\n    cleanup()\n    writable.off('drain', resume)\n  }\n}\nasync function pumpToWeb(readable, writable, finish, { end }) {\n  if (isTransformStream(writable)) {\n    writable = writable.writable\n  }\n  // https://streams.spec.whatwg.org/#example-manual-write-with-backpressure\n  const writer = writable.getWriter()\n  try {\n    for await (const chunk of readable) {\n      await writer.ready\n      writer.write(chunk).catch(() => {})\n    }\n    await writer.ready\n    if (end) {\n      await writer.close()\n    }\n    finish()\n  } catch (err) {\n    try {\n      await writer.abort(err)\n      finish(err)\n    } catch (err) {\n      finish(err)\n    }\n  }\n}\nfunction pipeline(...streams) {\n  return pipelineImpl(streams, once(popCallback(streams)))\n}\nfunction pipelineImpl(streams, callback, opts) {\n  if (streams.length === 1 && ArrayIsArray(streams[0])) {\n    streams = streams[0]\n  }\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams')\n  }\n  const ac = new AbortController()\n  const signal = ac.signal\n  const outerSignal = opts === null || opts === undefined ? undefined : opts.signal\n\n  // Need to cleanup event listeners if last stream is readable\n  // https://github.com/nodejs/node/issues/35452\n  const lastStreamCleanup = []\n  validateAbortSignal(outerSignal, 'options.signal')\n  function abort() {\n    finishImpl(new AbortError())\n  }\n  outerSignal === null || outerSignal === undefined ? undefined : outerSignal.addEventListener('abort', abort)\n  let error\n  let value\n  const destroys = []\n  let finishCount = 0\n  function finish(err) {\n    finishImpl(err, --finishCount === 0)\n  }\n  function finishImpl(err, final) {\n    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {\n      error = err\n    }\n    if (!error && !final) {\n      return\n    }\n    while (destroys.length) {\n      destroys.shift()(error)\n    }\n    outerSignal === null || outerSignal === undefined ? undefined : outerSignal.removeEventListener('abort', abort)\n    ac.abort()\n    if (final) {\n      if (!error) {\n        lastStreamCleanup.forEach((fn) => fn())\n      }\n      process.nextTick(callback, error, value)\n    }\n  }\n  let ret\n  for (let i = 0; i < streams.length; i++) {\n    const stream = streams[i]\n    const reading = i < streams.length - 1\n    const writing = i > 0\n    const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false\n    const isLastStream = i === streams.length - 1\n    if (isNodeStream(stream)) {\n      if (end) {\n        const { destroy, cleanup } = destroyer(stream, reading, writing)\n        destroys.push(destroy)\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      }\n\n      // Catch stream errors that occur after pipe/pump has completed.\n      function onError(err) {\n        if (err && err.name !== 'AbortError' && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n          finish(err)\n        }\n      }\n      stream.on('error', onError)\n      if (isReadable(stream) && isLastStream) {\n        lastStreamCleanup.push(() => {\n          stream.removeListener('error', onError)\n        })\n      }\n    }\n    if (i === 0) {\n      if (typeof stream === 'function') {\n        ret = stream({\n          signal\n        })\n        if (!isIterable(ret)) {\n          throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or Stream', 'source', ret)\n        }\n      } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {\n        ret = stream\n      } else {\n        ret = Duplex.from(stream)\n      }\n    } else if (typeof stream === 'function') {\n      if (isTransformStream(ret)) {\n        var _ret\n        ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable)\n      } else {\n        ret = makeAsyncIterable(ret)\n      }\n      ret = stream(ret, {\n        signal\n      })\n      if (reading) {\n        if (!isIterable(ret, true)) {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable', `transform[${i - 1}]`, ret)\n        }\n      } else {\n        var _ret2\n        if (!PassThrough) {\n          PassThrough = require('./passthrough')\n        }\n\n        // If the last argument to pipeline is not a stream\n        // we must create a proxy stream so that pipeline(...)\n        // always returns a stream which can be further\n        // composed through `.pipe(stream)`.\n\n        const pt = new PassThrough({\n          objectMode: true\n        })\n\n        // Handle Promises/A+ spec, `then` could be a getter that throws on\n        // second use.\n        const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then\n        if (typeof then === 'function') {\n          finishCount++\n          then.call(\n            ret,\n            (val) => {\n              value = val\n              if (val != null) {\n                pt.write(val)\n              }\n              if (end) {\n                pt.end()\n              }\n              process.nextTick(finish)\n            },\n            (err) => {\n              pt.destroy(err)\n              process.nextTick(finish, err)\n            }\n          )\n        } else if (isIterable(ret, true)) {\n          finishCount++\n          pumpToNode(ret, pt, finish, {\n            end\n          })\n        } else if (isReadableStream(ret) || isTransformStream(ret)) {\n          const toRead = ret.readable || ret\n          finishCount++\n          pumpToNode(toRead, pt, finish, {\n            end\n          })\n        } else {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable or Promise', 'destination', ret)\n        }\n        ret = pt\n        const { destroy, cleanup } = destroyer(ret, false, true)\n        destroys.push(destroy)\n        if (isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      }\n    } else if (isNodeStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount += 2\n        const cleanup = pipe(ret, stream, finish, {\n          end\n        })\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      } else if (isTransformStream(ret) || isReadableStream(ret)) {\n        const toRead = ret.readable || ret\n        finishCount++\n        pumpToNode(toRead, stream, finish, {\n          end\n        })\n      } else if (isIterable(ret)) {\n        finishCount++\n        pumpToNode(ret, stream, finish, {\n          end\n        })\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\n          'val',\n          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],\n          ret\n        )\n      }\n      ret = stream\n    } else if (isWebStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount++\n        pumpToWeb(makeAsyncIterable(ret), stream, finish, {\n          end\n        })\n      } else if (isReadableStream(ret) || isIterable(ret)) {\n        finishCount++\n        pumpToWeb(ret, stream, finish, {\n          end\n        })\n      } else if (isTransformStream(ret)) {\n        finishCount++\n        pumpToWeb(ret.readable, stream, finish, {\n          end\n        })\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\n          'val',\n          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],\n          ret\n        )\n      }\n      ret = stream\n    } else {\n      ret = Duplex.from(stream)\n    }\n  }\n  if (\n    (signal !== null && signal !== undefined && signal.aborted) ||\n    (outerSignal !== null && outerSignal !== undefined && outerSignal.aborted)\n  ) {\n    process.nextTick(abort)\n  }\n  return ret\n}\nfunction pipe(src, dst, finish, { end }) {\n  let ended = false\n  dst.on('close', () => {\n    if (!ended) {\n      // Finish if the destination closes before the source has completed.\n      finish(new ERR_STREAM_PREMATURE_CLOSE())\n    }\n  })\n  src.pipe(dst, {\n    end: false\n  }) // If end is true we already will have a listener to end dst.\n\n  if (end) {\n    // Compat. Before node v10.12.0 stdio used to throw an error so\n    // pipe() did/does not end() stdio destinations.\n    // Now they allow it but \"secretly\" don't close the underlying fd.\n\n    function endFn() {\n      ended = true\n      dst.end()\n    }\n    if (isReadableEnded(src)) {\n      // End the destination if the source has already ended.\n      process.nextTick(endFn)\n    } else {\n      src.once('end', endFn)\n    }\n  } else {\n    finish()\n  }\n  eos(\n    src,\n    {\n      readable: true,\n      writable: false\n    },\n    (err) => {\n      const rState = src._readableState\n      if (\n        err &&\n        err.code === 'ERR_STREAM_PREMATURE_CLOSE' &&\n        rState &&\n        rState.ended &&\n        !rState.errored &&\n        !rState.errorEmitted\n      ) {\n        // Some readable streams will emit 'close' before 'end'. However, since\n        // this is on the readable side 'end' should still be emitted if the\n        // stream has been ended and no error emitted. This should be allowed in\n        // favor of backwards compatibility. Since the stream is piped to a\n        // destination this should not result in any observable difference.\n        // We don't need to check if this is a writable premature close since\n        // eos will only fail with premature close on the reading side for\n        // duplex streams.\n        src.once('end', finish).once('error', finish)\n      } else {\n        finish(err)\n      }\n    }\n  )\n  return eos(\n    dst,\n    {\n      readable: false,\n      writable: true\n    },\n    finish\n  )\n}\nmodule.exports = {\n  pipelineImpl,\n  pipeline\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}