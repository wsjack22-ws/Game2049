{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _regeneratorRuntime = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AccountStore = exports.AccountsResolver = void 0;\nvar camelcase_1 = __importDefault(require(\"camelcase\"));\nvar web3_js_1 = require(\"@solana/web3.js\");\nvar utf8 = __importStar(require(\"../utils/bytes/utf8.js\"));\nvar token_js_1 = require(\"../utils/token.js\");\nvar token_1 = require(\"../spl/token\");\n// Populates a given accounts context with PDAs and common missing accounts.\nvar AccountsResolver = /*#__PURE__*/function () {\n  function AccountsResolver(_args, _accounts, _provider, _programId, _idlIx, _accountNamespace) {\n    _classCallCheck(this, AccountsResolver);\n    this._args = _args;\n    this._accounts = _accounts;\n    this._provider = _provider;\n    this._programId = _programId;\n    this._idlIx = _idlIx;\n    this._accountStore = new AccountStore(_provider, _accountNamespace);\n  }\n  // Note: We serially resolve PDAs one by one rather than doing them\n  //       in parallel because there can be dependencies between\n  //       addresses. That is, one PDA can be used as a seed in another.\n  //\n  // TODO: PDAs need to be resolved in topological order. For now, we\n  //       require the developer to simply list the accounts in the\n  //       correct order. But in future work, we should create the\n  //       dependency graph and resolve automatically.\n  //\n  _createClass(AccountsResolver, [{\n    key: \"resolve\",\n    value: function () {\n      var _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var k, accountDesc, accountDescName;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              k = 0;\n            case 1:\n              if (!(k < this._idlIx.accounts.length)) {\n                _context.next = 17;\n                break;\n              }\n              // Cast is ok because only a non-nested IdlAccount can have a seeds\n              // cosntraint.\n              accountDesc = this._idlIx.accounts[k];\n              accountDescName = (0, camelcase_1.default)(accountDesc.name); // PDA derived from IDL seeds.\n              if (!(accountDesc.pda && accountDesc.pda.seeds.length > 0 && !this._accounts[accountDescName])) {\n                _context.next = 8;\n                break;\n              }\n              _context.next = 7;\n              return this.autoPopulatePda(accountDesc);\n            case 7:\n              return _context.abrupt(\"continue\", 14);\n            case 8:\n              if (!(accountDesc.isSigner && !this._accounts[accountDescName])) {\n                _context.next = 13;\n                break;\n              }\n              if (!(this._provider.wallet === undefined)) {\n                _context.next = 11;\n                break;\n              }\n              throw new Error(\"This function requires the Provider interface implementor to have a 'wallet' field.\");\n            case 11:\n              // @ts-expect-error\n              this._accounts[accountDescName] = this._provider.wallet.publicKey;\n              return _context.abrupt(\"continue\", 14);\n            case 13:\n              // Common accounts are auto populated with magic names by convention.\n              if (Reflect.has(AccountsResolver.CONST_ACCOUNTS, accountDescName) && !this._accounts[accountDescName]) {\n                this._accounts[accountDescName] = AccountsResolver.CONST_ACCOUNTS[accountDescName];\n              }\n            case 14:\n              k += 1;\n              _context.next = 1;\n              break;\n            case 17:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function resolve() {\n        return _resolve.apply(this, arguments);\n      }\n      return resolve;\n    }()\n  }, {\n    key: \"autoPopulatePda\",\n    value: function () {\n      var _autoPopulatePda = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(accountDesc) {\n        var _this = this;\n        var seeds, programId, _yield$web3_js_1$Publ, _yield$web3_js_1$Publ2, pubkey;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(!accountDesc.pda || !accountDesc.pda.seeds)) {\n                _context2.next = 2;\n                break;\n              }\n              throw new Error(\"Must have seeds\");\n            case 2:\n              _context2.next = 4;\n              return Promise.all(accountDesc.pda.seeds.map(function (seedDesc) {\n                return _this.toBuffer(seedDesc);\n              }));\n            case 4:\n              seeds = _context2.sent;\n              _context2.next = 7;\n              return this.parseProgramId(accountDesc);\n            case 7:\n              programId = _context2.sent;\n              _context2.next = 10;\n              return web3_js_1.PublicKey.findProgramAddress(seeds, programId);\n            case 10:\n              _yield$web3_js_1$Publ = _context2.sent;\n              _yield$web3_js_1$Publ2 = _slicedToArray(_yield$web3_js_1$Publ, 1);\n              pubkey = _yield$web3_js_1$Publ2[0];\n              this._accounts[(0, camelcase_1.default)(accountDesc.name)] = pubkey;\n            case 14:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function autoPopulatePda(_x) {\n        return _autoPopulatePda.apply(this, arguments);\n      }\n      return autoPopulatePda;\n    }()\n  }, {\n    key: \"parseProgramId\",\n    value: function () {\n      var _parseProgramId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(accountDesc) {\n        var _a;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if ((_a = accountDesc.pda) === null || _a === void 0 ? void 0 : _a.programId) {\n                _context3.next = 2;\n                break;\n              }\n              return _context3.abrupt(\"return\", this._programId);\n            case 2:\n              _context3.t0 = accountDesc.pda.programId.kind;\n              _context3.next = _context3.t0 === \"const\" ? 5 : _context3.t0 === \"arg\" ? 6 : _context3.t0 === \"account\" ? 7 : 10;\n              break;\n            case 5:\n              return _context3.abrupt(\"return\", new web3_js_1.PublicKey(this.toBufferConst(accountDesc.pda.programId.value)));\n            case 6:\n              return _context3.abrupt(\"return\", this.argValue(accountDesc.pda.programId));\n            case 7:\n              _context3.next = 9;\n              return this.accountValue(accountDesc.pda.programId);\n            case 9:\n              return _context3.abrupt(\"return\", _context3.sent);\n            case 10:\n              throw new Error(\"Unexpected program seed kind: \".concat(accountDesc.pda.programId.kind));\n            case 11:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function parseProgramId(_x2) {\n        return _parseProgramId.apply(this, arguments);\n      }\n      return parseProgramId;\n    }()\n  }, {\n    key: \"toBuffer\",\n    value: function () {\n      var _toBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(seedDesc) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.t0 = seedDesc.kind;\n              _context4.next = _context4.t0 === \"const\" ? 3 : _context4.t0 === \"arg\" ? 4 : _context4.t0 === \"account\" ? 7 : 10;\n              break;\n            case 3:\n              return _context4.abrupt(\"return\", this.toBufferConst(seedDesc));\n            case 4:\n              _context4.next = 6;\n              return this.toBufferArg(seedDesc);\n            case 6:\n              return _context4.abrupt(\"return\", _context4.sent);\n            case 7:\n              _context4.next = 9;\n              return this.toBufferAccount(seedDesc);\n            case 9:\n              return _context4.abrupt(\"return\", _context4.sent);\n            case 10:\n              throw new Error(\"Unexpected seed kind: \".concat(seedDesc.kind));\n            case 11:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function toBuffer(_x3) {\n        return _toBuffer.apply(this, arguments);\n      }\n      return toBuffer;\n    }()\n  }, {\n    key: \"toBufferConst\",\n    value: function toBufferConst(seedDesc) {\n      return this.toBufferValue(seedDesc.type, seedDesc.value);\n    }\n  }, {\n    key: \"toBufferArg\",\n    value: function () {\n      var _toBufferArg = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(seedDesc) {\n        var argValue;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              argValue = this.argValue(seedDesc);\n              return _context5.abrupt(\"return\", this.toBufferValue(seedDesc.type, argValue));\n            case 2:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function toBufferArg(_x4) {\n        return _toBufferArg.apply(this, arguments);\n      }\n      return toBufferArg;\n    }()\n  }, {\n    key: \"argValue\",\n    value: function argValue(seedDesc) {\n      var seedArgName = (0, camelcase_1.default)(seedDesc.path.split(\".\")[0]);\n      var idlArgPosition = this._idlIx.args.findIndex(function (argDesc) {\n        return argDesc.name === seedArgName;\n      });\n      if (idlArgPosition === -1) {\n        throw new Error(\"Unable to find argument for seed: \".concat(seedArgName));\n      }\n      return this._args[idlArgPosition];\n    }\n  }, {\n    key: \"toBufferAccount\",\n    value: function () {\n      var _toBufferAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(seedDesc) {\n        var accountValue;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return this.accountValue(seedDesc);\n            case 2:\n              accountValue = _context6.sent;\n              return _context6.abrupt(\"return\", this.toBufferValue(seedDesc.type, accountValue));\n            case 4:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function toBufferAccount(_x5) {\n        return _toBufferAccount.apply(this, arguments);\n      }\n      return toBufferAccount;\n    }()\n  }, {\n    key: \"accountValue\",\n    value: function () {\n      var _accountValue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(seedDesc) {\n        var pathComponents, fieldName, fieldPubkey, account, fieldValue;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              pathComponents = seedDesc.path.split(\".\");\n              fieldName = pathComponents[0];\n              fieldPubkey = this._accounts[(0, camelcase_1.default)(fieldName)]; // The seed is a pubkey of the account.\n              if (!(pathComponents.length === 1)) {\n                _context7.next = 5;\n                break;\n              }\n              return _context7.abrupt(\"return\", fieldPubkey);\n            case 5:\n              _context7.next = 7;\n              return this._accountStore.fetchAccount(seedDesc.account, fieldPubkey);\n            case 7:\n              account = _context7.sent;\n              // Dereference all fields in the path to get the field value\n              // used in the seed.\n              fieldValue = this.parseAccountValue(account, pathComponents.slice(1));\n              return _context7.abrupt(\"return\", fieldValue);\n            case 10:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function accountValue(_x6) {\n        return _accountValue.apply(this, arguments);\n      }\n      return accountValue;\n    }()\n  }, {\n    key: \"parseAccountValue\",\n    value: function parseAccountValue(account, path) {\n      var accountField;\n      while (path.length > 0) {\n        accountField = account[(0, camelcase_1.default)(path[0])];\n        path = path.slice(1);\n      }\n      return accountField;\n    }\n    // Converts the given idl valaue into a Buffer. The values here must be\n    // primitives. E.g. no structs.\n    //\n    // TODO: add more types here as needed.\n  }, {\n    key: \"toBufferValue\",\n    value: function toBufferValue(type, value) {\n      switch (type) {\n        case \"u8\":\n          return Buffer.from([value]);\n        case \"u16\":\n          var b = Buffer.alloc(2);\n          b.writeUInt16LE(value);\n          return b;\n        case \"u32\":\n          var buf = Buffer.alloc(4);\n          buf.writeUInt32LE(value);\n          return buf;\n        case \"u64\":\n          var bU64 = Buffer.alloc(8);\n          bU64.writeBigUInt64LE(BigInt(value));\n          return bU64;\n        case \"string\":\n          return Buffer.from(utf8.encode(value));\n        case \"publicKey\":\n          return value.toBuffer();\n        default:\n          if (type.array) {\n            return Buffer.from(value);\n          }\n          throw new Error(\"Unexpected seed type: \".concat(type));\n      }\n    }\n  }]);\n  return AccountsResolver;\n}();\nexports.AccountsResolver = AccountsResolver;\nAccountsResolver.CONST_ACCOUNTS = {\n  systemProgram: web3_js_1.SystemProgram.programId,\n  tokenProgram: token_js_1.TOKEN_PROGRAM_ID,\n  associatedTokenProgram: token_js_1.ASSOCIATED_PROGRAM_ID,\n  rent: web3_js_1.SYSVAR_RENT_PUBKEY\n};\n// TODO: this should be configureable to avoid unnecessary requests.\nvar AccountStore = /*#__PURE__*/function () {\n  // todo: don't use the progrma use the account namespace.\n  function AccountStore(_provider, _accounts) {\n    _classCallCheck(this, AccountStore);\n    this._provider = _provider;\n    this._accounts = _accounts;\n    this._cache = new Map();\n  }\n  _createClass(AccountStore, [{\n    key: \"fetchAccount\",\n    value: function () {\n      var _fetchAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(name, publicKey) {\n        var address, accountInfo, data, account;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              address = publicKey.toString();\n              if (this._cache.has(address)) {\n                _context8.next = 14;\n                break;\n              }\n              if (!(name === \"TokenAccount\")) {\n                _context8.next = 12;\n                break;\n              }\n              _context8.next = 5;\n              return this._provider.connection.getAccountInfo(publicKey);\n            case 5:\n              accountInfo = _context8.sent;\n              if (!(accountInfo === null)) {\n                _context8.next = 8;\n                break;\n              }\n              throw new Error(\"invalid account info for \".concat(address));\n            case 8:\n              data = (0, token_1.coder)().accounts.decode(\"token\", accountInfo.data);\n              this._cache.set(address, data);\n              _context8.next = 14;\n              break;\n            case 12:\n              account = this._accounts[(0, camelcase_1.default)(name)].fetch(publicKey);\n              this._cache.set(address, account);\n            case 14:\n              return _context8.abrupt(\"return\", this._cache.get(address));\n            case 15:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n      function fetchAccount(_x7, _x8) {\n        return _fetchAccount.apply(this, arguments);\n      }\n      return fetchAccount;\n    }()\n  }]);\n  return AccountStore;\n}();\nexports.AccountStore = AccountStore;","map":{"version":3,"names":["camelcase_1","__importDefault","require","web3_js_1","utf8","__importStar","token_js_1","token_1","AccountsResolver","_args","_accounts","_provider","_programId","_idlIx","_accountNamespace","_classCallCheck","_accountStore","AccountStore","_createClass","key","value","_resolve","_asyncToGenerator","_regeneratorRuntime","mark","_callee","k","accountDesc","accountDescName","wrap","_callee$","_context","prev","next","accounts","length","default","name","pda","seeds","autoPopulatePda","abrupt","isSigner","wallet","undefined","Error","publicKey","Reflect","has","CONST_ACCOUNTS","stop","resolve","apply","arguments","_autoPopulatePda","_callee2","_this","programId","_yield$web3_js_1$Publ","_yield$web3_js_1$Publ2","pubkey","_callee2$","_context2","Promise","all","map","seedDesc","toBuffer","sent","parseProgramId","PublicKey","findProgramAddress","_slicedToArray","_x","_parseProgramId","_callee3","_a","_callee3$","_context3","t0","kind","toBufferConst","argValue","accountValue","concat","_x2","_toBuffer","_callee4","_callee4$","_context4","toBufferArg","toBufferAccount","_x3","toBufferValue","type","_toBufferArg","_callee5","_callee5$","_context5","_x4","seedArgName","path","split","idlArgPosition","args","findIndex","argDesc","_toBufferAccount","_callee6","_callee6$","_context6","_x5","_accountValue","_callee7","pathComponents","fieldName","fieldPubkey","account","fieldValue","_callee7$","_context7","fetchAccount","parseAccountValue","slice","_x6","accountField","Buffer","from","b","alloc","writeUInt16LE","buf","writeUInt32LE","bU64","writeBigUInt64LE","BigInt","encode","array","exports","systemProgram","SystemProgram","tokenProgram","TOKEN_PROGRAM_ID","associatedTokenProgram","ASSOCIATED_PROGRAM_ID","rent","SYSVAR_RENT_PUBKEY","_cache","Map","_fetchAccount","_callee8","address","accountInfo","data","_callee8$","_context8","toString","connection","getAccountInfo","coder","decode","set","fetch","get","_x7","_x8"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/program/accounts-resolver.ts"],"sourcesContent":["import camelCase from \"camelcase\";\nimport { PublicKey, SystemProgram, SYSVAR_RENT_PUBKEY } from \"@solana/web3.js\";\nimport { Idl, IdlSeed, IdlAccount } from \"../idl.js\";\nimport * as utf8 from \"../utils/bytes/utf8.js\";\nimport { TOKEN_PROGRAM_ID, ASSOCIATED_PROGRAM_ID } from \"../utils/token.js\";\nimport { AllInstructions } from \"./namespace/types.js\";\nimport Provider from \"../provider.js\";\nimport { AccountNamespace } from \"./namespace/account.js\";\nimport { coder } from \"../spl/token\";\n\n// Populates a given accounts context with PDAs and common missing accounts.\nexport class AccountsResolver<IDL extends Idl, I extends AllInstructions<IDL>> {\n  static readonly CONST_ACCOUNTS = {\n    systemProgram: SystemProgram.programId,\n    tokenProgram: TOKEN_PROGRAM_ID,\n    associatedTokenProgram: ASSOCIATED_PROGRAM_ID,\n    rent: SYSVAR_RENT_PUBKEY,\n  };\n\n  private _accountStore: AccountStore<IDL>;\n\n  constructor(\n    private _args: Array<any>,\n    private _accounts: { [name: string]: PublicKey },\n    private _provider: Provider,\n    private _programId: PublicKey,\n    private _idlIx: AllInstructions<IDL>,\n    _accountNamespace: AccountNamespace<IDL>\n  ) {\n    this._accountStore = new AccountStore(_provider, _accountNamespace);\n  }\n\n  // Note: We serially resolve PDAs one by one rather than doing them\n  //       in parallel because there can be dependencies between\n  //       addresses. That is, one PDA can be used as a seed in another.\n  //\n  // TODO: PDAs need to be resolved in topological order. For now, we\n  //       require the developer to simply list the accounts in the\n  //       correct order. But in future work, we should create the\n  //       dependency graph and resolve automatically.\n  //\n  public async resolve() {\n    for (let k = 0; k < this._idlIx.accounts.length; k += 1) {\n      // Cast is ok because only a non-nested IdlAccount can have a seeds\n      // cosntraint.\n      const accountDesc = this._idlIx.accounts[k] as IdlAccount;\n      const accountDescName = camelCase(accountDesc.name);\n\n      // PDA derived from IDL seeds.\n      if (\n        accountDesc.pda &&\n        accountDesc.pda.seeds.length > 0 &&\n        !this._accounts[accountDescName]\n      ) {\n        await this.autoPopulatePda(accountDesc);\n        continue;\n      }\n\n      // Signers default to the provider.\n      if (accountDesc.isSigner && !this._accounts[accountDescName]) {\n        // @ts-expect-error\n        if (this._provider.wallet === undefined) {\n          throw new Error(\n            \"This function requires the Provider interface implementor to have a 'wallet' field.\"\n          );\n        }\n        // @ts-expect-error\n        this._accounts[accountDescName] = this._provider.wallet.publicKey;\n        continue;\n      }\n\n      // Common accounts are auto populated with magic names by convention.\n      if (\n        Reflect.has(AccountsResolver.CONST_ACCOUNTS, accountDescName) &&\n        !this._accounts[accountDescName]\n      ) {\n        this._accounts[accountDescName] =\n          AccountsResolver.CONST_ACCOUNTS[accountDescName];\n      }\n    }\n  }\n\n  private async autoPopulatePda(accountDesc: IdlAccount) {\n    if (!accountDesc.pda || !accountDesc.pda.seeds)\n      throw new Error(\"Must have seeds\");\n\n    const seeds: Buffer[] = await Promise.all(\n      accountDesc.pda.seeds.map((seedDesc: IdlSeed) => this.toBuffer(seedDesc))\n    );\n\n    const programId = await this.parseProgramId(accountDesc);\n    const [pubkey] = await PublicKey.findProgramAddress(seeds, programId);\n\n    this._accounts[camelCase(accountDesc.name)] = pubkey;\n  }\n\n  private async parseProgramId(accountDesc: IdlAccount): Promise<PublicKey> {\n    if (!accountDesc.pda?.programId) {\n      return this._programId;\n    }\n    switch (accountDesc.pda.programId.kind) {\n      case \"const\":\n        return new PublicKey(\n          this.toBufferConst(accountDesc.pda.programId.value)\n        );\n      case \"arg\":\n        return this.argValue(accountDesc.pda.programId);\n      case \"account\":\n        return await this.accountValue(accountDesc.pda.programId);\n      default:\n        throw new Error(\n          `Unexpected program seed kind: ${accountDesc.pda.programId.kind}`\n        );\n    }\n  }\n\n  private async toBuffer(seedDesc: IdlSeed): Promise<Buffer> {\n    switch (seedDesc.kind) {\n      case \"const\":\n        return this.toBufferConst(seedDesc);\n      case \"arg\":\n        return await this.toBufferArg(seedDesc);\n      case \"account\":\n        return await this.toBufferAccount(seedDesc);\n      default:\n        throw new Error(`Unexpected seed kind: ${seedDesc.kind}`);\n    }\n  }\n\n  private toBufferConst(seedDesc: IdlSeed): Buffer {\n    return this.toBufferValue(seedDesc.type, seedDesc.value);\n  }\n\n  private async toBufferArg(seedDesc: IdlSeed): Promise<Buffer> {\n    const argValue = this.argValue(seedDesc);\n    return this.toBufferValue(seedDesc.type, argValue);\n  }\n\n  private argValue(seedDesc: IdlSeed): any {\n    const seedArgName = camelCase(seedDesc.path.split(\".\")[0]);\n\n    const idlArgPosition = this._idlIx.args.findIndex(\n      (argDesc: any) => argDesc.name === seedArgName\n    );\n    if (idlArgPosition === -1) {\n      throw new Error(`Unable to find argument for seed: ${seedArgName}`);\n    }\n\n    return this._args[idlArgPosition];\n  }\n\n  private async toBufferAccount(seedDesc: IdlSeed): Promise<Buffer> {\n    const accountValue = await this.accountValue(seedDesc);\n    return this.toBufferValue(seedDesc.type, accountValue);\n  }\n\n  private async accountValue(seedDesc: IdlSeed): Promise<any> {\n    const pathComponents = seedDesc.path.split(\".\");\n\n    const fieldName = pathComponents[0];\n    const fieldPubkey = this._accounts[camelCase(fieldName)];\n\n    // The seed is a pubkey of the account.\n    if (pathComponents.length === 1) {\n      return fieldPubkey;\n    }\n\n    // The key is account data.\n    //\n    // Fetch and deserialize it.\n    const account = await this._accountStore.fetchAccount(\n      seedDesc.account,\n      fieldPubkey\n    );\n\n    // Dereference all fields in the path to get the field value\n    // used in the seed.\n    const fieldValue = this.parseAccountValue(account, pathComponents.slice(1));\n    return fieldValue;\n  }\n\n  private parseAccountValue<T = any>(account: T, path: Array<string>): any {\n    let accountField: any;\n    while (path.length > 0) {\n      accountField = account[camelCase(path[0])];\n      path = path.slice(1);\n    }\n    return accountField;\n  }\n\n  // Converts the given idl valaue into a Buffer. The values here must be\n  // primitives. E.g. no structs.\n  //\n  // TODO: add more types here as needed.\n  private toBufferValue(type: string | any, value: any): Buffer {\n    switch (type) {\n      case \"u8\":\n        return Buffer.from([value]);\n      case \"u16\":\n        let b = Buffer.alloc(2);\n        b.writeUInt16LE(value);\n        return b;\n      case \"u32\":\n        let buf = Buffer.alloc(4);\n        buf.writeUInt32LE(value);\n        return buf;\n      case \"u64\":\n        let bU64 = Buffer.alloc(8);\n        bU64.writeBigUInt64LE(BigInt(value));\n        return bU64;\n      case \"string\":\n        return Buffer.from(utf8.encode(value));\n      case \"publicKey\":\n        return value.toBuffer();\n      default:\n        if (type.array) {\n          return Buffer.from(value);\n        }\n        throw new Error(`Unexpected seed type: ${type}`);\n    }\n  }\n}\n\n// TODO: this should be configureable to avoid unnecessary requests.\nexport class AccountStore<IDL extends Idl> {\n  private _cache = new Map<string, any>();\n\n  // todo: don't use the progrma use the account namespace.\n  constructor(\n    private _provider: Provider,\n    private _accounts: AccountNamespace<IDL>\n  ) {}\n\n  public async fetchAccount<T = any>(\n    name: string,\n    publicKey: PublicKey\n  ): Promise<T> {\n    const address = publicKey.toString();\n    if (!this._cache.has(address)) {\n      if (name === \"TokenAccount\") {\n        const accountInfo = await this._provider.connection.getAccountInfo(\n          publicKey\n        );\n        if (accountInfo === null) {\n          throw new Error(`invalid account info for ${address}`);\n        }\n        const data = coder().accounts.decode(\"token\", accountInfo.data);\n        this._cache.set(address, data);\n      } else {\n        const account = this._accounts[camelCase(name)].fetch(publicKey);\n        this._cache.set(address, account);\n      }\n    }\n    return this._cache.get(address);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}