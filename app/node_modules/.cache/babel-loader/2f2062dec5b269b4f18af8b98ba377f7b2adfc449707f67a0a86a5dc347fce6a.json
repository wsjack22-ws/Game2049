{"ast":null,"code":"const BASE64_ENCODINGS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst BASE64_LOOKUP = new Uint8Array(256);\nlet IGNORE_NODE = false;\nconst byteArrayProto = Object.getPrototypeOf(Uint8Array.prototype);\nconst byteLength = Object.getOwnPropertyDescriptor(byteArrayProto, 'byteLength').get;\nconst byteFill = byteArrayProto.fill;\nconst normalizeEncoding = function normalizeEncoding(enc) {\n  const encoding = `${enc}`.toLowerCase();\n  switch (encoding) {\n    case 'ascii':\n      return 'ascii';\n    case 'base64':\n      return 'base64';\n    case 'hex':\n      return 'hex';\n    case 'latin1':\n    case 'binary':\n      return 'latin1';\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n      return 'utf16le';\n    case 'utf8':\n    case 'utf-8':\n      return 'utf8';\n    default:\n      if (encoding === '') return 'utf8';\n  }\n};\nconst validateInt32 = function validateInt32(value, name, min = -2147483648, max = 2147483647) {\n  const OUT_OF_RANGE = `'${name}' must be >= ${min} && <= ${max}: ${value}`;\n  if (value !== (value | 0)) {\n    if (typeof value !== 'number') {\n      throw new Error(`'${name}' must be a number: ${value}`);\n    }\n    if (!Number.isInteger(value)) {\n      throw new Error(`'${name}' must be an integer: ${value}`);\n    }\n    throw new Error(OUT_OF_RANGE);\n  }\n  if (value < min || value > max) {\n    throw new Error(OUT_OF_RANGE);\n  }\n};\n/** Class extending Uint8Array to provide a partial implementation of NodeJS Buffer as a cross-platform shim. */\nexport class BufferShim extends Uint8Array {\n  /**\r\n   * @param {string|Buffer|BufferShim|ArrayBuffer|SharedArrayBuffer} input\r\n   * @param {BufferEncoding} [encoding='utf8']\r\n   */\n  constructor(input, encoding = 'utf8') {\n    encoding = normalizeEncoding(encoding);\n    let buffer;\n    if (BASE64_LOOKUP['B'.charCodeAt(0)] === 0) {\n      for (let i = 0; i < BASE64_ENCODINGS.length; i += 1) {\n        BASE64_LOOKUP[BASE64_ENCODINGS.charCodeAt(i)] = i;\n      }\n    }\n    if (typeof input === 'string' && encoding === 'utf8') {\n      buffer = BufferShim.toUTF8Array(input);\n    } else if (typeof input === 'string' && encoding === 'utf16le') {\n      buffer = BufferShim.toUTF16Array(input);\n    } else if (typeof input === 'string' && ['ascii', 'latin1'].includes(encoding)) {\n      buffer = BufferShim.toASCIIArrayOrBinaryArray(input);\n    } else if (typeof input === 'string' && encoding === 'hex') {\n      buffer = BufferShim.toHexArray(input);\n    } else if (typeof input === 'string' && encoding === 'base64') {\n      buffer = BufferShim.atob(input);\n    } else if (typeof input === 'string') {\n      throw new Error('Unsupported encoding ' + encoding);\n    } else if (BufferShim.isBuffer(input) || BufferShim.isBufferShim(input)) {\n      buffer = BufferShim.toArrayBuffer(input);\n    } else if (input instanceof ArrayBuffer || input instanceof SharedArrayBuffer) {\n      buffer = input;\n    } else {\n      throw new Error('The first argument must be one of type string, Buffer, ' + 'ArrayBuffer, Array, or Array-like Object. Received type ' + typeof input);\n    }\n    super(buffer);\n  }\n  static atob(input) {\n    if (BufferShim.isNodeEnv) return BufferShim.toArrayBuffer(Buffer.from(input, 'base64'));\n    const getByteLength = str => {\n      let bytes = str.length * 0.75;\n      if (str[str.length - 1] === '=') {\n        bytes--;\n        if (str[str.length - 2] === '=') {\n          bytes--;\n        }\n      }\n      return bytes;\n    };\n    input = input.replace(/[\\t\\n\\f\\r\\s]+/g, '');\n    const byteLength = getByteLength(input);\n    const buffer = new ArrayBuffer(byteLength);\n    const dataView = new Uint8Array(buffer);\n    let bytePos = 0;\n    for (let pos = 0; pos < input.length; pos += 4) {\n      const encoded1 = BASE64_LOOKUP[input.charCodeAt(pos)];\n      const encoded2 = BASE64_LOOKUP[input.charCodeAt(pos + 1)];\n      const encoded3 = BASE64_LOOKUP[input.charCodeAt(pos + 2)];\n      const encoded4 = BASE64_LOOKUP[input.charCodeAt(pos + 3)];\n      dataView[bytePos++] = encoded1 << 2 | encoded2 >> 4;\n      dataView[bytePos++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n      dataView[bytePos++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return buffer;\n  }\n  static btoa(buffer) {\n    if (BufferShim.isNodeEnv) return BufferShim.toNodeBuffer(buffer).toString('base64');\n    let base64 = '';\n    let bytes = new Uint8Array(buffer);\n    let byteLength = bytes.byteLength;\n    let byteRemainder = byteLength % 3;\n    let mainLength = byteLength - byteRemainder;\n    let a, b, c, d;\n    let chunk;\n    // Main loop deals with bytes in chunks of 3\n    for (let i = 0; i < mainLength; i = i + 3) {\n      // Combine the three bytes into a single integer\n      chunk = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];\n      // Use bitmasks to extract 6-bit segments from the triplet\n      a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\n      b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\n      c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\n      d = chunk & 63; // 63       = 2^6 - 1\n      // Convert the raw binary segments to the appropriate ASCII encoding\n      base64 += BASE64_ENCODINGS[a] + BASE64_ENCODINGS[b] + BASE64_ENCODINGS[c] + BASE64_ENCODINGS[d];\n    }\n    // Deal with the remaining bytes and padding\n    if (byteRemainder == 1) {\n      chunk = bytes[mainLength];\n      a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\n      // Set the 4 least significant bits to zero\n      b = (chunk & 3) << 4; // 3   = 2^2 - 1\n      base64 += BASE64_ENCODINGS[a] + BASE64_ENCODINGS[b] + '==';\n    } else if (byteRemainder == 2) {\n      chunk = bytes[mainLength] << 8 | bytes[mainLength + 1];\n      a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\n      b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\n      // Set the 2 least significant bits to zero\n      c = (chunk & 15) << 2; // 15    = 2^4 - 1\n      base64 += BASE64_ENCODINGS[a] + BASE64_ENCODINGS[b] + BASE64_ENCODINGS[c] + '=';\n    }\n    return base64;\n  }\n  static fromUTF8ArrayOrASCIIArray(buffer) {\n    if (BufferShim.isNodeEnv) return BufferShim.toNodeBuffer(buffer).toString('utf8');\n    const bytes = new Uint8Array(buffer);\n    const out = [];\n    let pos = 0;\n    while (pos < bytes.length) {\n      let c1 = bytes[pos++];\n      if (c1 < 128) {\n        out.push(String.fromCharCode(c1));\n      } else if (c1 > 191 && c1 < 224) {\n        let c2 = bytes[pos++];\n        out.push(String.fromCharCode((c1 & 31) << 6 | c2 & 63));\n      } else if (c1 > 239 && c1 < 365) {\n        // Surrogate Pair\n        let c2 = bytes[pos++];\n        let c3 = bytes[pos++];\n        let c4 = bytes[pos++];\n        let u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 0x10000;\n        out.push(String.fromCharCode(0xd800 + (u >> 10)));\n        out.push(String.fromCharCode(0xdc00 + (u & 1023)));\n      } else {\n        let c2 = bytes[pos++];\n        let c3 = bytes[pos++];\n        out.push(String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63));\n      }\n    }\n    return out.join('');\n  }\n  static toUTF8Array(input) {\n    if (BufferShim.isNodeEnv) return BufferShim.toArrayBuffer(Buffer.from(input, 'utf8'));\n    let utf8 = [];\n    for (let i = 0; i < input.length; i += 1) {\n      let charcode = input.charCodeAt(i);\n      if (charcode < 0x80) {\n        utf8.push(charcode);\n      } else if (charcode < 0x800) {\n        utf8.push(0xc0 | charcode >> 6, 0x80 | charcode & 0x3f);\n      } else if (charcode < 0xd800 || charcode >= 0xe000) {\n        utf8.push(0xe0 | charcode >> 12, 0x80 | charcode >> 6 & 0x3f, 0x80 | charcode & 0x3f);\n      } else {\n        // surrogate pair\n        i += 1;\n        charcode = 0x10000 + ((charcode & 0x3ff) << 10 | input.charCodeAt(i) & 0x3ff);\n        utf8.push(0xf0 | charcode >> 18, 0x80 | charcode >> 12 & 0x3f, 0x80 | charcode >> 6 & 0x3f, 0x80 | charcode & 0x3f);\n      }\n    }\n    return new Uint8Array(utf8).buffer;\n  }\n  static toUTF16Array(input) {\n    if (BufferShim.isNodeEnv) return BufferShim.toArrayBuffer(Buffer.from(input, 'utf16le'));\n    const utf16 = [];\n    for (let i = 0; i < input.length; i += 1) {\n      const c = input.charCodeAt(i);\n      const hi = c >> 8;\n      const lo = c % 256;\n      utf16.push(lo);\n      utf16.push(hi);\n    }\n    return new Uint8Array(utf16).buffer;\n  }\n  static fromUTF16Array(buffer) {\n    if (BufferShim.isNodeEnv) return BufferShim.toNodeBuffer(buffer).toString('utf16le');\n    const bytes = new Uint8Array(buffer);\n    const out = [];\n    for (let i = 0; i < bytes.length; i += 2) {\n      out.push(String.fromCharCode(bytes[i] + bytes[i + 1] * 256));\n    }\n    return out.join('');\n  }\n  static toASCIIArrayOrBinaryArray(input) {\n    if (BufferShim.isNodeEnv) return BufferShim.toArrayBuffer(Buffer.from(input, 'binary'));\n    const ascii = [];\n    for (let i = 0; i < input.length; i += 1) {\n      ascii.push(input.charCodeAt(i) & 0xff);\n    }\n    return new Uint8Array(ascii).buffer;\n  }\n  static fromBinaryArray(buffer) {\n    if (BufferShim.isNodeEnv) return BufferShim.toNodeBuffer(buffer).toString('binary');\n    const bytes = new Uint8Array(buffer);\n    const out = [];\n    for (let i = 0; i < bytes.length; i += 1) {\n      out.push(String.fromCharCode(bytes[i]));\n    }\n    return out.join('');\n  }\n  static toHexArray(input) {\n    if (BufferShim.isNodeEnv) return BufferShim.toArrayBuffer(Buffer.from(input, 'hex'));\n    const HEX_LEN = 2;\n    const hex = [];\n    const length = input.length / HEX_LEN;\n    for (let i = 0; i < length; i += 1) {\n      const parsed = parseInt(input.substr(i * HEX_LEN, HEX_LEN), 16);\n      if (isNaN(parsed)) return new Uint8Array([]).buffer;\n      hex.push(parsed);\n    }\n    return new Uint8Array(hex).buffer;\n  }\n  static fromHexArray(buffer) {\n    if (BufferShim.isNodeEnv) return BufferShim.toNodeBuffer(buffer).toString('hex');\n    const bytes = new Uint8Array(buffer);\n    const out = [];\n    for (let i = 0; i < bytes.length; i += 1) {\n      const hex = bytes[i].toString(16);\n      out.push(hex.length === 1 ? '0' + hex : hex);\n    }\n    return out.join('');\n  }\n  /** Copy a Buffer or BufferShim to an ArrayBuffer.\r\n   * @param {Buffer|BufferShim} buffer\r\n   * @returns {ArrayBuffer}\r\n   */\n  static toArrayBuffer(buffer) {\n    const arrayBuffer = new ArrayBuffer(buffer.length);\n    const view = new Uint8Array(arrayBuffer);\n    for (let i = 0; i < buffer.length; i += 1) {\n      view[i] = buffer[i];\n    }\n    return arrayBuffer;\n  }\n  /** Copy an ArrayBuffer to a Buffer if possible or a BufferShim.\r\n   * @param {ArrayBuffer} buffer\r\n   * @returns {Buffer}\r\n   */\n  static toNodeBuffer(buffer) {\n    if (!BufferShim.isNodeEnv) return new BufferShim(buffer);\n    const nodeBuffer = Buffer.alloc(buffer.byteLength);\n    const view = new Uint8Array(buffer);\n    for (let i = 0; i < nodeBuffer.length; i += 1) {\n      nodeBuffer[i] = view[i];\n    }\n    return nodeBuffer;\n  }\n  fill(value, offset, end, encoding) {\n    BufferShim.fill(this, value, offset, end, encoding);\n    return this;\n  }\n  /** Returns this instance as a Uint8Array.\r\n   * @returns {Uint8Array}\r\n   */\n  toUint8Array() {\n    return new Uint8Array(this.buffer);\n  }\n  /** Returns this instance as a NodeJS Buffer if possible.\r\n   * @returns {Buffer}\r\n   */\n  toBuffer() {\n    return BufferShim.toNodeBuffer(this.buffer);\n  }\n  /** Returns this instance as a string.\r\n   * @param {BufferEncoding} [encoding='utf8']\r\n   * @returns {string}\r\n   */\n  toString(encoding = 'utf8') {\n    encoding = normalizeEncoding(encoding);\n    switch (encoding) {\n      case 'hex':\n        return BufferShim.fromHexArray(this.buffer);\n      case 'utf16le':\n        return BufferShim.fromUTF16Array(this.buffer);\n      case 'latin1':\n        return BufferShim.fromBinaryArray(this.buffer);\n      case 'base64':\n        return BufferShim.btoa(this.buffer);\n      case 'ascii':\n      case 'utf8':\n      default:\n        return BufferShim.fromUTF8ArrayOrASCIIArray(this.buffer);\n    }\n  }\n  /** Tests if the current environment is using NodeJS Buffer implementation. */\n  static get isNodeEnv() {\n    if (IGNORE_NODE) return false;\n    return typeof Buffer === 'function' && typeof Buffer.from === 'function' && typeof Buffer.isBufferShim === 'undefined';\n  }\n  /** Returns true if {buffer} is a Buffer\r\n   * @param {any} buffer\r\n   * @returns {boolean}\r\n   */\n  static isBuffer(buffer) {\n    if (BufferShim.isNodeEnv) {\n      return buffer instanceof Buffer;\n    }\n    return false;\n  }\n  /** Returns true if {buffer} is a BufferShim\r\n   * @param {any} buffer\r\n   * @returns {boolean}\r\n   */\n  static isBufferShim(buffer) {\n    return buffer instanceof BufferShim;\n  }\n  /** Allocates a new buffer of {size} octets.\r\n   * @param {number} size\r\n   * @returns {BufferShim}\r\n   */\n  static alloc(size, fill, encoding) {\n    return BufferShim.fill(new BufferShim(new ArrayBuffer(size)), fill || 0, encoding);\n  }\n  /** Allocates a new uninitialized buffer of {size} octets.\r\n   * @param {number} size\r\n   * @returns {BufferShim}\r\n   */\n  static allocUnsafe(size) {\n    return new BufferShim(new ArrayBuffer(size));\n  }\n  static from(input, encoding) {\n    if (typeof input !== 'string' && !BufferShim.isBuffer(input) && !BufferShim.isBufferShim(input) && (Array.isArray(input) || input instanceof Uint8Array || typeof input[Symbol.iterator] === 'function')) {\n      const buffer = Uint8Array.from(input).buffer;\n      return new BufferShim(buffer);\n    }\n    return new BufferShim(input, encoding);\n  }\n  static fill(buffer, value, offset, end, encoding) {\n    if (typeof value === 'string') {\n      if (offset === undefined || typeof offset === 'string') {\n        encoding = offset;\n        offset = 0;\n        end = buffer.length;\n      } else if (typeof end === 'string') {\n        encoding = end;\n        end = buffer.length;\n      }\n      const normalizedEncoding = normalizeEncoding(encoding);\n      if (normalizedEncoding === undefined) {\n        throw new Error('Unsupported encoding ' + encoding);\n      }\n      if (value.length === 0) {\n        // If value === '' default to zero.\n        value = 0;\n      } else if (value.length === 1) {\n        // Fast path: If `value` fits into a single byte, use that numeric value.\n        if (normalizedEncoding === 'utf8') {\n          const code = value.charCodeAt(0);\n          if (code < 128) {\n            value = code;\n          }\n        } else if (normalizedEncoding === 'latin1') {\n          value = value.charCodeAt(0);\n        }\n      }\n    } else {\n      encoding = undefined;\n    }\n    if (offset === undefined) {\n      offset = 0;\n      end = buffer.length;\n    } else {\n      validateInt32(offset, 'offset', 0);\n      // Invalid ranges are not set to a default, so can range check early.\n      if (end === undefined) {\n        end = buffer.length;\n      } else {\n        validateInt32(end, 'end', 0, buffer.length);\n      }\n      if (offset >= end) return buffer;\n    }\n    if (typeof value === 'number') {\n      // OOB check\n      const byteLen = byteLength.call(buffer);\n      const fillLength = end - offset;\n      if (offset > end || fillLength + offset > byteLen) {\n        throw new Error('Attempt to access memory outside buffer bounds');\n      }\n      byteFill.call(buffer, value, offset, end);\n    } else {\n      const bytes = BufferShim.isBufferShim(value) ? value : BufferShim.from(value);\n      const length = bytes.length;\n      for (let i = 0; i < end - offset; i += 1) {\n        buffer[i + offset] = bytes[i % length];\n      }\n    }\n    return buffer;\n  }\n}\n/** Global function for ignoring NodeJS env in class BufferShim.\r\n * @param {boolean} [ignore] - Sets the global value; if no boolean is passed, it will return the current setting.\r\n * @returns {boolean}\r\n */\nexport function ignoreNode(ignore) {\n  if (typeof ignore === 'boolean') {\n    IGNORE_NODE = ignore;\n  }\n  return IGNORE_NODE;\n}","map":{"version":3,"names":["BASE64_ENCODINGS","BASE64_LOOKUP","Uint8Array","IGNORE_NODE","byteArrayProto","Object","getPrototypeOf","prototype","byteLength","getOwnPropertyDescriptor","get","byteFill","fill","normalizeEncoding","enc","encoding","toLowerCase","validateInt32","value","name","min","max","OUT_OF_RANGE","Error","Number","isInteger","BufferShim","constructor","input","buffer","charCodeAt","i","length","toUTF8Array","toUTF16Array","includes","toASCIIArrayOrBinaryArray","toHexArray","atob","isBuffer","isBufferShim","toArrayBuffer","ArrayBuffer","SharedArrayBuffer","isNodeEnv","Buffer","from","getByteLength","str","bytes","replace","dataView","bytePos","pos","encoded1","encoded2","encoded3","encoded4","btoa","toNodeBuffer","toString","base64","byteRemainder","mainLength","a","b","c","d","chunk","fromUTF8ArrayOrASCIIArray","out","c1","push","String","fromCharCode","c2","c3","c4","u","join","utf8","charcode","utf16","hi","lo","fromUTF16Array","ascii","fromBinaryArray","HEX_LEN","hex","parsed","parseInt","substr","isNaN","fromHexArray","arrayBuffer","view","nodeBuffer","alloc","offset","end","toUint8Array","toBuffer","size","allocUnsafe","Array","isArray","Symbol","iterator","undefined","normalizedEncoding","code","byteLen","call","fillLength","ignoreNode","ignore"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/buffer-esm/esm/index.js"],"sourcesContent":["const BASE64_ENCODINGS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\nconst BASE64_LOOKUP = new Uint8Array(256);\r\nlet IGNORE_NODE = false;\r\nconst byteArrayProto = Object.getPrototypeOf(Uint8Array.prototype);\r\nconst byteLength = Object.getOwnPropertyDescriptor(byteArrayProto, 'byteLength').get;\r\nconst byteFill = byteArrayProto.fill;\r\nconst normalizeEncoding = function normalizeEncoding(enc) {\r\n    const encoding = `${enc}`.toLowerCase();\r\n    switch (encoding) {\r\n        case 'ascii':\r\n            return 'ascii';\r\n        case 'base64':\r\n            return 'base64';\r\n        case 'hex':\r\n            return 'hex';\r\n        case 'latin1':\r\n        case 'binary':\r\n            return 'latin1';\r\n        case 'ucs2':\r\n        case 'ucs-2':\r\n        case 'utf16le':\r\n            return 'utf16le';\r\n        case 'utf8':\r\n        case 'utf-8':\r\n            return 'utf8';\r\n        default:\r\n            if (encoding === '')\r\n                return 'utf8';\r\n    }\r\n};\r\nconst validateInt32 = function validateInt32(value, name, min = -2147483648, max = 2147483647) {\r\n    const OUT_OF_RANGE = `'${name}' must be >= ${min} && <= ${max}: ${value}`;\r\n    if (value !== (value | 0)) {\r\n        if (typeof value !== 'number') {\r\n            throw new Error(`'${name}' must be a number: ${value}`);\r\n        }\r\n        if (!Number.isInteger(value)) {\r\n            throw new Error(`'${name}' must be an integer: ${value}`);\r\n        }\r\n        throw new Error(OUT_OF_RANGE);\r\n    }\r\n    if (value < min || value > max) {\r\n        throw new Error(OUT_OF_RANGE);\r\n    }\r\n};\r\n/** Class extending Uint8Array to provide a partial implementation of NodeJS Buffer as a cross-platform shim. */\r\nexport class BufferShim extends Uint8Array {\r\n    /**\r\n     * @param {string|Buffer|BufferShim|ArrayBuffer|SharedArrayBuffer} input\r\n     * @param {BufferEncoding} [encoding='utf8']\r\n     */\r\n    constructor(input, encoding = 'utf8') {\r\n        encoding = normalizeEncoding(encoding);\r\n        let buffer;\r\n        if (BASE64_LOOKUP['B'.charCodeAt(0)] === 0) {\r\n            for (let i = 0; i < BASE64_ENCODINGS.length; i += 1) {\r\n                BASE64_LOOKUP[BASE64_ENCODINGS.charCodeAt(i)] = i;\r\n            }\r\n        }\r\n        if (typeof input === 'string' && encoding === 'utf8') {\r\n            buffer = BufferShim.toUTF8Array(input);\r\n        }\r\n        else if (typeof input === 'string' && encoding === 'utf16le') {\r\n            buffer = BufferShim.toUTF16Array(input);\r\n        }\r\n        else if (typeof input === 'string' && ['ascii', 'latin1'].includes(encoding)) {\r\n            buffer = BufferShim.toASCIIArrayOrBinaryArray(input);\r\n        }\r\n        else if (typeof input === 'string' && encoding === 'hex') {\r\n            buffer = BufferShim.toHexArray(input);\r\n        }\r\n        else if (typeof input === 'string' && encoding === 'base64') {\r\n            buffer = BufferShim.atob(input);\r\n        }\r\n        else if (typeof input === 'string') {\r\n            throw new Error('Unsupported encoding ' + encoding);\r\n        }\r\n        else if (BufferShim.isBuffer(input) || BufferShim.isBufferShim(input)) {\r\n            buffer = BufferShim.toArrayBuffer(input);\r\n        }\r\n        else if (input instanceof ArrayBuffer || input instanceof SharedArrayBuffer) {\r\n            buffer = input;\r\n        }\r\n        else {\r\n            throw new Error('The first argument must be one of type string, Buffer, ' +\r\n                'ArrayBuffer, Array, or Array-like Object. Received type ' +\r\n                (typeof input));\r\n        }\r\n        super(buffer);\r\n    }\r\n    static atob(input) {\r\n        if (BufferShim.isNodeEnv)\r\n            return BufferShim.toArrayBuffer(Buffer.from(input, 'base64'));\r\n        const getByteLength = (str) => {\r\n            let bytes = str.length * 0.75;\r\n            if (str[str.length - 1] === '=') {\r\n                bytes--;\r\n                if (str[str.length - 2] === '=') {\r\n                    bytes--;\r\n                }\r\n            }\r\n            return bytes;\r\n        };\r\n        input = input.replace(/[\\t\\n\\f\\r\\s]+/g, '');\r\n        const byteLength = getByteLength(input);\r\n        const buffer = new ArrayBuffer(byteLength);\r\n        const dataView = new Uint8Array(buffer);\r\n        let bytePos = 0;\r\n        for (let pos = 0; pos < input.length; pos += 4) {\r\n            const encoded1 = BASE64_LOOKUP[input.charCodeAt(pos)];\r\n            const encoded2 = BASE64_LOOKUP[input.charCodeAt(pos + 1)];\r\n            const encoded3 = BASE64_LOOKUP[input.charCodeAt(pos + 2)];\r\n            const encoded4 = BASE64_LOOKUP[input.charCodeAt(pos + 3)];\r\n            dataView[bytePos++] = (encoded1 << 2) | (encoded2 >> 4);\r\n            dataView[bytePos++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\r\n            dataView[bytePos++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\r\n        }\r\n        return buffer;\r\n    }\r\n    static btoa(buffer) {\r\n        if (BufferShim.isNodeEnv)\r\n            return BufferShim.toNodeBuffer(buffer).toString('base64');\r\n        let base64 = '';\r\n        let bytes = new Uint8Array(buffer);\r\n        let byteLength = bytes.byteLength;\r\n        let byteRemainder = byteLength % 3;\r\n        let mainLength = byteLength - byteRemainder;\r\n        let a, b, c, d;\r\n        let chunk;\r\n        // Main loop deals with bytes in chunks of 3\r\n        for (let i = 0; i < mainLength; i = i + 3) {\r\n            // Combine the three bytes into a single integer\r\n            chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\r\n            // Use bitmasks to extract 6-bit segments from the triplet\r\n            a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\r\n            b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\r\n            c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\r\n            d = chunk & 63; // 63       = 2^6 - 1\r\n            // Convert the raw binary segments to the appropriate ASCII encoding\r\n            base64 += BASE64_ENCODINGS[a] + BASE64_ENCODINGS[b] + BASE64_ENCODINGS[c] + BASE64_ENCODINGS[d];\r\n        }\r\n        // Deal with the remaining bytes and padding\r\n        if (byteRemainder == 1) {\r\n            chunk = bytes[mainLength];\r\n            a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\r\n            // Set the 4 least significant bits to zero\r\n            b = (chunk & 3) << 4; // 3   = 2^2 - 1\r\n            base64 += BASE64_ENCODINGS[a] + BASE64_ENCODINGS[b] + '==';\r\n        }\r\n        else if (byteRemainder == 2) {\r\n            chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];\r\n            a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\r\n            b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\r\n            // Set the 2 least significant bits to zero\r\n            c = (chunk & 15) << 2; // 15    = 2^4 - 1\r\n            base64 += BASE64_ENCODINGS[a] + BASE64_ENCODINGS[b] + BASE64_ENCODINGS[c] + '=';\r\n        }\r\n        return base64;\r\n    }\r\n    static fromUTF8ArrayOrASCIIArray(buffer) {\r\n        if (BufferShim.isNodeEnv)\r\n            return BufferShim.toNodeBuffer(buffer).toString('utf8');\r\n        const bytes = new Uint8Array(buffer);\r\n        const out = [];\r\n        let pos = 0;\r\n        while (pos < bytes.length) {\r\n            let c1 = bytes[pos++];\r\n            if (c1 < 128) {\r\n                out.push(String.fromCharCode(c1));\r\n            }\r\n            else if (c1 > 191 && c1 < 224) {\r\n                let c2 = bytes[pos++];\r\n                out.push(String.fromCharCode(((c1 & 31) << 6) | (c2 & 63)));\r\n            }\r\n            else if (c1 > 239 && c1 < 365) {\r\n                // Surrogate Pair\r\n                let c2 = bytes[pos++];\r\n                let c3 = bytes[pos++];\r\n                let c4 = bytes[pos++];\r\n                let u = (((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63)) - 0x10000;\r\n                out.push(String.fromCharCode(0xd800 + (u >> 10)));\r\n                out.push(String.fromCharCode(0xdc00 + (u & 1023)));\r\n            }\r\n            else {\r\n                let c2 = bytes[pos++];\r\n                let c3 = bytes[pos++];\r\n                out.push(String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));\r\n            }\r\n        }\r\n        return out.join('');\r\n    }\r\n    static toUTF8Array(input) {\r\n        if (BufferShim.isNodeEnv)\r\n            return BufferShim.toArrayBuffer(Buffer.from(input, 'utf8'));\r\n        let utf8 = [];\r\n        for (let i = 0; i < input.length; i += 1) {\r\n            let charcode = input.charCodeAt(i);\r\n            if (charcode < 0x80) {\r\n                utf8.push(charcode);\r\n            }\r\n            else if (charcode < 0x800) {\r\n                utf8.push(0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f));\r\n            }\r\n            else if (charcode < 0xd800 || charcode >= 0xe000) {\r\n                utf8.push(0xe0 | (charcode >> 12), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));\r\n            }\r\n            else {\r\n                // surrogate pair\r\n                i += 1;\r\n                charcode = 0x10000 + (((charcode & 0x3ff) << 10) | (input.charCodeAt(i) & 0x3ff));\r\n                utf8.push(0xf0 | (charcode >> 18), 0x80 | ((charcode >> 12) & 0x3f), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));\r\n            }\r\n        }\r\n        return new Uint8Array(utf8).buffer;\r\n    }\r\n    static toUTF16Array(input) {\r\n        if (BufferShim.isNodeEnv)\r\n            return BufferShim.toArrayBuffer(Buffer.from(input, 'utf16le'));\r\n        const utf16 = [];\r\n        for (let i = 0; i < input.length; i += 1) {\r\n            const c = input.charCodeAt(i);\r\n            const hi = c >> 8;\r\n            const lo = c % 256;\r\n            utf16.push(lo);\r\n            utf16.push(hi);\r\n        }\r\n        return new Uint8Array(utf16).buffer;\r\n    }\r\n    static fromUTF16Array(buffer) {\r\n        if (BufferShim.isNodeEnv)\r\n            return BufferShim.toNodeBuffer(buffer).toString('utf16le');\r\n        const bytes = new Uint8Array(buffer);\r\n        const out = [];\r\n        for (let i = 0; i < bytes.length; i += 2) {\r\n            out.push(String.fromCharCode(bytes[i] + bytes[i + 1] * 256));\r\n        }\r\n        return out.join('');\r\n    }\r\n    static toASCIIArrayOrBinaryArray(input) {\r\n        if (BufferShim.isNodeEnv)\r\n            return BufferShim.toArrayBuffer(Buffer.from(input, 'binary'));\r\n        const ascii = [];\r\n        for (let i = 0; i < input.length; i += 1) {\r\n            ascii.push(input.charCodeAt(i) & 0xff);\r\n        }\r\n        return new Uint8Array(ascii).buffer;\r\n    }\r\n    static fromBinaryArray(buffer) {\r\n        if (BufferShim.isNodeEnv)\r\n            return BufferShim.toNodeBuffer(buffer).toString('binary');\r\n        const bytes = new Uint8Array(buffer);\r\n        const out = [];\r\n        for (let i = 0; i < bytes.length; i += 1) {\r\n            out.push(String.fromCharCode(bytes[i]));\r\n        }\r\n        return out.join('');\r\n    }\r\n    static toHexArray(input) {\r\n        if (BufferShim.isNodeEnv)\r\n            return BufferShim.toArrayBuffer(Buffer.from(input, 'hex'));\r\n        const HEX_LEN = 2;\r\n        const hex = [];\r\n        const length = input.length / HEX_LEN;\r\n        for (let i = 0; i < length; i += 1) {\r\n            const parsed = parseInt(input.substr(i * HEX_LEN, HEX_LEN), 16);\r\n            if (isNaN(parsed))\r\n                return new Uint8Array([]).buffer;\r\n            hex.push(parsed);\r\n        }\r\n        return new Uint8Array(hex).buffer;\r\n    }\r\n    static fromHexArray(buffer) {\r\n        if (BufferShim.isNodeEnv)\r\n            return BufferShim.toNodeBuffer(buffer).toString('hex');\r\n        const bytes = new Uint8Array(buffer);\r\n        const out = [];\r\n        for (let i = 0; i < bytes.length; i += 1) {\r\n            const hex = bytes[i].toString(16);\r\n            out.push(hex.length === 1 ? '0' + hex : hex);\r\n        }\r\n        return out.join('');\r\n    }\r\n    /** Copy a Buffer or BufferShim to an ArrayBuffer.\r\n     * @param {Buffer|BufferShim} buffer\r\n     * @returns {ArrayBuffer}\r\n     */\r\n    static toArrayBuffer(buffer) {\r\n        const arrayBuffer = new ArrayBuffer(buffer.length);\r\n        const view = new Uint8Array(arrayBuffer);\r\n        for (let i = 0; i < buffer.length; i += 1) {\r\n            view[i] = buffer[i];\r\n        }\r\n        return arrayBuffer;\r\n    }\r\n    /** Copy an ArrayBuffer to a Buffer if possible or a BufferShim.\r\n     * @param {ArrayBuffer} buffer\r\n     * @returns {Buffer}\r\n     */\r\n    static toNodeBuffer(buffer) {\r\n        if (!BufferShim.isNodeEnv)\r\n            return new BufferShim(buffer);\r\n        const nodeBuffer = Buffer.alloc(buffer.byteLength);\r\n        const view = new Uint8Array(buffer);\r\n        for (let i = 0; i < nodeBuffer.length; i += 1) {\r\n            nodeBuffer[i] = view[i];\r\n        }\r\n        return nodeBuffer;\r\n    }\r\n    fill(value, offset, end, encoding) {\r\n        BufferShim.fill(this, value, offset, end, encoding);\r\n        return this;\r\n    }\r\n    /** Returns this instance as a Uint8Array.\r\n     * @returns {Uint8Array}\r\n     */\r\n    toUint8Array() {\r\n        return new Uint8Array(this.buffer);\r\n    }\r\n    /** Returns this instance as a NodeJS Buffer if possible.\r\n     * @returns {Buffer}\r\n     */\r\n    toBuffer() {\r\n        return BufferShim.toNodeBuffer(this.buffer);\r\n    }\r\n    /** Returns this instance as a string.\r\n     * @param {BufferEncoding} [encoding='utf8']\r\n     * @returns {string}\r\n     */\r\n    toString(encoding = 'utf8') {\r\n        encoding = normalizeEncoding(encoding);\r\n        switch (encoding) {\r\n            case 'hex':\r\n                return BufferShim.fromHexArray(this.buffer);\r\n            case 'utf16le':\r\n                return BufferShim.fromUTF16Array(this.buffer);\r\n            case 'latin1':\r\n                return BufferShim.fromBinaryArray(this.buffer);\r\n            case 'base64':\r\n                return BufferShim.btoa(this.buffer);\r\n            case 'ascii':\r\n            case 'utf8':\r\n            default:\r\n                return BufferShim.fromUTF8ArrayOrASCIIArray(this.buffer);\r\n        }\r\n    }\r\n    /** Tests if the current environment is using NodeJS Buffer implementation. */\r\n    static get isNodeEnv() {\r\n        if (IGNORE_NODE)\r\n            return false;\r\n        return typeof Buffer === 'function' && typeof Buffer.from === 'function' && typeof Buffer.isBufferShim === 'undefined';\r\n    }\r\n    /** Returns true if {buffer} is a Buffer\r\n     * @param {any} buffer\r\n     * @returns {boolean}\r\n     */\r\n    static isBuffer(buffer) {\r\n        if (BufferShim.isNodeEnv) {\r\n            return buffer instanceof Buffer;\r\n        }\r\n        return false;\r\n    }\r\n    /** Returns true if {buffer} is a BufferShim\r\n     * @param {any} buffer\r\n     * @returns {boolean}\r\n     */\r\n    static isBufferShim(buffer) {\r\n        return buffer instanceof BufferShim;\r\n    }\r\n    /** Allocates a new buffer of {size} octets.\r\n     * @param {number} size\r\n     * @returns {BufferShim}\r\n     */\r\n    static alloc(size, fill, encoding) {\r\n        return BufferShim.fill(new BufferShim(new ArrayBuffer(size)), fill || 0, encoding);\r\n    }\r\n    /** Allocates a new uninitialized buffer of {size} octets.\r\n     * @param {number} size\r\n     * @returns {BufferShim}\r\n     */\r\n    static allocUnsafe(size) {\r\n        return new BufferShim(new ArrayBuffer(size));\r\n    }\r\n    static from(input, encoding) {\r\n        if (typeof input !== 'string' &&\r\n            !BufferShim.isBuffer(input) &&\r\n            !BufferShim.isBufferShim(input) &&\r\n            (Array.isArray(input) || input instanceof Uint8Array || typeof input[Symbol.iterator] === 'function')) {\r\n            const buffer = Uint8Array.from(input).buffer;\r\n            return new BufferShim(buffer);\r\n        }\r\n        return new BufferShim(input, encoding);\r\n    }\r\n    static fill(buffer, value, offset, end, encoding) {\r\n        if (typeof value === 'string') {\r\n            if (offset === undefined || typeof offset === 'string') {\r\n                encoding = offset;\r\n                offset = 0;\r\n                end = buffer.length;\r\n            }\r\n            else if (typeof end === 'string') {\r\n                encoding = end;\r\n                end = buffer.length;\r\n            }\r\n            const normalizedEncoding = normalizeEncoding(encoding);\r\n            if (normalizedEncoding === undefined) {\r\n                throw new Error('Unsupported encoding ' + encoding);\r\n            }\r\n            if (value.length === 0) {\r\n                // If value === '' default to zero.\r\n                value = 0;\r\n            }\r\n            else if (value.length === 1) {\r\n                // Fast path: If `value` fits into a single byte, use that numeric value.\r\n                if (normalizedEncoding === 'utf8') {\r\n                    const code = value.charCodeAt(0);\r\n                    if (code < 128) {\r\n                        value = code;\r\n                    }\r\n                }\r\n                else if (normalizedEncoding === 'latin1') {\r\n                    value = value.charCodeAt(0);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            encoding = undefined;\r\n        }\r\n        if (offset === undefined) {\r\n            offset = 0;\r\n            end = buffer.length;\r\n        }\r\n        else {\r\n            validateInt32(offset, 'offset', 0);\r\n            // Invalid ranges are not set to a default, so can range check early.\r\n            if (end === undefined) {\r\n                end = buffer.length;\r\n            }\r\n            else {\r\n                validateInt32(end, 'end', 0, buffer.length);\r\n            }\r\n            if (offset >= end)\r\n                return buffer;\r\n        }\r\n        if (typeof value === 'number') {\r\n            // OOB check\r\n            const byteLen = byteLength.call(buffer);\r\n            const fillLength = end - offset;\r\n            if (offset > end || fillLength + offset > byteLen) {\r\n                throw new Error('Attempt to access memory outside buffer bounds');\r\n            }\r\n            byteFill.call(buffer, value, offset, end);\r\n        }\r\n        else {\r\n            const bytes = BufferShim.isBufferShim(value) ? value : BufferShim.from(value);\r\n            const length = bytes.length;\r\n            for (let i = 0; i < end - offset; i += 1) {\r\n                buffer[i + offset] = bytes[i % length];\r\n            }\r\n        }\r\n        return buffer;\r\n    }\r\n}\r\n/** Global function for ignoring NodeJS env in class BufferShim.\r\n * @param {boolean} [ignore] - Sets the global value; if no boolean is passed, it will return the current setting.\r\n * @returns {boolean}\r\n */\r\nexport function ignoreNode(ignore) {\r\n    if (typeof ignore === 'boolean') {\r\n        IGNORE_NODE = ignore;\r\n    }\r\n    return IGNORE_NODE;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}