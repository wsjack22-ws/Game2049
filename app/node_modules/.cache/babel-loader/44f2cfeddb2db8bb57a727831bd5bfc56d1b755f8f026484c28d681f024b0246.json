{"ast":null,"code":"'use strict';\n\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController;\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_ARG_TYPE,\n    ERR_MISSING_ARGS,\n    ERR_OUT_OF_RANGE\n  },\n  AbortError\n} = require('../../ours/errors');\nconst {\n  validateAbortSignal,\n  validateInteger,\n  validateObject\n} = require('../validators');\nconst kWeakHandler = require('../../ours/primordials').Symbol('kWeak');\nconst {\n  finished\n} = require('./end-of-stream');\nconst staticCompose = require('./compose');\nconst {\n  addAbortSignalNoValidate\n} = require('./add-abort-signal');\nconst {\n  isWritable,\n  isNodeStream\n} = require('./utils');\nconst {\n  ArrayPrototypePush,\n  MathFloor,\n  Number,\n  NumberIsNaN,\n  Promise,\n  PromiseReject,\n  PromisePrototypeThen,\n  Symbol\n} = require('../../ours/primordials');\nconst kEmpty = Symbol('kEmpty');\nconst kEof = Symbol('kEof');\nfunction compose(stream, options) {\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  if (isNodeStream(stream) && !isWritable(stream)) {\n    throw new ERR_INVALID_ARG_VALUE('stream', stream, 'must be writable');\n  }\n  const composedStream = staticCompose(this, stream);\n  if (options !== null && options !== undefined && options.signal) {\n    // Not validating as we already validated before\n    addAbortSignalNoValidate(options.signal, composedStream);\n  }\n  return composedStream;\n}\nfunction map(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn);\n  }\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  let concurrency = 1;\n  if ((options === null || options === undefined ? undefined : options.concurrency) != null) {\n    concurrency = MathFloor(options.concurrency);\n  }\n  validateInteger(concurrency, 'concurrency', 1);\n  return async function* map() {\n    var _options$signal, _options$signal2;\n    const ac = new AbortController();\n    const stream = this;\n    const queue = [];\n    const signal = ac.signal;\n    const signalOpt = {\n      signal\n    };\n    const abort = () => ac.abort();\n    if (options !== null && options !== undefined && (_options$signal = options.signal) !== null && _options$signal !== undefined && _options$signal.aborted) {\n      abort();\n    }\n    options === null || options === undefined ? undefined : (_options$signal2 = options.signal) === null || _options$signal2 === undefined ? undefined : _options$signal2.addEventListener('abort', abort);\n    let next;\n    let resume;\n    let done = false;\n    function onDone() {\n      done = true;\n    }\n    async function pump() {\n      try {\n        for await (let val of stream) {\n          var _val;\n          if (done) {\n            return;\n          }\n          if (signal.aborted) {\n            throw new AbortError();\n          }\n          try {\n            val = fn(val, signalOpt);\n          } catch (err) {\n            val = PromiseReject(err);\n          }\n          if (val === kEmpty) {\n            continue;\n          }\n          if (typeof ((_val = val) === null || _val === undefined ? undefined : _val.catch) === 'function') {\n            val.catch(onDone);\n          }\n          queue.push(val);\n          if (next) {\n            next();\n            next = null;\n          }\n          if (!done && queue.length && queue.length >= concurrency) {\n            await new Promise(resolve => {\n              resume = resolve;\n            });\n          }\n        }\n        queue.push(kEof);\n      } catch (err) {\n        const val = PromiseReject(err);\n        PromisePrototypeThen(val, undefined, onDone);\n        queue.push(val);\n      } finally {\n        var _options$signal3;\n        done = true;\n        if (next) {\n          next();\n          next = null;\n        }\n        options === null || options === undefined ? undefined : (_options$signal3 = options.signal) === null || _options$signal3 === undefined ? undefined : _options$signal3.removeEventListener('abort', abort);\n      }\n    }\n    pump();\n    try {\n      while (true) {\n        while (queue.length > 0) {\n          const val = await queue[0];\n          if (val === kEof) {\n            return;\n          }\n          if (signal.aborted) {\n            throw new AbortError();\n          }\n          if (val !== kEmpty) {\n            yield val;\n          }\n          queue.shift();\n          if (resume) {\n            resume();\n            resume = null;\n          }\n        }\n        await new Promise(resolve => {\n          next = resolve;\n        });\n      }\n    } finally {\n      ac.abort();\n      done = true;\n      if (resume) {\n        resume();\n        resume = null;\n      }\n    }\n  }.call(this);\n}\nfunction asIndexedPairs(options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  return async function* asIndexedPairs() {\n    let index = 0;\n    for await (const val of this) {\n      var _options$signal4;\n      if (options !== null && options !== undefined && (_options$signal4 = options.signal) !== null && _options$signal4 !== undefined && _options$signal4.aborted) {\n        throw new AbortError({\n          cause: options.signal.reason\n        });\n      }\n      yield [index++, val];\n    }\n  }.call(this);\n}\nasync function some(fn, options = undefined) {\n  for await (const unused of filter.call(this, fn, options)) {\n    return true;\n  }\n  return false;\n}\nasync function every(fn, options = undefined) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn);\n  }\n  // https://en.wikipedia.org/wiki/De_Morgan%27s_laws\n  return !(await some.call(this, async (...args) => {\n    return !(await fn(...args));\n  }, options));\n}\nasync function find(fn, options) {\n  for await (const result of filter.call(this, fn, options)) {\n    return result;\n  }\n  return undefined;\n}\nasync function forEach(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn);\n  }\n  async function forEachFn(value, options) {\n    await fn(value, options);\n    return kEmpty;\n  }\n  // eslint-disable-next-line no-unused-vars\n  for await (const unused of map.call(this, forEachFn, options));\n}\nfunction filter(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn);\n  }\n  async function filterFn(value, options) {\n    if (await fn(value, options)) {\n      return value;\n    }\n    return kEmpty;\n  }\n  return map.call(this, filterFn, options);\n}\n\n// Specific to provide better error to reduce since the argument is only\n// missing if the stream has no items in it - but the code is still appropriate\nclass ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {\n  constructor() {\n    super('reduce');\n    this.message = 'Reduce of an empty stream requires an initial value';\n  }\n}\nasync function reduce(reducer, initialValue, options) {\n  var _options$signal5;\n  if (typeof reducer !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('reducer', ['Function', 'AsyncFunction'], reducer);\n  }\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  let hasInitialValue = arguments.length > 1;\n  if (options !== null && options !== undefined && (_options$signal5 = options.signal) !== null && _options$signal5 !== undefined && _options$signal5.aborted) {\n    const err = new AbortError(undefined, {\n      cause: options.signal.reason\n    });\n    this.once('error', () => {}); // The error is already propagated\n    await finished(this.destroy(err));\n    throw err;\n  }\n  const ac = new AbortController();\n  const signal = ac.signal;\n  if (options !== null && options !== undefined && options.signal) {\n    const opts = {\n      once: true,\n      [kWeakHandler]: this\n    };\n    options.signal.addEventListener('abort', () => ac.abort(), opts);\n  }\n  let gotAnyItemFromStream = false;\n  try {\n    for await (const value of this) {\n      var _options$signal6;\n      gotAnyItemFromStream = true;\n      if (options !== null && options !== undefined && (_options$signal6 = options.signal) !== null && _options$signal6 !== undefined && _options$signal6.aborted) {\n        throw new AbortError();\n      }\n      if (!hasInitialValue) {\n        initialValue = value;\n        hasInitialValue = true;\n      } else {\n        initialValue = await reducer(initialValue, value, {\n          signal\n        });\n      }\n    }\n    if (!gotAnyItemFromStream && !hasInitialValue) {\n      throw new ReduceAwareErrMissingArgs();\n    }\n  } finally {\n    ac.abort();\n  }\n  return initialValue;\n}\nasync function toArray(options) {\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  const result = [];\n  for await (const val of this) {\n    var _options$signal7;\n    if (options !== null && options !== undefined && (_options$signal7 = options.signal) !== null && _options$signal7 !== undefined && _options$signal7.aborted) {\n      throw new AbortError(undefined, {\n        cause: options.signal.reason\n      });\n    }\n    ArrayPrototypePush(result, val);\n  }\n  return result;\n}\nfunction flatMap(fn, options) {\n  const values = map.call(this, fn, options);\n  return async function* flatMap() {\n    for await (const val of values) {\n      yield* val;\n    }\n  }.call(this);\n}\nfunction toIntegerOrInfinity(number) {\n  // We coerce here to align with the spec\n  // https://github.com/tc39/proposal-iterator-helpers/issues/169\n  number = Number(number);\n  if (NumberIsNaN(number)) {\n    return 0;\n  }\n  if (number < 0) {\n    throw new ERR_OUT_OF_RANGE('number', '>= 0', number);\n  }\n  return number;\n}\nfunction drop(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  number = toIntegerOrInfinity(number);\n  return async function* drop() {\n    var _options$signal8;\n    if (options !== null && options !== undefined && (_options$signal8 = options.signal) !== null && _options$signal8 !== undefined && _options$signal8.aborted) {\n      throw new AbortError();\n    }\n    for await (const val of this) {\n      var _options$signal9;\n      if (options !== null && options !== undefined && (_options$signal9 = options.signal) !== null && _options$signal9 !== undefined && _options$signal9.aborted) {\n        throw new AbortError();\n      }\n      if (number-- <= 0) {\n        yield val;\n      }\n    }\n  }.call(this);\n}\nfunction take(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  number = toIntegerOrInfinity(number);\n  return async function* take() {\n    var _options$signal10;\n    if (options !== null && options !== undefined && (_options$signal10 = options.signal) !== null && _options$signal10 !== undefined && _options$signal10.aborted) {\n      throw new AbortError();\n    }\n    for await (const val of this) {\n      var _options$signal11;\n      if (options !== null && options !== undefined && (_options$signal11 = options.signal) !== null && _options$signal11 !== undefined && _options$signal11.aborted) {\n        throw new AbortError();\n      }\n      if (number-- > 0) {\n        yield val;\n      } else {\n        return;\n      }\n    }\n  }.call(this);\n}\nmodule.exports.streamReturningOperators = {\n  asIndexedPairs,\n  drop,\n  filter,\n  flatMap,\n  map,\n  take,\n  compose\n};\nmodule.exports.promiseReturningOperators = {\n  every,\n  forEach,\n  reduce,\n  toArray,\n  some,\n  find\n};","map":{"version":3,"names":["AbortController","globalThis","require","codes","ERR_INVALID_ARG_VALUE","ERR_INVALID_ARG_TYPE","ERR_MISSING_ARGS","ERR_OUT_OF_RANGE","AbortError","validateAbortSignal","validateInteger","validateObject","kWeakHandler","Symbol","finished","staticCompose","addAbortSignalNoValidate","isWritable","isNodeStream","ArrayPrototypePush","MathFloor","Number","NumberIsNaN","Promise","PromiseReject","PromisePrototypeThen","kEmpty","kEof","compose","stream","options","undefined","signal","composedStream","map","fn","concurrency","_options$signal","_options$signal2","ac","queue","signalOpt","abort","aborted","addEventListener","next","resume","done","onDone","pump","val","_val","err","catch","push","length","resolve","_options$signal3","removeEventListener","shift","call","asIndexedPairs","index","_options$signal4","cause","reason","some","unused","filter","every","args","find","result","forEach","forEachFn","value","filterFn","ReduceAwareErrMissingArgs","constructor","message","reduce","reducer","initialValue","_options$signal5","hasInitialValue","arguments","once","destroy","opts","gotAnyItemFromStream","_options$signal6","toArray","_options$signal7","flatMap","values","toIntegerOrInfinity","number","drop","_options$signal8","_options$signal9","take","_options$signal10","_options$signal11","module","exports","streamReturningOperators","promiseReturningOperators"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@toruslabs/base-controllers/node_modules/readable-stream/lib/internal/streams/operators.js"],"sourcesContent":["'use strict'\n\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController\nconst {\n  codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },\n  AbortError\n} = require('../../ours/errors')\nconst { validateAbortSignal, validateInteger, validateObject } = require('../validators')\nconst kWeakHandler = require('../../ours/primordials').Symbol('kWeak')\nconst { finished } = require('./end-of-stream')\nconst staticCompose = require('./compose')\nconst { addAbortSignalNoValidate } = require('./add-abort-signal')\nconst { isWritable, isNodeStream } = require('./utils')\nconst {\n  ArrayPrototypePush,\n  MathFloor,\n  Number,\n  NumberIsNaN,\n  Promise,\n  PromiseReject,\n  PromisePrototypeThen,\n  Symbol\n} = require('../../ours/primordials')\nconst kEmpty = Symbol('kEmpty')\nconst kEof = Symbol('kEof')\nfunction compose(stream, options) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  if (isNodeStream(stream) && !isWritable(stream)) {\n    throw new ERR_INVALID_ARG_VALUE('stream', stream, 'must be writable')\n  }\n  const composedStream = staticCompose(this, stream)\n  if (options !== null && options !== undefined && options.signal) {\n    // Not validating as we already validated before\n    addAbortSignalNoValidate(options.signal, composedStream)\n  }\n  return composedStream\n}\nfunction map(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  let concurrency = 1\n  if ((options === null || options === undefined ? undefined : options.concurrency) != null) {\n    concurrency = MathFloor(options.concurrency)\n  }\n  validateInteger(concurrency, 'concurrency', 1)\n  return async function* map() {\n    var _options$signal, _options$signal2\n    const ac = new AbortController()\n    const stream = this\n    const queue = []\n    const signal = ac.signal\n    const signalOpt = {\n      signal\n    }\n    const abort = () => ac.abort()\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal = options.signal) !== null &&\n      _options$signal !== undefined &&\n      _options$signal.aborted\n    ) {\n      abort()\n    }\n    options === null || options === undefined\n      ? undefined\n      : (_options$signal2 = options.signal) === null || _options$signal2 === undefined\n      ? undefined\n      : _options$signal2.addEventListener('abort', abort)\n    let next\n    let resume\n    let done = false\n    function onDone() {\n      done = true\n    }\n    async function pump() {\n      try {\n        for await (let val of stream) {\n          var _val\n          if (done) {\n            return\n          }\n          if (signal.aborted) {\n            throw new AbortError()\n          }\n          try {\n            val = fn(val, signalOpt)\n          } catch (err) {\n            val = PromiseReject(err)\n          }\n          if (val === kEmpty) {\n            continue\n          }\n          if (typeof ((_val = val) === null || _val === undefined ? undefined : _val.catch) === 'function') {\n            val.catch(onDone)\n          }\n          queue.push(val)\n          if (next) {\n            next()\n            next = null\n          }\n          if (!done && queue.length && queue.length >= concurrency) {\n            await new Promise((resolve) => {\n              resume = resolve\n            })\n          }\n        }\n        queue.push(kEof)\n      } catch (err) {\n        const val = PromiseReject(err)\n        PromisePrototypeThen(val, undefined, onDone)\n        queue.push(val)\n      } finally {\n        var _options$signal3\n        done = true\n        if (next) {\n          next()\n          next = null\n        }\n        options === null || options === undefined\n          ? undefined\n          : (_options$signal3 = options.signal) === null || _options$signal3 === undefined\n          ? undefined\n          : _options$signal3.removeEventListener('abort', abort)\n      }\n    }\n    pump()\n    try {\n      while (true) {\n        while (queue.length > 0) {\n          const val = await queue[0]\n          if (val === kEof) {\n            return\n          }\n          if (signal.aborted) {\n            throw new AbortError()\n          }\n          if (val !== kEmpty) {\n            yield val\n          }\n          queue.shift()\n          if (resume) {\n            resume()\n            resume = null\n          }\n        }\n        await new Promise((resolve) => {\n          next = resolve\n        })\n      }\n    } finally {\n      ac.abort()\n      done = true\n      if (resume) {\n        resume()\n        resume = null\n      }\n    }\n  }.call(this)\n}\nfunction asIndexedPairs(options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  return async function* asIndexedPairs() {\n    let index = 0\n    for await (const val of this) {\n      var _options$signal4\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal4 = options.signal) !== null &&\n        _options$signal4 !== undefined &&\n        _options$signal4.aborted\n      ) {\n        throw new AbortError({\n          cause: options.signal.reason\n        })\n      }\n      yield [index++, val]\n    }\n  }.call(this)\n}\nasync function some(fn, options = undefined) {\n  for await (const unused of filter.call(this, fn, options)) {\n    return true\n  }\n  return false\n}\nasync function every(fn, options = undefined) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  // https://en.wikipedia.org/wiki/De_Morgan%27s_laws\n  return !(await some.call(\n    this,\n    async (...args) => {\n      return !(await fn(...args))\n    },\n    options\n  ))\n}\nasync function find(fn, options) {\n  for await (const result of filter.call(this, fn, options)) {\n    return result\n  }\n  return undefined\n}\nasync function forEach(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  async function forEachFn(value, options) {\n    await fn(value, options)\n    return kEmpty\n  }\n  // eslint-disable-next-line no-unused-vars\n  for await (const unused of map.call(this, forEachFn, options));\n}\nfunction filter(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  async function filterFn(value, options) {\n    if (await fn(value, options)) {\n      return value\n    }\n    return kEmpty\n  }\n  return map.call(this, filterFn, options)\n}\n\n// Specific to provide better error to reduce since the argument is only\n// missing if the stream has no items in it - but the code is still appropriate\nclass ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {\n  constructor() {\n    super('reduce')\n    this.message = 'Reduce of an empty stream requires an initial value'\n  }\n}\nasync function reduce(reducer, initialValue, options) {\n  var _options$signal5\n  if (typeof reducer !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('reducer', ['Function', 'AsyncFunction'], reducer)\n  }\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  let hasInitialValue = arguments.length > 1\n  if (\n    options !== null &&\n    options !== undefined &&\n    (_options$signal5 = options.signal) !== null &&\n    _options$signal5 !== undefined &&\n    _options$signal5.aborted\n  ) {\n    const err = new AbortError(undefined, {\n      cause: options.signal.reason\n    })\n    this.once('error', () => {}) // The error is already propagated\n    await finished(this.destroy(err))\n    throw err\n  }\n  const ac = new AbortController()\n  const signal = ac.signal\n  if (options !== null && options !== undefined && options.signal) {\n    const opts = {\n      once: true,\n      [kWeakHandler]: this\n    }\n    options.signal.addEventListener('abort', () => ac.abort(), opts)\n  }\n  let gotAnyItemFromStream = false\n  try {\n    for await (const value of this) {\n      var _options$signal6\n      gotAnyItemFromStream = true\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal6 = options.signal) !== null &&\n        _options$signal6 !== undefined &&\n        _options$signal6.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (!hasInitialValue) {\n        initialValue = value\n        hasInitialValue = true\n      } else {\n        initialValue = await reducer(initialValue, value, {\n          signal\n        })\n      }\n    }\n    if (!gotAnyItemFromStream && !hasInitialValue) {\n      throw new ReduceAwareErrMissingArgs()\n    }\n  } finally {\n    ac.abort()\n  }\n  return initialValue\n}\nasync function toArray(options) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  const result = []\n  for await (const val of this) {\n    var _options$signal7\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal7 = options.signal) !== null &&\n      _options$signal7 !== undefined &&\n      _options$signal7.aborted\n    ) {\n      throw new AbortError(undefined, {\n        cause: options.signal.reason\n      })\n    }\n    ArrayPrototypePush(result, val)\n  }\n  return result\n}\nfunction flatMap(fn, options) {\n  const values = map.call(this, fn, options)\n  return async function* flatMap() {\n    for await (const val of values) {\n      yield* val\n    }\n  }.call(this)\n}\nfunction toIntegerOrInfinity(number) {\n  // We coerce here to align with the spec\n  // https://github.com/tc39/proposal-iterator-helpers/issues/169\n  number = Number(number)\n  if (NumberIsNaN(number)) {\n    return 0\n  }\n  if (number < 0) {\n    throw new ERR_OUT_OF_RANGE('number', '>= 0', number)\n  }\n  return number\n}\nfunction drop(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  number = toIntegerOrInfinity(number)\n  return async function* drop() {\n    var _options$signal8\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal8 = options.signal) !== null &&\n      _options$signal8 !== undefined &&\n      _options$signal8.aborted\n    ) {\n      throw new AbortError()\n    }\n    for await (const val of this) {\n      var _options$signal9\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal9 = options.signal) !== null &&\n        _options$signal9 !== undefined &&\n        _options$signal9.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (number-- <= 0) {\n        yield val\n      }\n    }\n  }.call(this)\n}\nfunction take(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  number = toIntegerOrInfinity(number)\n  return async function* take() {\n    var _options$signal10\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal10 = options.signal) !== null &&\n      _options$signal10 !== undefined &&\n      _options$signal10.aborted\n    ) {\n      throw new AbortError()\n    }\n    for await (const val of this) {\n      var _options$signal11\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal11 = options.signal) !== null &&\n        _options$signal11 !== undefined &&\n        _options$signal11.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (number-- > 0) {\n        yield val\n      } else {\n        return\n      }\n    }\n  }.call(this)\n}\nmodule.exports.streamReturningOperators = {\n  asIndexedPairs,\n  drop,\n  filter,\n  flatMap,\n  map,\n  take,\n  compose\n}\nmodule.exports.promiseReturningOperators = {\n  every,\n  forEach,\n  reduce,\n  toArray,\n  some,\n  find\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}