{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AccountStore = exports.AccountsResolver = void 0;\nconst camelcase_1 = __importDefault(require(\"camelcase\"));\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst utf8 = __importStar(require(\"../utils/bytes/utf8.js\"));\nconst token_js_1 = require(\"../utils/token.js\");\nconst token_1 = require(\"../spl/token\");\n// Populates a given accounts context with PDAs and common missing accounts.\nclass AccountsResolver {\n  constructor(_args, _accounts, _provider, _programId, _idlIx, _accountNamespace) {\n    this._args = _args;\n    this._accounts = _accounts;\n    this._provider = _provider;\n    this._programId = _programId;\n    this._idlIx = _idlIx;\n    this._accountStore = new AccountStore(_provider, _accountNamespace);\n  }\n  // Note: We serially resolve PDAs one by one rather than doing them\n  //       in parallel because there can be dependencies between\n  //       addresses. That is, one PDA can be used as a seed in another.\n  //\n  // TODO: PDAs need to be resolved in topological order. For now, we\n  //       require the developer to simply list the accounts in the\n  //       correct order. But in future work, we should create the\n  //       dependency graph and resolve automatically.\n  //\n  async resolve() {\n    for (let k = 0; k < this._idlIx.accounts.length; k += 1) {\n      // Cast is ok because only a non-nested IdlAccount can have a seeds\n      // cosntraint.\n      const accountDesc = this._idlIx.accounts[k];\n      const accountDescName = (0, camelcase_1.default)(accountDesc.name);\n      // PDA derived from IDL seeds.\n      if (accountDesc.pda && accountDesc.pda.seeds.length > 0 && !this._accounts[accountDescName]) {\n        await this.autoPopulatePda(accountDesc);\n        continue;\n      }\n      // Signers default to the provider.\n      if (accountDesc.isSigner && !this._accounts[accountDescName]) {\n        // @ts-expect-error\n        if (this._provider.wallet === undefined) {\n          throw new Error(\"This function requires the Provider interface implementor to have a 'wallet' field.\");\n        }\n        // @ts-expect-error\n        this._accounts[accountDescName] = this._provider.wallet.publicKey;\n        continue;\n      }\n      // Common accounts are auto populated with magic names by convention.\n      if (Reflect.has(AccountsResolver.CONST_ACCOUNTS, accountDescName) && !this._accounts[accountDescName]) {\n        this._accounts[accountDescName] = AccountsResolver.CONST_ACCOUNTS[accountDescName];\n      }\n    }\n  }\n  async autoPopulatePda(accountDesc) {\n    if (!accountDesc.pda || !accountDesc.pda.seeds) throw new Error(\"Must have seeds\");\n    const seeds = await Promise.all(accountDesc.pda.seeds.map(seedDesc => this.toBuffer(seedDesc)));\n    const programId = await this.parseProgramId(accountDesc);\n    const [pubkey] = await web3_js_1.PublicKey.findProgramAddress(seeds, programId);\n    this._accounts[(0, camelcase_1.default)(accountDesc.name)] = pubkey;\n  }\n  async parseProgramId(accountDesc) {\n    var _a;\n    if (!((_a = accountDesc.pda) === null || _a === void 0 ? void 0 : _a.programId)) {\n      return this._programId;\n    }\n    switch (accountDesc.pda.programId.kind) {\n      case \"const\":\n        return new web3_js_1.PublicKey(this.toBufferConst(accountDesc.pda.programId.value));\n      case \"arg\":\n        return this.argValue(accountDesc.pda.programId);\n      case \"account\":\n        return await this.accountValue(accountDesc.pda.programId);\n      default:\n        throw new Error(`Unexpected program seed kind: ${accountDesc.pda.programId.kind}`);\n    }\n  }\n  async toBuffer(seedDesc) {\n    switch (seedDesc.kind) {\n      case \"const\":\n        return this.toBufferConst(seedDesc);\n      case \"arg\":\n        return await this.toBufferArg(seedDesc);\n      case \"account\":\n        return await this.toBufferAccount(seedDesc);\n      default:\n        throw new Error(`Unexpected seed kind: ${seedDesc.kind}`);\n    }\n  }\n  toBufferConst(seedDesc) {\n    return this.toBufferValue(seedDesc.type, seedDesc.value);\n  }\n  async toBufferArg(seedDesc) {\n    const argValue = this.argValue(seedDesc);\n    return this.toBufferValue(seedDesc.type, argValue);\n  }\n  argValue(seedDesc) {\n    const seedArgName = (0, camelcase_1.default)(seedDesc.path.split(\".\")[0]);\n    const idlArgPosition = this._idlIx.args.findIndex(argDesc => argDesc.name === seedArgName);\n    if (idlArgPosition === -1) {\n      throw new Error(`Unable to find argument for seed: ${seedArgName}`);\n    }\n    return this._args[idlArgPosition];\n  }\n  async toBufferAccount(seedDesc) {\n    const accountValue = await this.accountValue(seedDesc);\n    return this.toBufferValue(seedDesc.type, accountValue);\n  }\n  async accountValue(seedDesc) {\n    const pathComponents = seedDesc.path.split(\".\");\n    const fieldName = pathComponents[0];\n    const fieldPubkey = this._accounts[(0, camelcase_1.default)(fieldName)];\n    // The seed is a pubkey of the account.\n    if (pathComponents.length === 1) {\n      return fieldPubkey;\n    }\n    // The key is account data.\n    //\n    // Fetch and deserialize it.\n    const account = await this._accountStore.fetchAccount(seedDesc.account, fieldPubkey);\n    // Dereference all fields in the path to get the field value\n    // used in the seed.\n    const fieldValue = this.parseAccountValue(account, pathComponents.slice(1));\n    return fieldValue;\n  }\n  parseAccountValue(account, path) {\n    let accountField;\n    while (path.length > 0) {\n      accountField = account[(0, camelcase_1.default)(path[0])];\n      path = path.slice(1);\n    }\n    return accountField;\n  }\n  // Converts the given idl valaue into a Buffer. The values here must be\n  // primitives. E.g. no structs.\n  //\n  // TODO: add more types here as needed.\n  toBufferValue(type, value) {\n    switch (type) {\n      case \"u8\":\n        return Buffer.from([value]);\n      case \"u16\":\n        let b = Buffer.alloc(2);\n        b.writeUInt16LE(value);\n        return b;\n      case \"u32\":\n        let buf = Buffer.alloc(4);\n        buf.writeUInt32LE(value);\n        return buf;\n      case \"u64\":\n        let bU64 = Buffer.alloc(8);\n        bU64.writeBigUInt64LE(BigInt(value));\n        return bU64;\n      case \"string\":\n        return Buffer.from(utf8.encode(value));\n      case \"publicKey\":\n        return value.toBuffer();\n      default:\n        if (type.array) {\n          return Buffer.from(value);\n        }\n        throw new Error(`Unexpected seed type: ${type}`);\n    }\n  }\n}\nexports.AccountsResolver = AccountsResolver;\nAccountsResolver.CONST_ACCOUNTS = {\n  systemProgram: web3_js_1.SystemProgram.programId,\n  tokenProgram: token_js_1.TOKEN_PROGRAM_ID,\n  associatedTokenProgram: token_js_1.ASSOCIATED_PROGRAM_ID,\n  rent: web3_js_1.SYSVAR_RENT_PUBKEY\n};\n// TODO: this should be configureable to avoid unnecessary requests.\nclass AccountStore {\n  // todo: don't use the progrma use the account namespace.\n  constructor(_provider, _accounts) {\n    this._provider = _provider;\n    this._accounts = _accounts;\n    this._cache = new Map();\n  }\n  async fetchAccount(name, publicKey) {\n    const address = publicKey.toString();\n    if (!this._cache.has(address)) {\n      if (name === \"TokenAccount\") {\n        const accountInfo = await this._provider.connection.getAccountInfo(publicKey);\n        if (accountInfo === null) {\n          throw new Error(`invalid account info for ${address}`);\n        }\n        const data = (0, token_1.coder)().accounts.decode(\"token\", accountInfo.data);\n        this._cache.set(address, data);\n      } else {\n        const account = this._accounts[(0, camelcase_1.default)(name)].fetch(publicKey);\n        this._cache.set(address, account);\n      }\n    }\n    return this._cache.get(address);\n  }\n}\nexports.AccountStore = AccountStore;","map":{"version":3,"names":["camelcase_1","__importDefault","require","web3_js_1","utf8","__importStar","token_js_1","token_1","AccountsResolver","constructor","_args","_accounts","_provider","_programId","_idlIx","_accountNamespace","_accountStore","AccountStore","resolve","k","accounts","length","accountDesc","accountDescName","default","name","pda","seeds","autoPopulatePda","isSigner","wallet","undefined","Error","publicKey","Reflect","has","CONST_ACCOUNTS","Promise","all","map","seedDesc","toBuffer","programId","parseProgramId","pubkey","PublicKey","findProgramAddress","_a","kind","toBufferConst","value","argValue","accountValue","toBufferArg","toBufferAccount","toBufferValue","type","seedArgName","path","split","idlArgPosition","args","findIndex","argDesc","pathComponents","fieldName","fieldPubkey","account","fetchAccount","fieldValue","parseAccountValue","slice","accountField","Buffer","from","b","alloc","writeUInt16LE","buf","writeUInt32LE","bU64","writeBigUInt64LE","BigInt","encode","array","exports","systemProgram","SystemProgram","tokenProgram","TOKEN_PROGRAM_ID","associatedTokenProgram","ASSOCIATED_PROGRAM_ID","rent","SYSVAR_RENT_PUBKEY","_cache","Map","address","toString","accountInfo","connection","getAccountInfo","data","coder","decode","set","fetch","get"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/program/accounts-resolver.ts"],"sourcesContent":["import camelCase from \"camelcase\";\nimport { PublicKey, SystemProgram, SYSVAR_RENT_PUBKEY } from \"@solana/web3.js\";\nimport { Idl, IdlSeed, IdlAccount } from \"../idl.js\";\nimport * as utf8 from \"../utils/bytes/utf8.js\";\nimport { TOKEN_PROGRAM_ID, ASSOCIATED_PROGRAM_ID } from \"../utils/token.js\";\nimport { AllInstructions } from \"./namespace/types.js\";\nimport Provider from \"../provider.js\";\nimport { AccountNamespace } from \"./namespace/account.js\";\nimport { coder } from \"../spl/token\";\n\n// Populates a given accounts context with PDAs and common missing accounts.\nexport class AccountsResolver<IDL extends Idl, I extends AllInstructions<IDL>> {\n  static readonly CONST_ACCOUNTS = {\n    systemProgram: SystemProgram.programId,\n    tokenProgram: TOKEN_PROGRAM_ID,\n    associatedTokenProgram: ASSOCIATED_PROGRAM_ID,\n    rent: SYSVAR_RENT_PUBKEY,\n  };\n\n  private _accountStore: AccountStore<IDL>;\n\n  constructor(\n    private _args: Array<any>,\n    private _accounts: { [name: string]: PublicKey },\n    private _provider: Provider,\n    private _programId: PublicKey,\n    private _idlIx: AllInstructions<IDL>,\n    _accountNamespace: AccountNamespace<IDL>\n  ) {\n    this._accountStore = new AccountStore(_provider, _accountNamespace);\n  }\n\n  // Note: We serially resolve PDAs one by one rather than doing them\n  //       in parallel because there can be dependencies between\n  //       addresses. That is, one PDA can be used as a seed in another.\n  //\n  // TODO: PDAs need to be resolved in topological order. For now, we\n  //       require the developer to simply list the accounts in the\n  //       correct order. But in future work, we should create the\n  //       dependency graph and resolve automatically.\n  //\n  public async resolve() {\n    for (let k = 0; k < this._idlIx.accounts.length; k += 1) {\n      // Cast is ok because only a non-nested IdlAccount can have a seeds\n      // cosntraint.\n      const accountDesc = this._idlIx.accounts[k] as IdlAccount;\n      const accountDescName = camelCase(accountDesc.name);\n\n      // PDA derived from IDL seeds.\n      if (\n        accountDesc.pda &&\n        accountDesc.pda.seeds.length > 0 &&\n        !this._accounts[accountDescName]\n      ) {\n        await this.autoPopulatePda(accountDesc);\n        continue;\n      }\n\n      // Signers default to the provider.\n      if (accountDesc.isSigner && !this._accounts[accountDescName]) {\n        // @ts-expect-error\n        if (this._provider.wallet === undefined) {\n          throw new Error(\n            \"This function requires the Provider interface implementor to have a 'wallet' field.\"\n          );\n        }\n        // @ts-expect-error\n        this._accounts[accountDescName] = this._provider.wallet.publicKey;\n        continue;\n      }\n\n      // Common accounts are auto populated with magic names by convention.\n      if (\n        Reflect.has(AccountsResolver.CONST_ACCOUNTS, accountDescName) &&\n        !this._accounts[accountDescName]\n      ) {\n        this._accounts[accountDescName] =\n          AccountsResolver.CONST_ACCOUNTS[accountDescName];\n      }\n    }\n  }\n\n  private async autoPopulatePda(accountDesc: IdlAccount) {\n    if (!accountDesc.pda || !accountDesc.pda.seeds)\n      throw new Error(\"Must have seeds\");\n\n    const seeds: Buffer[] = await Promise.all(\n      accountDesc.pda.seeds.map((seedDesc: IdlSeed) => this.toBuffer(seedDesc))\n    );\n\n    const programId = await this.parseProgramId(accountDesc);\n    const [pubkey] = await PublicKey.findProgramAddress(seeds, programId);\n\n    this._accounts[camelCase(accountDesc.name)] = pubkey;\n  }\n\n  private async parseProgramId(accountDesc: IdlAccount): Promise<PublicKey> {\n    if (!accountDesc.pda?.programId) {\n      return this._programId;\n    }\n    switch (accountDesc.pda.programId.kind) {\n      case \"const\":\n        return new PublicKey(\n          this.toBufferConst(accountDesc.pda.programId.value)\n        );\n      case \"arg\":\n        return this.argValue(accountDesc.pda.programId);\n      case \"account\":\n        return await this.accountValue(accountDesc.pda.programId);\n      default:\n        throw new Error(\n          `Unexpected program seed kind: ${accountDesc.pda.programId.kind}`\n        );\n    }\n  }\n\n  private async toBuffer(seedDesc: IdlSeed): Promise<Buffer> {\n    switch (seedDesc.kind) {\n      case \"const\":\n        return this.toBufferConst(seedDesc);\n      case \"arg\":\n        return await this.toBufferArg(seedDesc);\n      case \"account\":\n        return await this.toBufferAccount(seedDesc);\n      default:\n        throw new Error(`Unexpected seed kind: ${seedDesc.kind}`);\n    }\n  }\n\n  private toBufferConst(seedDesc: IdlSeed): Buffer {\n    return this.toBufferValue(seedDesc.type, seedDesc.value);\n  }\n\n  private async toBufferArg(seedDesc: IdlSeed): Promise<Buffer> {\n    const argValue = this.argValue(seedDesc);\n    return this.toBufferValue(seedDesc.type, argValue);\n  }\n\n  private argValue(seedDesc: IdlSeed): any {\n    const seedArgName = camelCase(seedDesc.path.split(\".\")[0]);\n\n    const idlArgPosition = this._idlIx.args.findIndex(\n      (argDesc: any) => argDesc.name === seedArgName\n    );\n    if (idlArgPosition === -1) {\n      throw new Error(`Unable to find argument for seed: ${seedArgName}`);\n    }\n\n    return this._args[idlArgPosition];\n  }\n\n  private async toBufferAccount(seedDesc: IdlSeed): Promise<Buffer> {\n    const accountValue = await this.accountValue(seedDesc);\n    return this.toBufferValue(seedDesc.type, accountValue);\n  }\n\n  private async accountValue(seedDesc: IdlSeed): Promise<any> {\n    const pathComponents = seedDesc.path.split(\".\");\n\n    const fieldName = pathComponents[0];\n    const fieldPubkey = this._accounts[camelCase(fieldName)];\n\n    // The seed is a pubkey of the account.\n    if (pathComponents.length === 1) {\n      return fieldPubkey;\n    }\n\n    // The key is account data.\n    //\n    // Fetch and deserialize it.\n    const account = await this._accountStore.fetchAccount(\n      seedDesc.account,\n      fieldPubkey\n    );\n\n    // Dereference all fields in the path to get the field value\n    // used in the seed.\n    const fieldValue = this.parseAccountValue(account, pathComponents.slice(1));\n    return fieldValue;\n  }\n\n  private parseAccountValue<T = any>(account: T, path: Array<string>): any {\n    let accountField: any;\n    while (path.length > 0) {\n      accountField = account[camelCase(path[0])];\n      path = path.slice(1);\n    }\n    return accountField;\n  }\n\n  // Converts the given idl valaue into a Buffer. The values here must be\n  // primitives. E.g. no structs.\n  //\n  // TODO: add more types here as needed.\n  private toBufferValue(type: string | any, value: any): Buffer {\n    switch (type) {\n      case \"u8\":\n        return Buffer.from([value]);\n      case \"u16\":\n        let b = Buffer.alloc(2);\n        b.writeUInt16LE(value);\n        return b;\n      case \"u32\":\n        let buf = Buffer.alloc(4);\n        buf.writeUInt32LE(value);\n        return buf;\n      case \"u64\":\n        let bU64 = Buffer.alloc(8);\n        bU64.writeBigUInt64LE(BigInt(value));\n        return bU64;\n      case \"string\":\n        return Buffer.from(utf8.encode(value));\n      case \"publicKey\":\n        return value.toBuffer();\n      default:\n        if (type.array) {\n          return Buffer.from(value);\n        }\n        throw new Error(`Unexpected seed type: ${type}`);\n    }\n  }\n}\n\n// TODO: this should be configureable to avoid unnecessary requests.\nexport class AccountStore<IDL extends Idl> {\n  private _cache = new Map<string, any>();\n\n  // todo: don't use the progrma use the account namespace.\n  constructor(\n    private _provider: Provider,\n    private _accounts: AccountNamespace<IDL>\n  ) {}\n\n  public async fetchAccount<T = any>(\n    name: string,\n    publicKey: PublicKey\n  ): Promise<T> {\n    const address = publicKey.toString();\n    if (!this._cache.has(address)) {\n      if (name === \"TokenAccount\") {\n        const accountInfo = await this._provider.connection.getAccountInfo(\n          publicKey\n        );\n        if (accountInfo === null) {\n          throw new Error(`invalid account info for ${address}`);\n        }\n        const data = coder().accounts.decode(\"token\", accountInfo.data);\n        this._cache.set(address, data);\n      } else {\n        const account = this._accounts[camelCase(name)].fetch(publicKey);\n        this._cache.set(address, account);\n      }\n    }\n    return this._cache.get(address);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}