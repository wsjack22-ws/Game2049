{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Withdrawal = void 0;\nconst address_1 = require(\"./address\");\nconst bytes_1 = require(\"./bytes\");\nconst types_1 = require(\"./types\");\n/**\n * Representation of EIP-4895 withdrawal data\n */\nclass Withdrawal {\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating a Withdrawal object from varying data types.\n   * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot\n   */\n  constructor(index, validatorIndex, address,\n  /**\n   * withdrawal amount in Gwei to match the CL repesentation and eventually ssz withdrawalsRoot\n   */\n  amount) {\n    this.index = index;\n    this.validatorIndex = validatorIndex;\n    this.address = address;\n    this.amount = amount;\n  }\n  static fromWithdrawalData(withdrawalData) {\n    const {\n      index: indexData,\n      validatorIndex: validatorIndexData,\n      address: addressData,\n      amount: amountData\n    } = withdrawalData;\n    const index = (0, types_1.toType)(indexData, types_1.TypeOutput.BigInt);\n    const validatorIndex = (0, types_1.toType)(validatorIndexData, types_1.TypeOutput.BigInt);\n    const address = new address_1.Address((0, types_1.toType)(addressData, types_1.TypeOutput.Buffer));\n    const amount = (0, types_1.toType)(amountData, types_1.TypeOutput.BigInt);\n    return new Withdrawal(index, validatorIndex, address, amount);\n  }\n  static fromValuesArray(withdrawalArray) {\n    if (withdrawalArray.length !== 4) {\n      throw Error(`Invalid withdrawalArray length expected=4 actual=${withdrawalArray.length}`);\n    }\n    const [index, validatorIndex, address, amount] = withdrawalArray;\n    return Withdrawal.fromWithdrawalData({\n      index,\n      validatorIndex,\n      address,\n      amount\n    });\n  }\n  /**\n   * Convert a withdrawal to a buffer array\n   * @param withdrawal the withdrawal to convert\n   * @returns buffer array of the withdrawal\n   */\n  static toBufferArray(withdrawal) {\n    const {\n      index,\n      validatorIndex,\n      address,\n      amount\n    } = withdrawal;\n    const indexBuffer = (0, types_1.toType)(index, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(index, types_1.TypeOutput.Buffer);\n    const validatorIndexBuffer = (0, types_1.toType)(validatorIndex, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(validatorIndex, types_1.TypeOutput.Buffer);\n    let addressBuffer;\n    if (address instanceof address_1.Address) {\n      addressBuffer = address.buf;\n    } else {\n      addressBuffer = (0, types_1.toType)(address, types_1.TypeOutput.Buffer);\n    }\n    const amountBuffer = (0, types_1.toType)(amount, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(amount, types_1.TypeOutput.Buffer);\n    return [indexBuffer, validatorIndexBuffer, addressBuffer, amountBuffer];\n  }\n  raw() {\n    return Withdrawal.toBufferArray(this);\n  }\n  toValue() {\n    return {\n      index: this.index,\n      validatorIndex: this.validatorIndex,\n      address: this.address.buf,\n      amount: this.amount\n    };\n  }\n  toJSON() {\n    return {\n      index: (0, bytes_1.bigIntToHex)(this.index),\n      validatorIndex: (0, bytes_1.bigIntToHex)(this.validatorIndex),\n      address: '0x' + this.address.buf.toString('hex'),\n      amount: (0, bytes_1.bigIntToHex)(this.amount)\n    };\n  }\n}\nexports.Withdrawal = Withdrawal;","map":{"version":3,"names":["address_1","require","bytes_1","types_1","Withdrawal","constructor","index","validatorIndex","address","amount","fromWithdrawalData","withdrawalData","indexData","validatorIndexData","addressData","amountData","toType","TypeOutput","BigInt","Address","Buffer","fromValuesArray","withdrawalArray","length","Error","toBufferArray","withdrawal","indexBuffer","alloc","validatorIndexBuffer","addressBuffer","buf","amountBuffer","raw","toValue","toJSON","bigIntToHex","toString","exports"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@ethereumjs/util/src/withdrawal.ts"],"sourcesContent":["import { Address } from './address'\nimport { bigIntToHex } from './bytes'\nimport { TypeOutput, toType } from './types'\n\nimport type { AddressLike, BigIntLike } from './types'\n\n/**\n * Flexible input data type for EIP-4895 withdrawal data with amount in Gwei to\n * match CL representation and for eventual ssz withdrawalsRoot\n */\nexport type WithdrawalData = {\n  index: BigIntLike\n  validatorIndex: BigIntLike\n  address: AddressLike\n  amount: BigIntLike\n}\n\n/**\n * JSON RPC interface for EIP-4895 withdrawal data with amount in Gwei to\n * match CL representation and for eventual ssz withdrawalsRoot\n */\nexport interface JsonRpcWithdrawal {\n  index: string // QUANTITY - bigint 8 bytes\n  validatorIndex: string // QUANTITY - bigint 8 bytes\n  address: string // DATA, 20 Bytes  address to withdraw to\n  amount: string // QUANTITY - bigint amount in Gwei 8 bytes\n}\n\nexport type WithdrawalBuffer = [Buffer, Buffer, Buffer, Buffer]\n\n/**\n * Representation of EIP-4895 withdrawal data\n */\nexport class Withdrawal {\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating a Withdrawal object from varying data types.\n   * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot\n   */\n  constructor(\n    public readonly index: bigint,\n    public readonly validatorIndex: bigint,\n    public readonly address: Address,\n    /**\n     * withdrawal amount in Gwei to match the CL repesentation and eventually ssz withdrawalsRoot\n     */\n    public readonly amount: bigint\n  ) {}\n\n  public static fromWithdrawalData(withdrawalData: WithdrawalData) {\n    const {\n      index: indexData,\n      validatorIndex: validatorIndexData,\n      address: addressData,\n      amount: amountData,\n    } = withdrawalData\n    const index = toType(indexData, TypeOutput.BigInt)\n    const validatorIndex = toType(validatorIndexData, TypeOutput.BigInt)\n    const address = new Address(toType(addressData, TypeOutput.Buffer))\n    const amount = toType(amountData, TypeOutput.BigInt)\n\n    return new Withdrawal(index, validatorIndex, address, amount)\n  }\n\n  public static fromValuesArray(withdrawalArray: WithdrawalBuffer) {\n    if (withdrawalArray.length !== 4) {\n      throw Error(`Invalid withdrawalArray length expected=4 actual=${withdrawalArray.length}`)\n    }\n    const [index, validatorIndex, address, amount] = withdrawalArray\n    return Withdrawal.fromWithdrawalData({ index, validatorIndex, address, amount })\n  }\n\n  /**\n   * Convert a withdrawal to a buffer array\n   * @param withdrawal the withdrawal to convert\n   * @returns buffer array of the withdrawal\n   */\n  public static toBufferArray(withdrawal: Withdrawal | WithdrawalData): WithdrawalBuffer {\n    const { index, validatorIndex, address, amount } = withdrawal\n    const indexBuffer =\n      toType(index, TypeOutput.BigInt) === BigInt(0)\n        ? Buffer.alloc(0)\n        : toType(index, TypeOutput.Buffer)\n    const validatorIndexBuffer =\n      toType(validatorIndex, TypeOutput.BigInt) === BigInt(0)\n        ? Buffer.alloc(0)\n        : toType(validatorIndex, TypeOutput.Buffer)\n    let addressBuffer\n    if (address instanceof Address) {\n      addressBuffer = (<Address>address).buf\n    } else {\n      addressBuffer = toType(address, TypeOutput.Buffer)\n    }\n    const amountBuffer =\n      toType(amount, TypeOutput.BigInt) === BigInt(0)\n        ? Buffer.alloc(0)\n        : toType(amount, TypeOutput.Buffer)\n\n    return [indexBuffer, validatorIndexBuffer, addressBuffer, amountBuffer]\n  }\n\n  raw() {\n    return Withdrawal.toBufferArray(this)\n  }\n\n  toValue() {\n    return {\n      index: this.index,\n      validatorIndex: this.validatorIndex,\n      address: this.address.buf,\n      amount: this.amount,\n    }\n  }\n\n  toJSON() {\n    return {\n      index: bigIntToHex(this.index),\n      validatorIndex: bigIntToHex(this.validatorIndex),\n      address: '0x' + this.address.buf.toString('hex'),\n      amount: bigIntToHex(this.amount),\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}