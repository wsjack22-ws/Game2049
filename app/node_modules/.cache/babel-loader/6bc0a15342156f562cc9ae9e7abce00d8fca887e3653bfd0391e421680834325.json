{"ast":null,"code":"import { snakeCase } from \"snake-case\";\nimport { sha256 } from \"js-sha256\";\nimport { IdlError } from \"../error\";\nexport function accountSize(idl, idlAccount) {\n  if (idlAccount.type.kind === \"enum\") {\n    let variantSizes = idlAccount.type.variants.map(variant => {\n      if (variant.fields === undefined) {\n        return 0;\n      }\n      return variant.fields.map(f => {\n        if (!(typeof f === \"object\" && \"name\" in f)) {\n          throw new Error(\"Tuple enum variants not yet implemented.\");\n        }\n        return typeSize(idl, f.type);\n      }).reduce((a, b) => a + b);\n    });\n    return Math.max(...variantSizes) + 1;\n  }\n  if (idlAccount.type.fields === undefined) {\n    return 0;\n  }\n  return idlAccount.type.fields.map(f => typeSize(idl, f.type)).reduce((a, b) => a + b, 0);\n}\n// Returns the size of the type in bytes. For variable length types, just return\n// 1. Users should override this value in such cases.\nfunction typeSize(idl, ty) {\n  var _a, _b;\n  switch (ty) {\n    case \"bool\":\n      return 1;\n    case \"u8\":\n      return 1;\n    case \"i8\":\n      return 1;\n    case \"i16\":\n      return 2;\n    case \"u16\":\n      return 2;\n    case \"u32\":\n      return 4;\n    case \"i32\":\n      return 4;\n    case \"u64\":\n      return 8;\n    case \"i64\":\n      return 8;\n    case \"u128\":\n      return 16;\n    case \"i128\":\n      return 16;\n    case \"bytes\":\n      return 1;\n    case \"string\":\n      return 1;\n    case \"publicKey\":\n      return 32;\n    default:\n      if (\"vec\" in ty) {\n        return 1;\n      }\n      if (\"option\" in ty) {\n        return 1 + typeSize(idl, ty.option);\n      }\n      if (\"defined\" in ty) {\n        const filtered = (_b = (_a = idl.types) === null || _a === void 0 ? void 0 : _a.filter(t => t.name === ty.defined)) !== null && _b !== void 0 ? _b : [];\n        if (filtered.length !== 1) {\n          throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);\n        }\n        let typeDef = filtered[0];\n        return accountSize(idl, typeDef);\n      }\n      if (\"array\" in ty) {\n        let arrayTy = ty.array[0];\n        let arraySize = ty.array[1];\n        return typeSize(idl, arrayTy) * arraySize;\n      }\n      throw new Error(`Invalid type ${JSON.stringify(ty)}`);\n  }\n}\n// Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\nexport function sighash(nameSpace, ixName) {\n  let name = snakeCase(ixName);\n  let preimage = `${nameSpace}:${name}`;\n  return Buffer.from(sha256.digest(preimage)).slice(0, 8);\n}","map":{"version":3,"names":["snakeCase","sha256","IdlError","accountSize","idl","idlAccount","type","kind","variantSizes","variants","map","variant","fields","undefined","f","Error","typeSize","reduce","a","b","Math","max","ty","option","filtered","_b","_a","types","filter","t","name","defined","length","JSON","stringify","typeDef","arrayTy","array","arraySize","sighash","nameSpace","ixName","preimage","Buffer","from","digest","slice"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/coder/common.ts"],"sourcesContent":["import { snakeCase } from \"snake-case\";\nimport { sha256 } from \"js-sha256\";\nimport { Idl, IdlField, IdlTypeDef, IdlEnumVariant, IdlType } from \"../idl\";\nimport { IdlError } from \"../error\";\n\nexport function accountSize(idl: Idl, idlAccount: IdlTypeDef): number {\n  if (idlAccount.type.kind === \"enum\") {\n    let variantSizes = idlAccount.type.variants.map(\n      (variant: IdlEnumVariant) => {\n        if (variant.fields === undefined) {\n          return 0;\n        }\n        return variant.fields\n          .map((f: IdlField | IdlType) => {\n            if (!(typeof f === \"object\" && \"name\" in f)) {\n              throw new Error(\"Tuple enum variants not yet implemented.\");\n            }\n            return typeSize(idl, f.type);\n          })\n          .reduce((a: number, b: number) => a + b);\n      }\n    );\n    return Math.max(...variantSizes) + 1;\n  }\n  if (idlAccount.type.fields === undefined) {\n    return 0;\n  }\n  return idlAccount.type.fields\n    .map((f) => typeSize(idl, f.type))\n    .reduce((a, b) => a + b, 0);\n}\n\n// Returns the size of the type in bytes. For variable length types, just return\n// 1. Users should override this value in such cases.\nfunction typeSize(idl: Idl, ty: IdlType): number {\n  switch (ty) {\n    case \"bool\":\n      return 1;\n    case \"u8\":\n      return 1;\n    case \"i8\":\n      return 1;\n    case \"i16\":\n      return 2;\n    case \"u16\":\n      return 2;\n    case \"u32\":\n      return 4;\n    case \"i32\":\n      return 4;\n    case \"u64\":\n      return 8;\n    case \"i64\":\n      return 8;\n    case \"u128\":\n      return 16;\n    case \"i128\":\n      return 16;\n    case \"bytes\":\n      return 1;\n    case \"string\":\n      return 1;\n    case \"publicKey\":\n      return 32;\n    default:\n      if (\"vec\" in ty) {\n        return 1;\n      }\n      if (\"option\" in ty) {\n        return 1 + typeSize(idl, ty.option);\n      }\n      if (\"defined\" in ty) {\n        const filtered = idl.types?.filter((t) => t.name === ty.defined) ?? [];\n        if (filtered.length !== 1) {\n          throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);\n        }\n        let typeDef = filtered[0];\n\n        return accountSize(idl, typeDef);\n      }\n      if (\"array\" in ty) {\n        let arrayTy = ty.array[0];\n        let arraySize = ty.array[1];\n        return typeSize(idl, arrayTy) * arraySize;\n      }\n      throw new Error(`Invalid type ${JSON.stringify(ty)}`);\n  }\n}\n\n// Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\nexport function sighash(nameSpace: string, ixName: string): Buffer {\n  let name = snakeCase(ixName);\n  let preimage = `${nameSpace}:${name}`;\n  return Buffer.from(sha256.digest(preimage)).slice(0, 8);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}