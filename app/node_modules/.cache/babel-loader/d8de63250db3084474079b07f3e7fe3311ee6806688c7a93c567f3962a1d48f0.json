{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { setAPIKey, setEmbedHost, post } from '@toruslabs/http-helpers';\nimport stringify from 'json-stable-stringify';\nimport { ec as ec$1 } from 'elliptic';\nimport { keccak256 as keccak256$1 } from 'ethereum-cryptography/keccak';\nimport { encrypt, getPublic, decrypt } from '@toruslabs/eccrypto';\nfunction keccak256(a) {\n  return Buffer.from(keccak256$1(a));\n}\nconst ec = new ec$1(\"secp256k1\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nclass MetadataStorageLayer {\n  // ms\n  constructor() {\n    let metadataHost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"https://metadata.tor.us\";\n    let serverTimeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    _defineProperty(this, \"metadataHost\", void 0);\n    _defineProperty(this, \"serverTimeOffset\", void 0);\n    this.metadataHost = metadataHost;\n    this.serverTimeOffset = serverTimeOffset;\n  }\n  static setAPIKey(apiKey) {\n    setAPIKey(apiKey);\n  }\n  static setEmbedHost(embedHost) {\n    setEmbedHost(embedHost);\n  }\n  generateMetadataParams(message, privateKeyHex) {\n    const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n    const setData = {\n      data: message,\n      timestamp: Math.floor(this.serverTimeOffset + Date.now() / 1000).toString(16)\n    };\n    const sig = key.sign(keccak256(Buffer.from(stringify(setData), \"utf8\")));\n    return {\n      pub_key_X: key.getPublic().getX().toString(16, 64),\n      pub_key_Y: key.getPublic().getY().toString(16, 64),\n      set_data: setData,\n      signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + (sig.recoveryParam?.toString(16).padStart(2, \"0\").slice(-2) ?? \"00\"), \"hex\").toString(\"base64\")\n    };\n  }\n  generatePubKeyParams(privateKeyHex) {\n    const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n    return {\n      pub_key_X: key.getPublic().getX().toString(16, 64),\n      pub_key_Y: key.getPublic().getY().toString(16, 64)\n    };\n  }\n  async setMetadata(data, namespace, options) {\n    const params = namespace !== null ? _objectSpread(_objectSpread({}, data), {}, {\n      namespace\n    }) : data;\n    const metadataResponse = await post(`${this.metadataHost}/set`, params, options, {\n      useAPIKey: true\n    });\n    return metadataResponse.message;\n  }\n  async getMetadata(pubKey, namespace, options) {\n    const params = namespace !== null ? _objectSpread(_objectSpread({}, pubKey), {}, {\n      namespace\n    }) : pubKey;\n    const metadataResponse = await post(`${this.metadataHost}/get`, params, options, {\n      useAPIKey: true\n    });\n    return metadataResponse.message;\n  }\n}\nconst WEBAUTHN_TORUS_SHARE = \"webauthn_torus_share\";\nconst WEBAUTHN_DEVICE_SHARE = \"webauthn_device_share\";\nfunction encParamsHexToBuf(encParamsHex) {\n  return {\n    iv: Buffer.from(encParamsHex.iv, \"hex\"),\n    ephemPublicKey: Buffer.from(encParamsHex.ephemPublicKey, \"hex\"),\n    ciphertext: Buffer.from(encParamsHex.ciphertext, \"hex\"),\n    mac: Buffer.from(encParamsHex.mac, \"hex\")\n  };\n}\nfunction encParamsBufToHex(encParams) {\n  return {\n    iv: Buffer.from(encParams.iv).toString(\"hex\"),\n    ephemPublicKey: Buffer.from(encParams.ephemPublicKey).toString(\"hex\"),\n    ciphertext: Buffer.from(encParams.ciphertext).toString(\"hex\"),\n    mac: Buffer.from(encParams.mac).toString(\"hex\")\n  };\n}\nasync function encryptData(privKeyHex, d) {\n  const serializedDec = JSON.stringify(d);\n  const serializedBuf = Buffer.from(serializedDec, \"utf-8\");\n  const encParams = await encrypt(getPublic(Buffer.from(privKeyHex, \"hex\")), serializedBuf);\n  const encParamsHex = encParamsBufToHex(encParams);\n  const sData = JSON.stringify(encParamsHex);\n  return sData;\n}\nasync function decryptData(privKeyHex, d) {\n  const encParamsHex = JSON.parse(d);\n  const encParams = encParamsHexToBuf(encParamsHex);\n  const keyPair = ec.keyFromPrivate(privKeyHex);\n  const serializedBuf = await decrypt(Buffer.from(keyPair.getPrivate().toString(\"hex\", 64), \"hex\"), encParams);\n  const serializedDec = serializedBuf.toString(\"utf-8\");\n  const data = JSON.parse(serializedDec);\n  return data;\n}\nasync function getAndDecryptData(m, privKeyHex, namespace) {\n  const keyPair = ec.keyFromPrivate(privKeyHex);\n  const pubKey = keyPair.getPublic();\n  const serializedData = await m.getMetadata({\n    pub_key_X: pubKey.getX().toString(16),\n    pub_key_Y: pubKey.getY().toString(16)\n  }, namespace);\n  if (!serializedData) {\n    return null;\n  }\n  const data = await decryptData(privKeyHex, serializedData);\n  return data;\n}\nasync function encryptAndSetData(m, privKeyHex, d, namespace) {\n  const sData = await encryptData(privKeyHex, d);\n  const metadataParams = m.generateMetadataParams(sData, privKeyHex);\n  await m.setMetadata(metadataParams, namespace);\n}\nasync function setTorusShare(m, webAuthnPubKey, webAuthnRefHex, subspace, subspaceData) {\n  const refKeyPair = ec.keyFromPrivate(webAuthnRefHex);\n  const privKey = refKeyPair.getPrivate();\n  const pubKey = ec.keyFromPublic({\n    x: webAuthnPubKey.pub_key_X,\n    y: webAuthnPubKey.pub_key_Y\n  });\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n  let d = {};\n  if (data) d = data;\n  const serializedSubspaceData = JSON.stringify(subspaceData);\n  const serializedSubspaceDataBuf = Buffer.from(serializedSubspaceData, \"utf-8\");\n  const encSubspaceData = await encrypt(Buffer.from(pubKey.getPublic(\"hex\"), \"hex\"), serializedSubspaceDataBuf);\n  const encSubspaceDataHex = encParamsBufToHex(encSubspaceData);\n  d[subspace] = encSubspaceDataHex;\n  await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_TORUS_SHARE);\n}\nasync function setDeviceShare(m, webAuthnRefHex, subspace, subspaceData) {\n  const keyPair = ec.keyFromPrivate(webAuthnRefHex);\n  const privKey = keyPair.getPrivate();\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n  let d = {};\n  if (data) d = data;\n  d[subspace] = subspaceData;\n  await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_DEVICE_SHARE);\n}\nasync function getTorusShare(m, webAuthnKeyHex, webAuthnRefHex, subspace) {\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n  if (!data) return null;\n  const encParamsHex = data[subspace];\n  if (!encParamsHex) return null;\n  const encParams = encParamsHexToBuf(encParamsHex);\n  const keyPair = ec.keyFromPrivate(webAuthnKeyHex);\n  const privKey = keyPair.getPrivate();\n  const serializedSubspaceDataBuf = await decrypt(Buffer.from(privKey.toString(\"hex\", 64), \"hex\"), encParams);\n  const serializedSubspaceData = serializedSubspaceDataBuf.toString(\"utf-8\");\n  const subspaceData = JSON.parse(serializedSubspaceData);\n  return subspaceData;\n}\nasync function getDeviceShare(m, webAuthnRefHex, subspace) {\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n  if (data) return data[subspace];\n  return null;\n}\nexport { decryptData, MetadataStorageLayer as default, ec, encParamsBufToHex, encParamsHexToBuf, encryptAndSetData, encryptData, getAndDecryptData, getDeviceShare, getTorusShare, keccak256, setDeviceShare, setTorusShare };","map":{"version":3,"names":["keccak256","a","Buffer","from","keccak256$1","ec","ec$1","MetadataStorageLayer","constructor","metadataHost","arguments","length","undefined","serverTimeOffset","_defineProperty","setAPIKey","apiKey","setEmbedHost","embedHost","generateMetadataParams","message","privateKeyHex","key","keyFromPrivate","setData","data","timestamp","Math","floor","Date","now","toString","sig","sign","stringify","pub_key_X","getPublic","getX","pub_key_Y","getY","set_data","signature","r","s","recoveryParam","padStart","slice","generatePubKeyParams","setMetadata","namespace","options","params","_objectSpread","metadataResponse","post","useAPIKey","getMetadata","pubKey","WEBAUTHN_TORUS_SHARE","WEBAUTHN_DEVICE_SHARE","encParamsHexToBuf","encParamsHex","iv","ephemPublicKey","ciphertext","mac","encParamsBufToHex","encParams","encryptData","privKeyHex","d","serializedDec","JSON","serializedBuf","encrypt","sData","decryptData","parse","keyPair","decrypt","getPrivate","getAndDecryptData","m","serializedData","encryptAndSetData","metadataParams","setTorusShare","webAuthnPubKey","webAuthnRefHex","subspace","subspaceData","refKeyPair","privKey","keyFromPublic","x","y","serializedSubspaceData","serializedSubspaceDataBuf","encSubspaceData","encSubspaceDataHex","setDeviceShare","getTorusShare","webAuthnKeyHex","getDeviceShare"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@toruslabs/metadata-helpers/src/utils.ts","/Users/wuhuan/gif-portal-starter/node_modules/@toruslabs/metadata-helpers/src/MetadataStorageLayer.ts","/Users/wuhuan/gif-portal-starter/node_modules/@toruslabs/metadata-helpers/src/webAuthnShareResolver.ts"],"sourcesContent":["import { ec as EC } from \"elliptic\";\nimport { keccak256 as keccakHash } from \"ethereum-cryptography/keccak\";\n\nexport function keccak256(a: Buffer): Buffer {\n  return Buffer.from(keccakHash(a));\n}\n\nexport const ec = new EC(\"secp256k1\");\n","import { post, setAPIKey, setEmbedHost } from \"@toruslabs/http-helpers\";\nimport stringify from \"json-stable-stringify\";\n\nimport { ec, keccak256 } from \"./utils\";\n\nexport type PubKeyParams = {\n  pub_key_X: string;\n  pub_key_Y: string;\n};\n\nexport type MetadataParams = PubKeyParams & {\n  set_data: {\n    data: string;\n    timestamp: string;\n  };\n  signature: string;\n};\n\nclass MetadataStorageLayer {\n  public metadataHost: string;\n\n  public serverTimeOffset: number; // ms\n\n  constructor(metadataHost = \"https://metadata.tor.us\", serverTimeOffset = 0) {\n    this.metadataHost = metadataHost;\n    this.serverTimeOffset = serverTimeOffset;\n  }\n\n  static setAPIKey(apiKey: string): void {\n    setAPIKey(apiKey);\n  }\n\n  static setEmbedHost(embedHost: string): void {\n    setEmbedHost(embedHost);\n  }\n\n  generateMetadataParams(message: string, privateKeyHex: string): MetadataParams {\n    const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n    const setData = {\n      data: message,\n      timestamp: Math.floor(this.serverTimeOffset + Date.now() / 1000).toString(16),\n    };\n    const sig = key.sign(keccak256(Buffer.from(stringify(setData), \"utf8\")));\n    return {\n      pub_key_X: key.getPublic().getX().toString(16, 64),\n      pub_key_Y: key.getPublic().getY().toString(16, 64),\n      set_data: setData,\n      signature: Buffer.from(\n        sig.r.toString(16, 64) + sig.s.toString(16, 64) + (sig.recoveryParam?.toString(16).padStart(2, \"0\").slice(-2) ?? \"00\"),\n        \"hex\"\n      ).toString(\"base64\"),\n    };\n  }\n\n  generatePubKeyParams(privateKeyHex: string): PubKeyParams {\n    const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n    return {\n      pub_key_X: key.getPublic().getX().toString(16, 64),\n      pub_key_Y: key.getPublic().getY().toString(16, 64),\n    };\n  }\n\n  async setMetadata(data: MetadataParams, namespace: string | null, options?: RequestInit): Promise<string> {\n    const params = namespace !== null ? { ...data, namespace } : data;\n    const metadataResponse = await post<{ message: string }>(`${this.metadataHost}/set`, params, options, { useAPIKey: true });\n    return metadataResponse.message;\n  }\n\n  async getMetadata(pubKey: PubKeyParams, namespace: string | null, options?: RequestInit): Promise<string> {\n    const params = namespace !== null ? { ...pubKey, namespace } : pubKey;\n    const metadataResponse = await post<{ message: string }>(`${this.metadataHost}/get`, params, options, { useAPIKey: true });\n    return metadataResponse.message;\n  }\n}\n\nexport default MetadataStorageLayer;\n","import { decrypt, Ecies, encrypt, getPublic } from \"@toruslabs/eccrypto\";\n\nimport MetadataStorageLayer, { PubKeyParams } from \"./MetadataStorageLayer\";\nimport { ec } from \"./utils\";\n\nconst WEBAUTHN_TORUS_SHARE = \"webauthn_torus_share\";\nconst WEBAUTHN_DEVICE_SHARE = \"webauthn_device_share\";\n\nexport type EciesHex = {\n  iv: string;\n  ephemPublicKey: string;\n  ciphertext: string;\n  mac: string;\n};\n\nexport function encParamsHexToBuf(encParamsHex: EciesHex): Ecies {\n  return {\n    iv: Buffer.from(encParamsHex.iv, \"hex\"),\n    ephemPublicKey: Buffer.from(encParamsHex.ephemPublicKey, \"hex\"),\n    ciphertext: Buffer.from(encParamsHex.ciphertext, \"hex\"),\n    mac: Buffer.from(encParamsHex.mac, \"hex\"),\n  };\n}\n\nexport function encParamsBufToHex(encParams: Ecies): EciesHex {\n  return {\n    iv: Buffer.from(encParams.iv).toString(\"hex\"),\n    ephemPublicKey: Buffer.from(encParams.ephemPublicKey).toString(\"hex\"),\n    ciphertext: Buffer.from(encParams.ciphertext).toString(\"hex\"),\n    mac: Buffer.from(encParams.mac).toString(\"hex\"),\n  };\n}\n\nexport async function encryptData(privKeyHex: string, d: unknown): Promise<string> {\n  const serializedDec = JSON.stringify(d);\n  const serializedBuf = Buffer.from(serializedDec, \"utf-8\");\n  const encParams = await encrypt(getPublic(Buffer.from(privKeyHex, \"hex\")), serializedBuf);\n  const encParamsHex = encParamsBufToHex(encParams);\n  const sData = JSON.stringify(encParamsHex);\n  return sData;\n}\n\nexport async function decryptData<T>(privKeyHex: string, d: string): Promise<T> {\n  const encParamsHex: EciesHex = JSON.parse(d);\n  const encParams = encParamsHexToBuf(encParamsHex);\n  const keyPair = ec.keyFromPrivate(privKeyHex);\n  const serializedBuf = await decrypt(Buffer.from(keyPair.getPrivate().toString(\"hex\", 64), \"hex\"), encParams);\n  const serializedDec = serializedBuf.toString(\"utf-8\");\n  const data: T = JSON.parse(serializedDec);\n  return data;\n}\n\nexport async function getAndDecryptData<T>(m: MetadataStorageLayer, privKeyHex: string, namespace: string): Promise<Record<string, T> | null> {\n  const keyPair = ec.keyFromPrivate(privKeyHex);\n  const pubKey = keyPair.getPublic();\n  const serializedData = await m.getMetadata({ pub_key_X: pubKey.getX().toString(16), pub_key_Y: pubKey.getY().toString(16) }, namespace);\n  if (!serializedData) {\n    return null;\n  }\n  const data = await decryptData<T>(privKeyHex, serializedData);\n  return data as Record<string, T>;\n}\n\nexport async function encryptAndSetData(m: MetadataStorageLayer, privKeyHex: string, d: Record<string, unknown>, namespace: string): Promise<void> {\n  const sData = await encryptData(privKeyHex, d);\n  const metadataParams = m.generateMetadataParams(sData, privKeyHex);\n  await m.setMetadata(metadataParams, namespace);\n}\n\nexport async function setTorusShare(\n  m: MetadataStorageLayer,\n  webAuthnPubKey: PubKeyParams,\n  webAuthnRefHex: string,\n  subspace: string,\n  subspaceData: unknown\n): Promise<void> {\n  const refKeyPair = ec.keyFromPrivate(webAuthnRefHex);\n  const privKey = refKeyPair.getPrivate();\n  const pubKey = ec.keyFromPublic({\n    x: webAuthnPubKey.pub_key_X,\n    y: webAuthnPubKey.pub_key_Y,\n  });\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n  let d: Record<string, unknown> = {};\n  if (data) d = data;\n  const serializedSubspaceData = JSON.stringify(subspaceData);\n  const serializedSubspaceDataBuf = Buffer.from(serializedSubspaceData, \"utf-8\");\n  const encSubspaceData = await encrypt(Buffer.from(pubKey.getPublic(\"hex\"), \"hex\"), serializedSubspaceDataBuf);\n  const encSubspaceDataHex = encParamsBufToHex(encSubspaceData);\n  d[subspace] = encSubspaceDataHex;\n  await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_TORUS_SHARE);\n}\n\nexport async function setDeviceShare(m: MetadataStorageLayer, webAuthnRefHex: string, subspace: string, subspaceData: unknown): Promise<void> {\n  const keyPair = ec.keyFromPrivate(webAuthnRefHex);\n  const privKey = keyPair.getPrivate();\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n  let d: Record<string, unknown> = {};\n  if (data) d = data;\n  d[subspace] = subspaceData;\n  await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_DEVICE_SHARE);\n}\n\nexport async function getTorusShare<T>(m: MetadataStorageLayer, webAuthnKeyHex: string, webAuthnRefHex: string, subspace: string): Promise<T | null> {\n  const data = await getAndDecryptData<EciesHex>(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n  if (!data) return null;\n  const encParamsHex = data[subspace];\n  if (!encParamsHex) return null;\n  const encParams = encParamsHexToBuf(encParamsHex);\n  const keyPair = ec.keyFromPrivate(webAuthnKeyHex);\n  const privKey = keyPair.getPrivate();\n  const serializedSubspaceDataBuf = await decrypt(Buffer.from(privKey.toString(\"hex\", 64), \"hex\"), encParams);\n  const serializedSubspaceData = serializedSubspaceDataBuf.toString(\"utf-8\");\n  const subspaceData = JSON.parse(serializedSubspaceData);\n  return subspaceData;\n}\n\nexport async function getDeviceShare<T>(m: MetadataStorageLayer, webAuthnRefHex: string, subspace: string): Promise<T | null> {\n  const data = await getAndDecryptData<T>(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n  if (data) return data[subspace];\n  return null;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}