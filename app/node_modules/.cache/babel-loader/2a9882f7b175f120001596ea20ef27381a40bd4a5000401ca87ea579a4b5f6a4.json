{"ast":null,"code":"import _objectSpread from \"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _toConsumableArray from \"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport camelCase from \"camelcase\";\nimport * as borsh from \"@project-serum/borsh\";\nimport * as bs58 from \"bs58\";\nimport { IdlCoder } from \"./idl\";\nimport { sighash } from \"./common\";\n/**\n * Namespace for state method function signatures.\n */\nexport var SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\nexport var SIGHASH_GLOBAL_NAMESPACE = \"global\";\n/**\n * Encodes and decodes program instructions.\n */\nexport var InstructionCoder = /*#__PURE__*/function () {\n  function InstructionCoder(idl) {\n    var _this = this;\n    _classCallCheck(this, InstructionCoder);\n    this.idl = idl;\n    this.ixLayout = InstructionCoder.parseIxLayout(idl);\n    var sighashLayouts = new Map();\n    idl.instructions.forEach(function (ix) {\n      var sh = sighash(SIGHASH_GLOBAL_NAMESPACE, ix.name);\n      sighashLayouts.set(bs58.encode(sh), {\n        layout: _this.ixLayout.get(ix.name),\n        name: ix.name\n      });\n    });\n    if (idl.state) {\n      idl.state.methods.map(function (ix) {\n        var sh = sighash(SIGHASH_STATE_NAMESPACE, ix.name);\n        sighashLayouts.set(bs58.encode(sh), {\n          layout: _this.ixLayout.get(ix.name),\n          name: ix.name\n        });\n      });\n    }\n    this.sighashLayouts = sighashLayouts;\n  }\n  /**\n   * Encodes a program instruction.\n   */\n  _createClass(InstructionCoder, [{\n    key: \"encode\",\n    value: function encode(ixName, ix) {\n      return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n    }\n    /**\n     * Encodes a program state instruction.\n     */\n  }, {\n    key: \"encodeState\",\n    value: function encodeState(ixName, ix) {\n      return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);\n    }\n  }, {\n    key: \"_encode\",\n    value: function _encode(nameSpace, ixName, ix) {\n      var buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n      var methodName = camelCase(ixName);\n      var layout = this.ixLayout.get(methodName);\n      if (!layout) {\n        throw new Error(\"Unknown method: \".concat(methodName));\n      }\n      var len = layout.encode(ix, buffer);\n      var data = buffer.slice(0, len);\n      return Buffer.concat([sighash(nameSpace, ixName), data]);\n    }\n  }, {\n    key: \"decode\",\n    value:\n    /**\n     * Dewcodes a program instruction.\n     */\n    function decode(ix) {\n      var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"hex\";\n      if (typeof ix === \"string\") {\n        ix = encoding === \"hex\" ? Buffer.from(ix, \"hex\") : bs58.decode(ix);\n      }\n      var sighash = bs58.encode(ix.slice(0, 8));\n      var data = ix.slice(8);\n      var decoder = this.sighashLayouts.get(sighash);\n      if (!decoder) {\n        return null;\n      }\n      return {\n        data: decoder.layout.decode(data),\n        name: decoder.name\n      };\n    }\n    /**\n     * Returns a formatted table of all the fields in the given instruction data.\n     */\n  }, {\n    key: \"format\",\n    value: function format(ix, accountMetas) {\n      return InstructionFormatter.format(ix, accountMetas, this.idl);\n    }\n  }], [{\n    key: \"parseIxLayout\",\n    value: function parseIxLayout(idl) {\n      var stateMethods = idl.state ? idl.state.methods : [];\n      var ixLayouts = stateMethods.map(function (m) {\n        var fieldLayouts = m.args.map(function (arg) {\n          var _a, _b;\n          return IdlCoder.fieldLayout(arg, Array.from([].concat(_toConsumableArray((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), _toConsumableArray((_b = idl.types) !== null && _b !== void 0 ? _b : []))));\n        });\n        var name = camelCase(m.name);\n        return [name, borsh.struct(fieldLayouts, name)];\n      }).concat(idl.instructions.map(function (ix) {\n        var fieldLayouts = ix.args.map(function (arg) {\n          var _a, _b;\n          return IdlCoder.fieldLayout(arg, Array.from([].concat(_toConsumableArray((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), _toConsumableArray((_b = idl.types) !== null && _b !== void 0 ? _b : []))));\n        });\n        var name = camelCase(ix.name);\n        return [name, borsh.struct(fieldLayouts, name)];\n      }));\n      // @ts-ignore\n      return new Map(ixLayouts);\n    }\n  }]);\n  return InstructionCoder;\n}();\nvar InstructionFormatter = /*#__PURE__*/function () {\n  function InstructionFormatter() {\n    _classCallCheck(this, InstructionFormatter);\n  }\n  _createClass(InstructionFormatter, null, [{\n    key: \"format\",\n    value: function format(ix, accountMetas, idl) {\n      var idlIx = idl.instructions.filter(function (i) {\n        return ix.name === i.name;\n      })[0];\n      if (idlIx === undefined) {\n        console.error(\"Invalid instruction given\");\n        return null;\n      }\n      var args = idlIx.args.map(function (idlField) {\n        return {\n          name: idlField.name,\n          type: InstructionFormatter.formatIdlType(idlField.type),\n          data: InstructionFormatter.formatIdlData(idlField, ix.data[idlField.name], idl.types)\n        };\n      });\n      var flatIdlAccounts = InstructionFormatter.flattenIdlAccounts(idlIx.accounts);\n      var accounts = accountMetas.map(function (meta, idx) {\n        if (idx < flatIdlAccounts.length) {\n          return _objectSpread({\n            name: flatIdlAccounts[idx].name\n          }, meta);\n        }\n        // \"Remaining accounts\" are unnamed in Anchor.\n        else {\n          return _objectSpread({\n            name: undefined\n          }, meta);\n        }\n      });\n      return {\n        args: args,\n        accounts: accounts\n      };\n    }\n  }, {\n    key: \"formatIdlType\",\n    value: function formatIdlType(idlType) {\n      if (typeof idlType === \"string\") {\n        return idlType;\n      }\n      if (\"vec\" in idlType) {\n        return \"Vec<\".concat(this.formatIdlType(idlType.vec), \">\");\n      }\n      if (\"option\" in idlType) {\n        return \"Option<\".concat(this.formatIdlType(idlType.option), \">\");\n      }\n      if (\"defined\" in idlType) {\n        return idlType.defined;\n      }\n      if (\"array\" in idlType) {\n        return \"Array<\".concat(idlType.array[0], \"; \").concat(idlType.array[1], \">\");\n      }\n      throw new Error(\"Unknown IDL type: \".concat(idlType));\n    }\n  }, {\n    key: \"formatIdlData\",\n    value: function formatIdlData(idlField, data, types) {\n      var _this2 = this;\n      if (typeof idlField.type === \"string\") {\n        return data.toString();\n      }\n      // @ts-ignore\n      if (idlField.type.vec) {\n        // @ts-ignore\n        return \"[\" + data\n        // @ts-ignore\n        .map(function (d) {\n          return _this2.formatIdlData(\n          // @ts-ignore\n          {\n            name: \"\",\n            type: idlField.type.vec\n          }, d);\n        }).join(\", \") + \"]\";\n      }\n      // @ts-ignore\n      if (idlField.type.option) {\n        // @ts-ignore\n        return data === null ? \"null\" : this.formatIdlData(\n        // @ts-ignore\n        {\n          name: \"\",\n          type: idlField.type.option\n        }, data);\n      }\n      // @ts-ignore\n      if (idlField.type.defined) {\n        if (types === undefined) {\n          throw new Error(\"User defined types not provided\");\n        }\n        // @ts-ignore\n        var filtered = types.filter(function (t) {\n          return t.name === idlField.type.defined;\n        });\n        if (filtered.length !== 1) {\n          // @ts-ignore\n          throw new Error(\"Type not found: \".concat(idlField.type.defined));\n        }\n        return InstructionFormatter.formatIdlDataDefined(filtered[0], data, types);\n      }\n      return \"unknown\";\n    }\n  }, {\n    key: \"formatIdlDataDefined\",\n    value: function formatIdlDataDefined(typeDef, data, types) {\n      if (typeDef.type.kind === \"struct\") {\n        var struct = typeDef.type;\n        var fields = Object.keys(data).map(function (k) {\n          var f = struct.fields.filter(function (f) {\n            return f.name === k;\n          })[0];\n          if (f === undefined) {\n            throw new Error(\"Unable to find type\");\n          }\n          return k + \": \" + InstructionFormatter.formatIdlData(f, data[k], types);\n        }).join(\", \");\n        return \"{ \" + fields + \" }\";\n      } else {\n        if (typeDef.type.variants.length === 0) {\n          return \"{}\";\n        }\n        // Struct enum.\n        if (typeDef.type.variants[0].name) {\n          var variants = typeDef.type.variants;\n          var variant = Object.keys(data)[0];\n          var enumType = data[variant];\n          var namedFields = Object.keys(enumType).map(function (f) {\n            var _a;\n            var fieldData = enumType[f];\n            var idlField = (_a = variants[variant]) === null || _a === void 0 ? void 0 : _a.filter(function (v) {\n              return v.name === f;\n            })[0];\n            if (idlField === undefined) {\n              throw new Error(\"Unable to find variant\");\n            }\n            return f + \": \" + InstructionFormatter.formatIdlData(idlField, fieldData, types);\n          }).join(\", \");\n          var variantName = camelCase(variant, {\n            pascalCase: true\n          });\n          if (namedFields.length === 0) {\n            return variantName;\n          }\n          return \"\".concat(variantName, \" { \").concat(namedFields, \" }\");\n        }\n        // Tuple enum.\n        else {\n          // TODO.\n          return \"Tuple formatting not yet implemented\";\n        }\n      }\n    }\n  }, {\n    key: \"flattenIdlAccounts\",\n    value: function flattenIdlAccounts(accounts, prefix) {\n      // @ts-ignore\n      return accounts.map(function (account) {\n        var accName = sentenceCase(account.name);\n        // @ts-ignore\n        if (account.accounts) {\n          var newPrefix = prefix ? \"\".concat(prefix, \" > \").concat(accName) : accName;\n          // @ts-ignore\n          return InstructionFormatter.flattenIdlAccounts(\n          // @ts-ignore\n          account.accounts, newPrefix);\n        } else {\n          return _objectSpread(_objectSpread({}, account), {}, {\n            name: prefix ? \"\".concat(prefix, \" > \").concat(accName) : accName\n          });\n        }\n      }).flat();\n    }\n  }]);\n  return InstructionFormatter;\n}();\nfunction sentenceCase(field) {\n  var result = field.replace(/([A-Z])/g, \" $1\");\n  return result.charAt(0).toUpperCase() + result.slice(1);\n}","map":{"version":3,"names":["camelCase","borsh","bs58","IdlCoder","sighash","SIGHASH_STATE_NAMESPACE","SIGHASH_GLOBAL_NAMESPACE","InstructionCoder","idl","_this","_classCallCheck","ixLayout","parseIxLayout","sighashLayouts","Map","instructions","forEach","ix","sh","name","set","encode","layout","get","state","methods","map","_createClass","key","value","ixName","_encode","encodeState","nameSpace","buffer","Buffer","alloc","methodName","Error","concat","len","data","slice","decode","encoding","arguments","length","undefined","from","decoder","format","accountMetas","InstructionFormatter","stateMethods","ixLayouts","m","fieldLayouts","args","arg","fieldLayout","Array","_toConsumableArray","_a","accounts","_b","types","struct","idlIx","filter","i","console","error","idlField","type","formatIdlType","formatIdlData","flatIdlAccounts","flattenIdlAccounts","meta","idx","_objectSpread","idlType","vec","option","defined","array","_this2","toString","d","join","filtered","t","formatIdlDataDefined","typeDef","kind","fields","Object","keys","k","f","variants","variant","enumType","namedFields","fieldData","v","variantName","pascalCase","prefix","account","accName","sentenceCase","newPrefix","flat","field","result","replace","charAt","toUpperCase"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/coder/instruction.ts"],"sourcesContent":["import camelCase from \"camelcase\";\nimport { Layout } from \"buffer-layout\";\nimport * as borsh from \"@project-serum/borsh\";\nimport * as bs58 from \"bs58\";\nimport {\n  Idl,\n  IdlField,\n  IdlStateMethod,\n  IdlType,\n  IdlTypeDef,\n  IdlAccount,\n  IdlAccountItem,\n  IdlTypeDefTyStruct,\n} from \"../idl\";\nimport { IdlCoder } from \"./idl\";\nimport { sighash } from \"./common\";\nimport { AccountMeta, PublicKey } from \"@solana/web3.js\";\n\n/**\n * Namespace for state method function signatures.\n */\nexport const SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\nexport const SIGHASH_GLOBAL_NAMESPACE = \"global\";\n\n/**\n * Encodes and decodes program instructions.\n */\nexport class InstructionCoder {\n  // Instruction args layout. Maps namespaced method\n  private ixLayout: Map<string, Layout>;\n\n  // Base58 encoded sighash to instruction layout.\n  private sighashLayouts: Map<string, { layout: Layout; name: string }>;\n\n  public constructor(private idl: Idl) {\n    this.ixLayout = InstructionCoder.parseIxLayout(idl);\n\n    const sighashLayouts = new Map();\n    idl.instructions.forEach((ix) => {\n      const sh = sighash(SIGHASH_GLOBAL_NAMESPACE, ix.name);\n      sighashLayouts.set(bs58.encode(sh), {\n        layout: this.ixLayout.get(ix.name),\n        name: ix.name,\n      });\n    });\n\n    if (idl.state) {\n      idl.state.methods.map((ix) => {\n        const sh = sighash(SIGHASH_STATE_NAMESPACE, ix.name);\n        sighashLayouts.set(bs58.encode(sh), {\n          layout: this.ixLayout.get(ix.name) as Layout,\n          name: ix.name,\n        });\n      });\n    }\n\n    this.sighashLayouts = sighashLayouts;\n  }\n\n  /**\n   * Encodes a program instruction.\n   */\n  public encode(ixName: string, ix: any) {\n    return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n  }\n\n  /**\n   * Encodes a program state instruction.\n   */\n  public encodeState(ixName: string, ix: any) {\n    return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);\n  }\n\n  private _encode(nameSpace: string, ixName: string, ix: any): Buffer {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n    const methodName = camelCase(ixName);\n    const layout = this.ixLayout.get(methodName);\n    if (!layout) {\n      throw new Error(`Unknown method: ${methodName}`);\n    }\n    const len = layout.encode(ix, buffer);\n    const data = buffer.slice(0, len);\n    return Buffer.concat([sighash(nameSpace, ixName), data]);\n  }\n\n  private static parseIxLayout(idl: Idl): Map<string, Layout> {\n    const stateMethods = idl.state ? idl.state.methods : [];\n\n    const ixLayouts = stateMethods\n      .map((m: IdlStateMethod) => {\n        let fieldLayouts = m.args.map((arg: IdlField) => {\n          return IdlCoder.fieldLayout(\n            arg,\n            Array.from([...(idl.accounts ?? []), ...(idl.types ?? [])])\n          );\n        });\n        const name = camelCase(m.name);\n        return [name, borsh.struct(fieldLayouts, name)];\n      })\n      .concat(\n        idl.instructions.map((ix) => {\n          let fieldLayouts = ix.args.map((arg: IdlField) =>\n            IdlCoder.fieldLayout(\n              arg,\n              Array.from([...(idl.accounts ?? []), ...(idl.types ?? [])])\n            )\n          );\n          const name = camelCase(ix.name);\n          return [name, borsh.struct(fieldLayouts, name)];\n        })\n      );\n    // @ts-ignore\n    return new Map(ixLayouts);\n  }\n\n  /**\n   * Dewcodes a program instruction.\n   */\n  public decode(\n    ix: Buffer | string,\n    encoding: \"hex\" | \"base58\" = \"hex\"\n  ): Instruction | null {\n    if (typeof ix === \"string\") {\n      ix = encoding === \"hex\" ? Buffer.from(ix, \"hex\") : bs58.decode(ix);\n    }\n    let sighash = bs58.encode(ix.slice(0, 8));\n    let data = ix.slice(8);\n    const decoder = this.sighashLayouts.get(sighash);\n    if (!decoder) {\n      return null;\n    }\n    return {\n      data: decoder.layout.decode(data),\n      name: decoder.name,\n    };\n  }\n\n  /**\n   * Returns a formatted table of all the fields in the given instruction data.\n   */\n  public format(\n    ix: Instruction,\n    accountMetas: AccountMeta[]\n  ): InstructionDisplay | null {\n    return InstructionFormatter.format(ix, accountMetas, this.idl);\n  }\n}\n\nexport type Instruction = {\n  name: string;\n  data: Object;\n};\n\nexport type InstructionDisplay = {\n  args: { name: string; type: string; data: string }[];\n  accounts: {\n    name?: string;\n    pubkey: PublicKey;\n    isSigner: boolean;\n    isWritable: boolean;\n  }[];\n};\n\nclass InstructionFormatter {\n  public static format(\n    ix: Instruction,\n    accountMetas: AccountMeta[],\n    idl: Idl\n  ): InstructionDisplay | null {\n    const idlIx = idl.instructions.filter((i) => ix.name === i.name)[0];\n    if (idlIx === undefined) {\n      console.error(\"Invalid instruction given\");\n      return null;\n    }\n\n    const args = idlIx.args.map((idlField) => {\n      return {\n        name: idlField.name,\n        type: InstructionFormatter.formatIdlType(idlField.type),\n        data: InstructionFormatter.formatIdlData(\n          idlField,\n          ix.data[idlField.name],\n          idl.types\n        ),\n      };\n    });\n\n    const flatIdlAccounts = InstructionFormatter.flattenIdlAccounts(\n      idlIx.accounts\n    );\n\n    const accounts = accountMetas.map((meta, idx) => {\n      if (idx < flatIdlAccounts.length) {\n        return {\n          name: flatIdlAccounts[idx].name,\n          ...meta,\n        };\n      }\n      // \"Remaining accounts\" are unnamed in Anchor.\n      else {\n        return {\n          name: undefined,\n          ...meta,\n        };\n      }\n    });\n\n    return {\n      args,\n      accounts,\n    };\n  }\n\n  private static formatIdlType(idlType: IdlType): string {\n    if (typeof idlType === \"string\") {\n      return idlType as string;\n    }\n\n    if (\"vec\" in idlType) {\n      return `Vec<${this.formatIdlType(idlType.vec)}>`;\n    }\n    if (\"option\" in idlType) {\n      return `Option<${this.formatIdlType(idlType.option)}>`;\n    }\n    if (\"defined\" in idlType) {\n      return idlType.defined;\n    }\n    if (\"array\" in idlType) {\n      return `Array<${idlType.array[0]}; ${idlType.array[1]}>`;\n    }\n\n    throw new Error(`Unknown IDL type: ${idlType}`);\n  }\n\n  private static formatIdlData(\n    idlField: IdlField,\n    data: Object,\n    types?: IdlTypeDef[]\n  ): string {\n    if (typeof idlField.type === \"string\") {\n      return data.toString();\n    }\n    // @ts-ignore\n    if (idlField.type.vec) {\n      // @ts-ignore\n      return (\n        \"[\" +\n        data\n          // @ts-ignore\n          .map((d: IdlField) =>\n            this.formatIdlData(\n              // @ts-ignore\n              { name: \"\", type: idlField.type.vec },\n              d\n            )\n          )\n          .join(\", \") +\n        \"]\"\n      );\n    }\n    // @ts-ignore\n    if (idlField.type.option) {\n      // @ts-ignore\n      return data === null\n        ? \"null\"\n        : this.formatIdlData(\n            // @ts-ignore\n            { name: \"\", type: idlField.type.option },\n            data\n          );\n    }\n    // @ts-ignore\n    if (idlField.type.defined) {\n      if (types === undefined) {\n        throw new Error(\"User defined types not provided\");\n      }\n      // @ts-ignore\n      const filtered = types.filter((t) => t.name === idlField.type.defined);\n      if (filtered.length !== 1) {\n        // @ts-ignore\n        throw new Error(`Type not found: ${idlField.type.defined}`);\n      }\n      return InstructionFormatter.formatIdlDataDefined(\n        filtered[0],\n        data,\n        types\n      );\n    }\n\n    return \"unknown\";\n  }\n\n  private static formatIdlDataDefined(\n    typeDef: IdlTypeDef,\n    data: Object,\n    types: IdlTypeDef[]\n  ): string {\n    if (typeDef.type.kind === \"struct\") {\n      const struct: IdlTypeDefTyStruct = typeDef.type;\n      const fields = Object.keys(data)\n        .map((k) => {\n          const f = struct.fields.filter((f) => f.name === k)[0];\n          if (f === undefined) {\n            throw new Error(\"Unable to find type\");\n          }\n          return (\n            k + \": \" + InstructionFormatter.formatIdlData(f, data[k], types)\n          );\n        })\n        .join(\", \");\n      return \"{ \" + fields + \" }\";\n    } else {\n      if (typeDef.type.variants.length === 0) {\n        return \"{}\";\n      }\n      // Struct enum.\n      if (typeDef.type.variants[0].name) {\n        const variants = typeDef.type.variants;\n        const variant = Object.keys(data)[0];\n        const enumType = data[variant];\n        const namedFields = Object.keys(enumType)\n          .map((f) => {\n            const fieldData = enumType[f];\n            const idlField = variants[variant]?.filter(\n              (v: IdlField) => v.name === f\n            )[0];\n            if (idlField === undefined) {\n              throw new Error(\"Unable to find variant\");\n            }\n            return (\n              f +\n              \": \" +\n              InstructionFormatter.formatIdlData(idlField, fieldData, types)\n            );\n          })\n          .join(\", \");\n\n        const variantName = camelCase(variant, { pascalCase: true });\n        if (namedFields.length === 0) {\n          return variantName;\n        }\n        return `${variantName} { ${namedFields} }`;\n      }\n      // Tuple enum.\n      else {\n        // TODO.\n        return \"Tuple formatting not yet implemented\";\n      }\n    }\n  }\n\n  private static flattenIdlAccounts(\n    accounts: IdlAccountItem[],\n    prefix?: string\n  ): IdlAccount[] {\n    // @ts-ignore\n    return accounts\n      .map((account) => {\n        const accName = sentenceCase(account.name);\n        // @ts-ignore\n        if (account.accounts) {\n          const newPrefix = prefix ? `${prefix} > ${accName}` : accName;\n          // @ts-ignore\n          return InstructionFormatter.flattenIdlAccounts(\n            // @ts-ignore\n            account.accounts,\n            newPrefix\n          );\n        } else {\n          return {\n            ...account,\n            name: prefix ? `${prefix} > ${accName}` : accName,\n          };\n        }\n      })\n      .flat();\n  }\n}\n\nfunction sentenceCase(field: string): string {\n  const result = field.replace(/([A-Z])/g, \" $1\");\n  return result.charAt(0).toUpperCase() + result.slice(1);\n}\n"],"mappings":";;;;AAAA,OAAOA,SAAS,MAAM,WAAW;AAEjC,OAAO,KAAKC,KAAK,MAAM,sBAAsB;AAC7C,OAAO,KAAKC,IAAI,MAAM,MAAM;AAW5B,SAASC,QAAQ,QAAQ,OAAO;AAChC,SAASC,OAAO,QAAQ,UAAU;AAGlC;;;AAGA,OAAO,IAAMC,uBAAuB,GAAG,OAAO;AAC9C;;;;AAIA,OAAO,IAAMC,wBAAwB,GAAG,QAAQ;AAEhD;;;AAGA,WAAaC,gBAAgB;EAO3B,SAAAA,iBAA2BC,GAAQ;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAH,gBAAA;IAAR,KAAAC,GAAG,GAAHA,GAAG;IAC5B,IAAI,CAACG,QAAQ,GAAGJ,gBAAgB,CAACK,aAAa,CAACJ,GAAG,CAAC;IAEnD,IAAMK,cAAc,GAAG,IAAIC,GAAG,EAAE;IAChCN,GAAG,CAACO,YAAY,CAACC,OAAO,CAAC,UAACC,EAAE,EAAI;MAC9B,IAAMC,EAAE,GAAGd,OAAO,CAACE,wBAAwB,EAAEW,EAAE,CAACE,IAAI,CAAC;MACrDN,cAAc,CAACO,GAAG,CAAClB,IAAI,CAACmB,MAAM,CAACH,EAAE,CAAC,EAAE;QAClCI,MAAM,EAAEb,KAAI,CAACE,QAAQ,CAACY,GAAG,CAACN,EAAE,CAACE,IAAI,CAAC;QAClCA,IAAI,EAAEF,EAAE,CAACE;OACV,CAAC;IACJ,CAAC,CAAC;IAEF,IAAIX,GAAG,CAACgB,KAAK,EAAE;MACbhB,GAAG,CAACgB,KAAK,CAACC,OAAO,CAACC,GAAG,CAAC,UAACT,EAAE,EAAI;QAC3B,IAAMC,EAAE,GAAGd,OAAO,CAACC,uBAAuB,EAAEY,EAAE,CAACE,IAAI,CAAC;QACpDN,cAAc,CAACO,GAAG,CAAClB,IAAI,CAACmB,MAAM,CAACH,EAAE,CAAC,EAAE;UAClCI,MAAM,EAAEb,KAAI,CAACE,QAAQ,CAACY,GAAG,CAACN,EAAE,CAACE,IAAI,CAAW;UAC5CA,IAAI,EAAEF,EAAE,CAACE;SACV,CAAC;MACJ,CAAC,CAAC;;IAGJ,IAAI,CAACN,cAAc,GAAGA,cAAc;EACtC;EAEA;;;EAAAc,YAAA,CAAApB,gBAAA;IAAAqB,GAAA;IAAAC,KAAA,EAGO,SAAAR,OAAOS,MAAc,EAAEb,EAAO;MACnC,OAAO,IAAI,CAACc,OAAO,CAACzB,wBAAwB,EAAEwB,MAAM,EAAEb,EAAE,CAAC;IAC3D;IAEA;;;EAAA;IAAAW,GAAA;IAAAC,KAAA,EAGO,SAAAG,YAAYF,MAAc,EAAEb,EAAO;MACxC,OAAO,IAAI,CAACc,OAAO,CAAC1B,uBAAuB,EAAEyB,MAAM,EAAEb,EAAE,CAAC;IAC1D;EAAC;IAAAW,GAAA;IAAAC,KAAA,EAEO,SAAAE,QAAQE,SAAiB,EAAEH,MAAc,EAAEb,EAAO;MACxD,IAAMiB,MAAM,GAAGC,MAAM,CAACC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;MACnC,IAAMC,UAAU,GAAGrC,SAAS,CAAC8B,MAAM,CAAC;MACpC,IAAMR,MAAM,GAAG,IAAI,CAACX,QAAQ,CAACY,GAAG,CAACc,UAAU,CAAC;MAC5C,IAAI,CAACf,MAAM,EAAE;QACX,MAAM,IAAIgB,KAAK,oBAAAC,MAAA,CAAoBF,UAAU,CAAE,CAAC;;MAElD,IAAMG,GAAG,GAAGlB,MAAM,CAACD,MAAM,CAACJ,EAAE,EAAEiB,MAAM,CAAC;MACrC,IAAMO,IAAI,GAAGP,MAAM,CAACQ,KAAK,CAAC,CAAC,EAAEF,GAAG,CAAC;MACjC,OAAOL,MAAM,CAACI,MAAM,CAAC,CAACnC,OAAO,CAAC6B,SAAS,EAAEH,MAAM,CAAC,EAAEW,IAAI,CAAC,CAAC;IAC1D;EAAC;IAAAb,GAAA;IAAAC,KAAA;IAgCD;;;IAGO,SAAAc,OACL1B,EAAmB,EACe;MAAA,IAAlC2B,QAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA6B,KAAK;MAElC,IAAI,OAAO5B,EAAE,KAAK,QAAQ,EAAE;QAC1BA,EAAE,GAAG2B,QAAQ,KAAK,KAAK,GAAGT,MAAM,CAACa,IAAI,CAAC/B,EAAE,EAAE,KAAK,CAAC,GAAGf,IAAI,CAACyC,MAAM,CAAC1B,EAAE,CAAC;;MAEpE,IAAIb,OAAO,GAAGF,IAAI,CAACmB,MAAM,CAACJ,EAAE,CAACyB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MACzC,IAAID,IAAI,GAAGxB,EAAE,CAACyB,KAAK,CAAC,CAAC,CAAC;MACtB,IAAMO,OAAO,GAAG,IAAI,CAACpC,cAAc,CAACU,GAAG,CAACnB,OAAO,CAAC;MAChD,IAAI,CAAC6C,OAAO,EAAE;QACZ,OAAO,IAAI;;MAEb,OAAO;QACLR,IAAI,EAAEQ,OAAO,CAAC3B,MAAM,CAACqB,MAAM,CAACF,IAAI,CAAC;QACjCtB,IAAI,EAAE8B,OAAO,CAAC9B;OACf;IACH;IAEA;;;EAAA;IAAAS,GAAA;IAAAC,KAAA,EAGO,SAAAqB,OACLjC,EAAe,EACfkC,YAA2B;MAE3B,OAAOC,oBAAoB,CAACF,MAAM,CAACjC,EAAE,EAAEkC,YAAY,EAAE,IAAI,CAAC3C,GAAG,CAAC;IAChE;EAAC;IAAAoB,GAAA;IAAAC,KAAA,EA5DO,SAAAjB,cAAqBJ,GAAQ;MACnC,IAAM6C,YAAY,GAAG7C,GAAG,CAACgB,KAAK,GAAGhB,GAAG,CAACgB,KAAK,CAACC,OAAO,GAAG,EAAE;MAEvD,IAAM6B,SAAS,GAAGD,YAAY,CAC3B3B,GAAG,CAAC,UAAC6B,CAAiB,EAAI;QACzB,IAAIC,YAAY,GAAGD,CAAC,CAACE,IAAI,CAAC/B,GAAG,CAAC,UAACgC,GAAa,EAAI;;UAC9C,OAAOvD,QAAQ,CAACwD,WAAW,CACzBD,GAAG,EACHE,KAAK,CAACZ,IAAI,IAAAT,MAAA,CAAAsB,kBAAA,CAAM,CAAAC,EAAA,GAAAtD,GAAG,CAACuD,QAAQ,cAAAD,EAAA,cAAAA,EAAA,GAAI,EAAE,GAAAD,kBAAA,CAAO,CAAAG,EAAA,GAAAxD,GAAG,CAACyD,KAAK,cAAAD,EAAA,cAAAA,EAAA,GAAI,EAAE,EAAE,CAAC,CAC5D;QACH,CAAC,CAAC;QACF,IAAM7C,IAAI,GAAGnB,SAAS,CAACuD,CAAC,CAACpC,IAAI,CAAC;QAC9B,OAAO,CAACA,IAAI,EAAElB,KAAK,CAACiE,MAAM,CAACV,YAAY,EAAErC,IAAI,CAAC,CAAC;MACjD,CAAC,CAAC,CACDoB,MAAM,CACL/B,GAAG,CAACO,YAAY,CAACW,GAAG,CAAC,UAACT,EAAE,EAAI;QAC1B,IAAIuC,YAAY,GAAGvC,EAAE,CAACwC,IAAI,CAAC/B,GAAG,CAAC,UAACgC,GAAa,EAAI;;UAC/C,OAAAvD,QAAQ,CAACwD,WAAW,CAClBD,GAAG,EACHE,KAAK,CAACZ,IAAI,IAAAT,MAAA,CAAAsB,kBAAA,CAAM,CAAAC,EAAA,GAAAtD,GAAG,CAACuD,QAAQ,cAAAD,EAAA,cAAAA,EAAA,GAAI,EAAE,GAAAD,kBAAA,CAAO,CAAAG,EAAA,GAAAxD,GAAG,CAACyD,KAAK,cAAAD,EAAA,cAAAA,EAAA,GAAI,EAAE,EAAE,CAAC,CAC5D;SAAA,CACF;QACD,IAAM7C,IAAI,GAAGnB,SAAS,CAACiB,EAAE,CAACE,IAAI,CAAC;QAC/B,OAAO,CAACA,IAAI,EAAElB,KAAK,CAACiE,MAAM,CAACV,YAAY,EAAErC,IAAI,CAAC,CAAC;MACjD,CAAC,CAAC,CACH;MACH;MACA,OAAO,IAAIL,GAAG,CAACwC,SAAS,CAAC;IAC3B;EAAC;EAAA,OAAA/C,gBAAA;AAAA;AAiCF,IAiBK6C,oBAAoB;EAAA,SAAAA,qBAAA;IAAA1C,eAAA,OAAA0C,oBAAA;EAAA;EAAAzB,YAAA,CAAAyB,oBAAA;IAAAxB,GAAA;IAAAC,KAAA,EACjB,SAAAqB,OACLjC,EAAe,EACfkC,YAA2B,EAC3B3C,GAAQ;MAER,IAAM2D,KAAK,GAAG3D,GAAG,CAACO,YAAY,CAACqD,MAAM,CAAC,UAACC,CAAC;QAAA,OAAKpD,EAAE,CAACE,IAAI,KAAKkD,CAAC,CAAClD,IAAI;MAAA,EAAC,CAAC,CAAC,CAAC;MACnE,IAAIgD,KAAK,KAAKpB,SAAS,EAAE;QACvBuB,OAAO,CAACC,KAAK,CAAC,2BAA2B,CAAC;QAC1C,OAAO,IAAI;;MAGb,IAAMd,IAAI,GAAGU,KAAK,CAACV,IAAI,CAAC/B,GAAG,CAAC,UAAC8C,QAAQ,EAAI;QACvC,OAAO;UACLrD,IAAI,EAAEqD,QAAQ,CAACrD,IAAI;UACnBsD,IAAI,EAAErB,oBAAoB,CAACsB,aAAa,CAACF,QAAQ,CAACC,IAAI,CAAC;UACvDhC,IAAI,EAAEW,oBAAoB,CAACuB,aAAa,CACtCH,QAAQ,EACRvD,EAAE,CAACwB,IAAI,CAAC+B,QAAQ,CAACrD,IAAI,CAAC,EACtBX,GAAG,CAACyD,KAAK;SAEZ;MACH,CAAC,CAAC;MAEF,IAAMW,eAAe,GAAGxB,oBAAoB,CAACyB,kBAAkB,CAC7DV,KAAK,CAACJ,QAAQ,CACf;MAED,IAAMA,QAAQ,GAAGZ,YAAY,CAACzB,GAAG,CAAC,UAACoD,IAAI,EAAEC,GAAG,EAAI;QAC9C,IAAIA,GAAG,GAAGH,eAAe,CAAC9B,MAAM,EAAE;UAChC,OAAAkC,aAAA;YACE7D,IAAI,EAAEyD,eAAe,CAACG,GAAG,CAAC,CAAC5D;UAAI,GAC5B2D,IAAI;;QAGX;QAAA,KACK;UACH,OAAAE,aAAA;YACE7D,IAAI,EAAE4B;UAAS,GACZ+B,IAAI;;MAGb,CAAC,CAAC;MAEF,OAAO;QACLrB,IAAI,EAAJA,IAAI;QACJM,QAAQ,EAARA;OACD;IACH;EAAC;IAAAnC,GAAA;IAAAC,KAAA,EAEO,SAAA6C,cAAqBO,OAAgB;MAC3C,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;QAC/B,OAAOA,OAAiB;;MAG1B,IAAI,KAAK,IAAIA,OAAO,EAAE;QACpB,cAAA1C,MAAA,CAAc,IAAI,CAACmC,aAAa,CAACO,OAAO,CAACC,GAAG,CAAC;;MAE/C,IAAI,QAAQ,IAAID,OAAO,EAAE;QACvB,iBAAA1C,MAAA,CAAiB,IAAI,CAACmC,aAAa,CAACO,OAAO,CAACE,MAAM,CAAC;;MAErD,IAAI,SAAS,IAAIF,OAAO,EAAE;QACxB,OAAOA,OAAO,CAACG,OAAO;;MAExB,IAAI,OAAO,IAAIH,OAAO,EAAE;QACtB,gBAAA1C,MAAA,CAAgB0C,OAAO,CAACI,KAAK,CAAC,CAAC,CAAC,QAAA9C,MAAA,CAAK0C,OAAO,CAACI,KAAK,CAAC,CAAC,CAAC;;MAGvD,MAAM,IAAI/C,KAAK,sBAAAC,MAAA,CAAsB0C,OAAO,CAAE,CAAC;IACjD;EAAC;IAAArD,GAAA;IAAAC,KAAA,EAEO,SAAA8C,cACNH,QAAkB,EAClB/B,IAAY,EACZwB,KAAoB;MAAA,IAAAqB,MAAA;MAEpB,IAAI,OAAOd,QAAQ,CAACC,IAAI,KAAK,QAAQ,EAAE;QACrC,OAAOhC,IAAI,CAAC8C,QAAQ,EAAE;;MAExB;MACA,IAAIf,QAAQ,CAACC,IAAI,CAACS,GAAG,EAAE;QACrB;QACA,OACE,GAAG,GACHzC;QACE;QAAA,CACCf,GAAG,CAAC,UAAC8D,CAAW;UAAA,OACfF,MAAI,CAACX,aAAa;UAChB;UACA;YAAExD,IAAI,EAAE,EAAE;YAAEsD,IAAI,EAAED,QAAQ,CAACC,IAAI,CAACS;UAAG,CAAE,EACrCM,CAAC,CACF;QAAA,EACF,CACAC,IAAI,CAAC,IAAI,CAAC,GACb,GAAG;;MAGP;MACA,IAAIjB,QAAQ,CAACC,IAAI,CAACU,MAAM,EAAE;QACxB;QACA,OAAO1C,IAAI,KAAK,IAAI,GAChB,MAAM,GACN,IAAI,CAACkC,aAAa;QAChB;QACA;UAAExD,IAAI,EAAE,EAAE;UAAEsD,IAAI,EAAED,QAAQ,CAACC,IAAI,CAACU;QAAM,CAAE,EACxC1C,IAAI,CACL;;MAEP;MACA,IAAI+B,QAAQ,CAACC,IAAI,CAACW,OAAO,EAAE;QACzB,IAAInB,KAAK,KAAKlB,SAAS,EAAE;UACvB,MAAM,IAAIT,KAAK,CAAC,iCAAiC,CAAC;;QAEpD;QACA,IAAMoD,QAAQ,GAAGzB,KAAK,CAACG,MAAM,CAAC,UAACuB,CAAC;UAAA,OAAKA,CAAC,CAACxE,IAAI,KAAKqD,QAAQ,CAACC,IAAI,CAACW,OAAO;QAAA,EAAC;QACtE,IAAIM,QAAQ,CAAC5C,MAAM,KAAK,CAAC,EAAE;UACzB;UACA,MAAM,IAAIR,KAAK,oBAAAC,MAAA,CAAoBiC,QAAQ,CAACC,IAAI,CAACW,OAAO,CAAE,CAAC;;QAE7D,OAAOhC,oBAAoB,CAACwC,oBAAoB,CAC9CF,QAAQ,CAAC,CAAC,CAAC,EACXjD,IAAI,EACJwB,KAAK,CACN;;MAGH,OAAO,SAAS;IAClB;EAAC;IAAArC,GAAA;IAAAC,KAAA,EAEO,SAAA+D,qBACNC,OAAmB,EACnBpD,IAAY,EACZwB,KAAmB;MAEnB,IAAI4B,OAAO,CAACpB,IAAI,CAACqB,IAAI,KAAK,QAAQ,EAAE;QAClC,IAAM5B,MAAM,GAAuB2B,OAAO,CAACpB,IAAI;QAC/C,IAAMsB,MAAM,GAAGC,MAAM,CAACC,IAAI,CAACxD,IAAI,CAAC,CAC7Bf,GAAG,CAAC,UAACwE,CAAC,EAAI;UACT,IAAMC,CAAC,GAAGjC,MAAM,CAAC6B,MAAM,CAAC3B,MAAM,CAAC,UAAC+B,CAAC;YAAA,OAAKA,CAAC,CAAChF,IAAI,KAAK+E,CAAC;UAAA,EAAC,CAAC,CAAC,CAAC;UACtD,IAAIC,CAAC,KAAKpD,SAAS,EAAE;YACnB,MAAM,IAAIT,KAAK,CAAC,qBAAqB,CAAC;;UAExC,OACE4D,CAAC,GAAG,IAAI,GAAG9C,oBAAoB,CAACuB,aAAa,CAACwB,CAAC,EAAE1D,IAAI,CAACyD,CAAC,CAAC,EAAEjC,KAAK,CAAC;QAEpE,CAAC,CAAC,CACDwB,IAAI,CAAC,IAAI,CAAC;QACb,OAAO,IAAI,GAAGM,MAAM,GAAG,IAAI;OAC5B,MAAM;QACL,IAAIF,OAAO,CAACpB,IAAI,CAAC2B,QAAQ,CAACtD,MAAM,KAAK,CAAC,EAAE;UACtC,OAAO,IAAI;;QAEb;QACA,IAAI+C,OAAO,CAACpB,IAAI,CAAC2B,QAAQ,CAAC,CAAC,CAAC,CAACjF,IAAI,EAAE;UACjC,IAAMiF,QAAQ,GAAGP,OAAO,CAACpB,IAAI,CAAC2B,QAAQ;UACtC,IAAMC,OAAO,GAAGL,MAAM,CAACC,IAAI,CAACxD,IAAI,CAAC,CAAC,CAAC,CAAC;UACpC,IAAM6D,QAAQ,GAAG7D,IAAI,CAAC4D,OAAO,CAAC;UAC9B,IAAME,WAAW,GAAGP,MAAM,CAACC,IAAI,CAACK,QAAQ,CAAC,CACtC5E,GAAG,CAAC,UAACyE,CAAC,EAAI;;YACT,IAAMK,SAAS,GAAGF,QAAQ,CAACH,CAAC,CAAC;YAC7B,IAAM3B,QAAQ,GAAG,CAAAV,EAAA,GAAAsC,QAAQ,CAACC,OAAO,CAAC,cAAAvC,EAAA,uBAAAA,EAAA,CAAEM,MAAM,CACxC,UAACqC,CAAW;cAAA,OAAKA,CAAC,CAACtF,IAAI,KAAKgF,CAAC;YAAA,GAC7B,CAAC,CAAC;YACJ,IAAI3B,QAAQ,KAAKzB,SAAS,EAAE;cAC1B,MAAM,IAAIT,KAAK,CAAC,wBAAwB,CAAC;;YAE3C,OACE6D,CAAC,GACD,IAAI,GACJ/C,oBAAoB,CAACuB,aAAa,CAACH,QAAQ,EAAEgC,SAAS,EAAEvC,KAAK,CAAC;UAElE,CAAC,CAAC,CACDwB,IAAI,CAAC,IAAI,CAAC;UAEb,IAAMiB,WAAW,GAAG1G,SAAS,CAACqG,OAAO,EAAE;YAAEM,UAAU,EAAE;UAAI,CAAE,CAAC;UAC5D,IAAIJ,WAAW,CAACzD,MAAM,KAAK,CAAC,EAAE;YAC5B,OAAO4D,WAAW;;UAEpB,UAAAnE,MAAA,CAAUmE,WAAW,SAAAnE,MAAA,CAAMgE,WAAW;;QAExC;QAAA,KACK;UACH;UACA,OAAO,sCAAsC;;;IAGnD;EAAC;IAAA3E,GAAA;IAAAC,KAAA,EAEO,SAAAgD,mBACNd,QAA0B,EAC1B6C,MAAe;MAEf;MACA,OAAO7C,QAAQ,CACZrC,GAAG,CAAC,UAACmF,OAAO,EAAI;QACf,IAAMC,OAAO,GAAGC,YAAY,CAACF,OAAO,CAAC1F,IAAI,CAAC;QAC1C;QACA,IAAI0F,OAAO,CAAC9C,QAAQ,EAAE;UACpB,IAAMiD,SAAS,GAAGJ,MAAM,MAAArE,MAAA,CAAMqE,MAAM,SAAArE,MAAA,CAAMuE,OAAO,IAAKA,OAAO;UAC7D;UACA,OAAO1D,oBAAoB,CAACyB,kBAAkB;UAC5C;UACAgC,OAAO,CAAC9C,QAAQ,EAChBiD,SAAS,CACV;SACF,MAAM;UACL,OAAAhC,aAAA,CAAAA,aAAA,KACK6B,OAAO;YACV1F,IAAI,EAAEyF,MAAM,MAAArE,MAAA,CAAMqE,MAAM,SAAArE,MAAA,CAAMuE,OAAO,IAAKA;UAAO;;MAGvD,CAAC,CAAC,CACDG,IAAI,EAAE;IACX;EAAC;EAAA,OAAA7D,oBAAA;AAAA;AAGH,SAAS2D,YAAYA,CAACG,KAAa;EACjC,IAAMC,MAAM,GAAGD,KAAK,CAACE,OAAO,CAAC,UAAU,EAAE,KAAK,CAAC;EAC/C,OAAOD,MAAM,CAACE,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,EAAE,GAAGH,MAAM,CAACzE,KAAK,CAAC,CAAC,CAAC;AACzD"},"metadata":{},"sourceType":"module","externalDependencies":[]}