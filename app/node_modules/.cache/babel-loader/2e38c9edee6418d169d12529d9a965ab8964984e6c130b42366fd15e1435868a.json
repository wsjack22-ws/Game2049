{"ast":null,"code":"import { isPromise, PROMISE_RESOLVED_VOID } from './util.js';\nimport { chooseMethod } from './method-chooser.js';\nimport { fillOptionsWithDefaults } from './options.js';\n\n/**\n * Contains all open channels,\n * used in tests to ensure everything is closed.\n */\nexport var OPEN_BROADCAST_CHANNELS = new Set();\nvar lastId = 0;\nexport var BroadcastChannel = function BroadcastChannel(name, options) {\n  // identifier of the channel to debug stuff\n  this.id = lastId++;\n  OPEN_BROADCAST_CHANNELS.add(this);\n  this.name = name;\n  if (ENFORCED_OPTIONS) {\n    options = ENFORCED_OPTIONS;\n  }\n  this.options = fillOptionsWithDefaults(options);\n  this.method = chooseMethod(this.options);\n\n  // isListening\n  this._iL = false;\n\n  /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */\n  this._onML = null;\n\n  /**\n   * _addEventListeners\n   */\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n\n  /**\n   * Unsend message promises\n   * where the sending is still in progress\n   * @type {Set<Promise>}\n   */\n  this._uMP = new Set();\n\n  /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */\n  this._befC = [];\n\n  /**\n   * _preparePromise\n   */\n  this._prepP = null;\n  _prepareChannel(this);\n};\n\n// STATICS\n\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */\nBroadcastChannel._pubkey = true;\n\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */\nvar ENFORCED_OPTIONS;\nexport function enforceOptions(options) {\n  ENFORCED_OPTIONS = options;\n}\n\n// PROTOTYPE\nBroadcastChannel.prototype = {\n  postMessage: function postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed ' +\n      /**\n       * In the past when this error appeared, it was realy hard to debug.\n       * So now we log the msg together with the error so it at least\n       * gives some clue about where in your application this happens.\n       */\n      JSON.stringify(msg));\n    }\n    return _post(this, 'message', msg);\n  },\n  postInternal: function postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n  set onmessage(fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n    _removeListenerObject(this, 'message', this._onML);\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n  addEventListener: function addEventListener(type, fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener: function removeEventListener(type, fn) {\n    var obj = this._addEL[type].find(function (obj) {\n      return obj.fn === fn;\n    });\n    _removeListenerObject(this, type, obj);\n  },\n  close: function close() {\n    var _this = this;\n    if (this.closed) {\n      return;\n    }\n    OPEN_BROADCAST_CHANNELS[\"delete\"](this);\n    this.closed = true;\n    var awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare\n    // wait until all current sending are processed\n    .then(function () {\n      return Promise.all(Array.from(_this._uMP));\n    })\n    // run before-close hooks\n    .then(function () {\n      return Promise.all(_this._befC.map(function (fn) {\n        return fn();\n      }));\n    })\n    // close the channel\n    .then(function () {\n      return _this.method.close(_this._state);\n    });\n  },\n  get type() {\n    return this.method.type;\n  },\n  get isClosed() {\n    return this.closed;\n  }\n};\n\n/**\n * Post a message over the channel\n * @returns {Promise} that resolved when the message sending is done\n */\nfunction _post(broadcastChannel, type, msg) {\n  var time = broadcastChannel.method.microSeconds();\n  var msgObj = {\n    time: time,\n    type: type,\n    data: msg\n  };\n  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID;\n  return awaitPrepare.then(function () {\n    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);\n\n    // add/remove to unsend messages list\n    broadcastChannel._uMP.add(sendPromise);\n    sendPromise[\"catch\"]().then(function () {\n      return broadcastChannel._uMP[\"delete\"](sendPromise);\n    });\n    return sendPromise;\n  });\n}\nfunction _prepareChannel(channel) {\n  var maybePromise = channel.method.create(channel.name, channel.options);\n  if (isPromise(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(function (s) {\n      // used in tests to simulate slow runtime\n      /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n  _startListening(channel);\n}\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(function (o) {\n    return o !== obj;\n  });\n  _stopListening(channel);\n}\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n\n    var listenerFn = function listenerFn(msgObj) {\n      channel._addEL[msgObj.type].forEach(function (listenerObject) {\n        /**\n         * Getting the current time in JavaScript has no good precision.\n         * So instead of only listening to events that happend 'after' the listener\n         * was added, we also listen to events that happended 100ms before it.\n         * This ensures that when another process, like a WebWorker, sends events\n         * we do not miss them out because their timestamp is a bit off compared to the main process.\n         * Not doing this would make messages missing when we send data directly after subscribing and awaiting a response.\n         * @link https://johnresig.com/blog/accuracy-of-javascript-time/\n         */\n        var hundredMsInMicro = 100 * 1000;\n        var minMessageTime = listenerObject.time - hundredMsInMicro;\n        if (msgObj.time >= minMessageTime) {\n          listenerObject.fn(msgObj.data);\n        } else if (channel.method.type === 'server') {\n          // server msg might lag based on connection.\n          listenerObject.fn(msgObj.data);\n        }\n      });\n    };\n    var time = channel.method.microSeconds();\n    if (channel._prepP) {\n      channel._prepP.then(function () {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // noone is listening, stop subscribing\n    channel._iL = false;\n    var time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}","map":{"version":3,"names":["isPromise","PROMISE_RESOLVED_VOID","chooseMethod","fillOptionsWithDefaults","OPEN_BROADCAST_CHANNELS","Set","lastId","BroadcastChannel","name","options","id","add","ENFORCED_OPTIONS","method","_iL","_onML","_addEL","message","internal","_uMP","_befC","_prepP","_prepareChannel","_pubkey","enforceOptions","prototype","postMessage","msg","closed","Error","JSON","stringify","_post","postInternal","onmessage","fn","time","microSeconds","listenObj","_removeListenerObject","_addListenerObject","addEventListener","type","removeEventListener","obj","find","close","_this","awaitPrepare","then","Promise","all","Array","from","map","_state","isClosed","broadcastChannel","msgObj","data","sendPromise","channel","maybePromise","create","s","_hasMessageListeners","length","push","_startListening","filter","o","_stopListening","listenerFn","forEach","listenerObject","hundredMsInMicro","minMessageTime","onMessage"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@toruslabs/broadcast-channel/dist/esbrowser/broadcast-channel.js"],"sourcesContent":["import { isPromise, PROMISE_RESOLVED_VOID } from './util.js';\nimport { chooseMethod } from './method-chooser.js';\nimport { fillOptionsWithDefaults } from './options.js';\n\n/**\n * Contains all open channels,\n * used in tests to ensure everything is closed.\n */\nexport var OPEN_BROADCAST_CHANNELS = new Set();\nvar lastId = 0;\nexport var BroadcastChannel = function BroadcastChannel(name, options) {\n  // identifier of the channel to debug stuff\n  this.id = lastId++;\n  OPEN_BROADCAST_CHANNELS.add(this);\n  this.name = name;\n  if (ENFORCED_OPTIONS) {\n    options = ENFORCED_OPTIONS;\n  }\n  this.options = fillOptionsWithDefaults(options);\n  this.method = chooseMethod(this.options);\n\n  // isListening\n  this._iL = false;\n\n  /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */\n  this._onML = null;\n\n  /**\n   * _addEventListeners\n   */\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n\n  /**\n   * Unsend message promises\n   * where the sending is still in progress\n   * @type {Set<Promise>}\n   */\n  this._uMP = new Set();\n\n  /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */\n  this._befC = [];\n\n  /**\n   * _preparePromise\n   */\n  this._prepP = null;\n  _prepareChannel(this);\n};\n\n// STATICS\n\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */\nBroadcastChannel._pubkey = true;\n\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */\nvar ENFORCED_OPTIONS;\nexport function enforceOptions(options) {\n  ENFORCED_OPTIONS = options;\n}\n\n// PROTOTYPE\nBroadcastChannel.prototype = {\n  postMessage: function postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed ' +\n      /**\n       * In the past when this error appeared, it was realy hard to debug.\n       * So now we log the msg together with the error so it at least\n       * gives some clue about where in your application this happens.\n       */\n      JSON.stringify(msg));\n    }\n    return _post(this, 'message', msg);\n  },\n  postInternal: function postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n  set onmessage(fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n    _removeListenerObject(this, 'message', this._onML);\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n  addEventListener: function addEventListener(type, fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener: function removeEventListener(type, fn) {\n    var obj = this._addEL[type].find(function (obj) {\n      return obj.fn === fn;\n    });\n    _removeListenerObject(this, type, obj);\n  },\n  close: function close() {\n    var _this = this;\n    if (this.closed) {\n      return;\n    }\n    OPEN_BROADCAST_CHANNELS[\"delete\"](this);\n    this.closed = true;\n    var awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare\n    // wait until all current sending are processed\n    .then(function () {\n      return Promise.all(Array.from(_this._uMP));\n    })\n    // run before-close hooks\n    .then(function () {\n      return Promise.all(_this._befC.map(function (fn) {\n        return fn();\n      }));\n    })\n    // close the channel\n    .then(function () {\n      return _this.method.close(_this._state);\n    });\n  },\n  get type() {\n    return this.method.type;\n  },\n  get isClosed() {\n    return this.closed;\n  }\n};\n\n/**\n * Post a message over the channel\n * @returns {Promise} that resolved when the message sending is done\n */\nfunction _post(broadcastChannel, type, msg) {\n  var time = broadcastChannel.method.microSeconds();\n  var msgObj = {\n    time: time,\n    type: type,\n    data: msg\n  };\n  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID;\n  return awaitPrepare.then(function () {\n    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);\n\n    // add/remove to unsend messages list\n    broadcastChannel._uMP.add(sendPromise);\n    sendPromise[\"catch\"]().then(function () {\n      return broadcastChannel._uMP[\"delete\"](sendPromise);\n    });\n    return sendPromise;\n  });\n}\nfunction _prepareChannel(channel) {\n  var maybePromise = channel.method.create(channel.name, channel.options);\n  if (isPromise(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(function (s) {\n      // used in tests to simulate slow runtime\n      /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n  _startListening(channel);\n}\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(function (o) {\n    return o !== obj;\n  });\n  _stopListening(channel);\n}\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n\n    var listenerFn = function listenerFn(msgObj) {\n      channel._addEL[msgObj.type].forEach(function (listenerObject) {\n        /**\n         * Getting the current time in JavaScript has no good precision.\n         * So instead of only listening to events that happend 'after' the listener\n         * was added, we also listen to events that happended 100ms before it.\n         * This ensures that when another process, like a WebWorker, sends events\n         * we do not miss them out because their timestamp is a bit off compared to the main process.\n         * Not doing this would make messages missing when we send data directly after subscribing and awaiting a response.\n         * @link https://johnresig.com/blog/accuracy-of-javascript-time/\n         */\n        var hundredMsInMicro = 100 * 1000;\n        var minMessageTime = listenerObject.time - hundredMsInMicro;\n        if (msgObj.time >= minMessageTime) {\n          listenerObject.fn(msgObj.data);\n        } else if (channel.method.type === 'server') {\n          // server msg might lag based on connection.\n          listenerObject.fn(msgObj.data);\n        }\n      });\n    };\n    var time = channel.method.microSeconds();\n    if (channel._prepP) {\n      channel._prepP.then(function () {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // noone is listening, stop subscribing\n    channel._iL = false;\n    var time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}