{"ast":null,"code":"import _toConsumableArray from \"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { snakeCase } from \"snake-case\";\nimport { sha256 } from \"js-sha256\";\nimport { IdlError } from \"../error\";\nexport function accountSize(idl, idlAccount) {\n  if (idlAccount.type.kind === \"enum\") {\n    var variantSizes = idlAccount.type.variants.map(function (variant) {\n      if (variant.fields === undefined) {\n        return 0;\n      }\n      return variant.fields.map(function (f) {\n        if (!(typeof f === \"object\" && \"name\" in f)) {\n          throw new Error(\"Tuple enum variants not yet implemented.\");\n        }\n        return typeSize(idl, f.type);\n      }).reduce(function (a, b) {\n        return a + b;\n      });\n    });\n    return Math.max.apply(Math, _toConsumableArray(variantSizes)) + 1;\n  }\n  if (idlAccount.type.fields === undefined) {\n    return 0;\n  }\n  return idlAccount.type.fields.map(function (f) {\n    return typeSize(idl, f.type);\n  }).reduce(function (a, b) {\n    return a + b;\n  }, 0);\n}\n// Returns the size of the type in bytes. For variable length types, just return\n// 1. Users should override this value in such cases.\nfunction typeSize(idl, ty) {\n  var _a, _b;\n  switch (ty) {\n    case \"bool\":\n      return 1;\n    case \"u8\":\n      return 1;\n    case \"i8\":\n      return 1;\n    case \"i16\":\n      return 2;\n    case \"u16\":\n      return 2;\n    case \"u32\":\n      return 4;\n    case \"i32\":\n      return 4;\n    case \"u64\":\n      return 8;\n    case \"i64\":\n      return 8;\n    case \"u128\":\n      return 16;\n    case \"i128\":\n      return 16;\n    case \"bytes\":\n      return 1;\n    case \"string\":\n      return 1;\n    case \"publicKey\":\n      return 32;\n    default:\n      if (\"vec\" in ty) {\n        return 1;\n      }\n      if (\"option\" in ty) {\n        return 1 + typeSize(idl, ty.option);\n      }\n      if (\"defined\" in ty) {\n        var filtered = (_b = (_a = idl.types) === null || _a === void 0 ? void 0 : _a.filter(function (t) {\n          return t.name === ty.defined;\n        })) !== null && _b !== void 0 ? _b : [];\n        if (filtered.length !== 1) {\n          throw new IdlError(\"Type not found: \".concat(JSON.stringify(ty)));\n        }\n        var typeDef = filtered[0];\n        return accountSize(idl, typeDef);\n      }\n      if (\"array\" in ty) {\n        var arrayTy = ty.array[0];\n        var arraySize = ty.array[1];\n        return typeSize(idl, arrayTy) * arraySize;\n      }\n      throw new Error(\"Invalid type \".concat(JSON.stringify(ty)));\n  }\n}\n// Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\nexport function sighash(nameSpace, ixName) {\n  var name = snakeCase(ixName);\n  var preimage = \"\".concat(nameSpace, \":\").concat(name);\n  return Buffer.from(sha256.digest(preimage)).slice(0, 8);\n}","map":{"version":3,"names":["snakeCase","sha256","IdlError","accountSize","idl","idlAccount","type","kind","variantSizes","variants","map","variant","fields","undefined","f","Error","typeSize","reduce","a","b","Math","max","apply","_toConsumableArray","ty","option","filtered","_b","_a","types","filter","t","name","defined","length","concat","JSON","stringify","typeDef","arrayTy","array","arraySize","sighash","nameSpace","ixName","preimage","Buffer","from","digest","slice"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/coder/common.ts"],"sourcesContent":["import { snakeCase } from \"snake-case\";\nimport { sha256 } from \"js-sha256\";\nimport { Idl, IdlField, IdlTypeDef, IdlEnumVariant, IdlType } from \"../idl\";\nimport { IdlError } from \"../error\";\n\nexport function accountSize(idl: Idl, idlAccount: IdlTypeDef): number {\n  if (idlAccount.type.kind === \"enum\") {\n    let variantSizes = idlAccount.type.variants.map(\n      (variant: IdlEnumVariant) => {\n        if (variant.fields === undefined) {\n          return 0;\n        }\n        return variant.fields\n          .map((f: IdlField | IdlType) => {\n            if (!(typeof f === \"object\" && \"name\" in f)) {\n              throw new Error(\"Tuple enum variants not yet implemented.\");\n            }\n            return typeSize(idl, f.type);\n          })\n          .reduce((a: number, b: number) => a + b);\n      }\n    );\n    return Math.max(...variantSizes) + 1;\n  }\n  if (idlAccount.type.fields === undefined) {\n    return 0;\n  }\n  return idlAccount.type.fields\n    .map((f) => typeSize(idl, f.type))\n    .reduce((a, b) => a + b, 0);\n}\n\n// Returns the size of the type in bytes. For variable length types, just return\n// 1. Users should override this value in such cases.\nfunction typeSize(idl: Idl, ty: IdlType): number {\n  switch (ty) {\n    case \"bool\":\n      return 1;\n    case \"u8\":\n      return 1;\n    case \"i8\":\n      return 1;\n    case \"i16\":\n      return 2;\n    case \"u16\":\n      return 2;\n    case \"u32\":\n      return 4;\n    case \"i32\":\n      return 4;\n    case \"u64\":\n      return 8;\n    case \"i64\":\n      return 8;\n    case \"u128\":\n      return 16;\n    case \"i128\":\n      return 16;\n    case \"bytes\":\n      return 1;\n    case \"string\":\n      return 1;\n    case \"publicKey\":\n      return 32;\n    default:\n      if (\"vec\" in ty) {\n        return 1;\n      }\n      if (\"option\" in ty) {\n        return 1 + typeSize(idl, ty.option);\n      }\n      if (\"defined\" in ty) {\n        const filtered = idl.types?.filter((t) => t.name === ty.defined) ?? [];\n        if (filtered.length !== 1) {\n          throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);\n        }\n        let typeDef = filtered[0];\n\n        return accountSize(idl, typeDef);\n      }\n      if (\"array\" in ty) {\n        let arrayTy = ty.array[0];\n        let arraySize = ty.array[1];\n        return typeSize(idl, arrayTy) * arraySize;\n      }\n      throw new Error(`Invalid type ${JSON.stringify(ty)}`);\n  }\n}\n\n// Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\nexport function sighash(nameSpace: string, ixName: string): Buffer {\n  let name = snakeCase(ixName);\n  let preimage = `${nameSpace}:${name}`;\n  return Buffer.from(sha256.digest(preimage)).slice(0, 8);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}