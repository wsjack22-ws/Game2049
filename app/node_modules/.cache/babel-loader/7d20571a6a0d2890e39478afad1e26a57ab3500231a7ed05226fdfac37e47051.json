{"ast":null,"code":"import { Transaction, PublicKey } from '@solana/web3.js';\nimport QRCodeModal from '@walletconnect/qrcode-modal';\nimport WalletConnectClient from '@walletconnect/sign-client';\nimport { getSdkError, parseAccountId } from '@walletconnect/utils';\nimport base58 from 'bs58';\nimport { ClientNotInitializedError, QRCodeModalError } from './errors.js';\nexport var WalletConnectChainID;\n(function (WalletConnectChainID) {\n  WalletConnectChainID[\"Mainnet\"] = \"solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ\";\n  WalletConnectChainID[\"Devnet\"] = \"solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K\";\n})(WalletConnectChainID || (WalletConnectChainID = {}));\nexport var WalletConnectRPCMethods;\n(function (WalletConnectRPCMethods) {\n  WalletConnectRPCMethods[\"signTransaction\"] = \"solana_signTransaction\";\n  WalletConnectRPCMethods[\"signMessage\"] = \"solana_signMessage\";\n})(WalletConnectRPCMethods || (WalletConnectRPCMethods = {}));\nconst getConnectParams = chainId => ({\n  requiredNamespaces: {\n    solana: {\n      chains: [chainId],\n      methods: [WalletConnectRPCMethods.signTransaction, WalletConnectRPCMethods.signMessage],\n      events: []\n    }\n  }\n});\nconst isVersionedTransaction = transaction => 'version' in transaction;\nexport class WalletConnectWallet {\n  constructor(config) {\n    this._options = config.options;\n    this._network = config.network;\n  }\n  async connect() {\n    const client = this._client ?? (await WalletConnectClient.init(this._options));\n    const sessions = client.find(getConnectParams(this._network)).filter(s => s.acknowledged);\n    if (sessions.length) {\n      // select last matching session\n      this._session = sessions[sessions.length - 1];\n      // We assign this variable only after we're sure we've received approval\n      this._client = client;\n      return {\n        publicKey: this.publicKey\n      };\n    } else {\n      const {\n        uri,\n        approval\n      } = await client.connect(getConnectParams(this._network));\n      return new Promise((resolve, reject) => {\n        if (uri) {\n          QRCodeModal.open(uri, () => {\n            reject(new QRCodeModalError());\n          });\n        }\n        approval().then(session => {\n          this._session = session;\n          // We assign this variable only after we're sure we've received approval\n          this._client = client;\n          resolve({\n            publicKey: this.publicKey\n          });\n        }).catch(reject).finally(() => {\n          QRCodeModal.close();\n        });\n      });\n    }\n  }\n  async disconnect() {\n    if (this._client && this._session) {\n      await this._client.disconnect({\n        topic: this._session.topic,\n        reason: getSdkError('USER_DISCONNECTED')\n      });\n      this._session = undefined;\n    } else {\n      throw new ClientNotInitializedError();\n    }\n  }\n  get client() {\n    if (this._client) {\n      // TODO: using client.off throws an error\n      return Object.assign({}, this._client, {\n        off: this._client.removeListener\n      });\n      // return this._client;\n    } else {\n      throw new ClientNotInitializedError();\n    }\n  }\n  get publicKey() {\n    if (this._client && this._session) {\n      const {\n        address\n      } = parseAccountId(this._session.namespaces.solana.accounts[0]);\n      return new PublicKey(address);\n    } else {\n      throw new ClientNotInitializedError();\n    }\n  }\n  async signTransaction(transaction) {\n    if (this._client && this._session) {\n      let rawTransaction;\n      let legacyTransaction;\n      if (isVersionedTransaction(transaction)) {\n        // V0 transactions are serialized and passed in the `transaction` property\n        rawTransaction = Buffer.from(transaction.serialize()).toString('base64');\n        if (transaction.version === 'legacy') {\n          // For backwards-compatible, legacy transactions are spread in the params\n          legacyTransaction = Transaction.from(transaction.serialize());\n        }\n      } else {\n        rawTransaction = transaction.serialize({\n          requireAllSignatures: false,\n          verifySignatures: false\n        }).toString('base64');\n        legacyTransaction = transaction;\n      }\n      const {\n        signature\n      } = await this._client.request({\n        chainId: this._network,\n        topic: this._session.topic,\n        request: {\n          method: WalletConnectRPCMethods.signTransaction,\n          params: {\n            // Passing ...legacyTransaction is deprecated.\n            // All new clients should rely on the `transaction` parameter.\n            // The future versions will stop passing ...legacyTransaction.\n            ...legacyTransaction,\n            // New base64-encoded serialized transaction request parameter\n            transaction: rawTransaction\n          }\n        }\n      });\n      transaction.addSignature(this.publicKey, Buffer.from(base58.decode(signature)));\n      return transaction;\n    } else {\n      throw new ClientNotInitializedError();\n    }\n  }\n  async signMessage(message) {\n    if (this._client && this._session) {\n      const {\n        signature\n      } = await this._client.request({\n        // The network does not change the output of message signing, but this is a required parameter for SignClient\n        chainId: this._network,\n        topic: this._session.topic,\n        request: {\n          method: WalletConnectRPCMethods.signMessage,\n          params: {\n            pubkey: this.publicKey.toString(),\n            message: base58.encode(message)\n          }\n        }\n      });\n      return base58.decode(signature);\n    } else {\n      throw new ClientNotInitializedError();\n    }\n  }\n}","map":{"version":3,"names":["Transaction","PublicKey","QRCodeModal","WalletConnectClient","getSdkError","parseAccountId","base58","ClientNotInitializedError","QRCodeModalError","WalletConnectChainID","WalletConnectRPCMethods","getConnectParams","chainId","requiredNamespaces","solana","chains","methods","signTransaction","signMessage","events","isVersionedTransaction","transaction","WalletConnectWallet","constructor","config","_options","options","_network","network","connect","client","_client","init","sessions","find","filter","s","acknowledged","length","_session","publicKey","uri","approval","Promise","resolve","reject","open","then","session","catch","finally","close","disconnect","topic","reason","undefined","Object","assign","off","removeListener","address","namespaces","accounts","rawTransaction","legacyTransaction","Buffer","from","serialize","toString","version","requireAllSignatures","verifySignatures","signature","request","method","params","addSignature","decode","message","pubkey","encode"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@jnwng/walletconnect-solana/src/adapter.ts"],"sourcesContent":["import { Transaction, VersionedTransaction, PublicKey } from '@solana/web3.js';\nimport QRCodeModal from '@walletconnect/qrcode-modal';\nimport WalletConnectClient from '@walletconnect/sign-client';\nimport type { EngineTypes, SessionTypes, SignClientTypes } from '@walletconnect/types';\nimport { getSdkError, parseAccountId } from '@walletconnect/utils';\nimport base58 from 'bs58';\nimport { ClientNotInitializedError, QRCodeModalError } from './errors.js';\n\nexport interface WalletConnectWalletAdapterConfig {\n    network: WalletConnectChainID;\n    options: SignClientTypes.Options;\n}\n\nexport enum WalletConnectChainID {\n    Mainnet = 'solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ',\n    Devnet = 'solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K',\n}\n\nexport enum WalletConnectRPCMethods {\n    signTransaction = 'solana_signTransaction',\n    signMessage = 'solana_signMessage',\n}\n\ninterface WalletConnectWalletInit {\n    publicKey: PublicKey;\n}\n\nconst getConnectParams = (chainId: WalletConnectChainID): EngineTypes.FindParams => ({\n    requiredNamespaces: {\n        solana: {\n            chains: [chainId],\n            methods: [WalletConnectRPCMethods.signTransaction, WalletConnectRPCMethods.signMessage],\n            events: [],\n        },\n    },\n});\n\nconst isVersionedTransaction = (transaction: Transaction | VersionedTransaction): transaction is VersionedTransaction =>\n    'version' in transaction;\n\nexport class WalletConnectWallet {\n    private _client: WalletConnectClient | undefined;\n    private _session: SessionTypes.Struct | undefined;\n    private readonly _network: WalletConnectChainID;\n    private readonly _options: SignClientTypes.Options;\n\n    constructor(config: WalletConnectWalletAdapterConfig) {\n        this._options = config.options;\n        this._network = config.network;\n    }\n\n    async connect(): Promise<WalletConnectWalletInit> {\n        const client = this._client ?? (await WalletConnectClient.init(this._options));\n        const sessions = client.find(getConnectParams(this._network)).filter((s) => s.acknowledged);\n        if (sessions.length) {\n            // select last matching session\n            this._session = sessions[sessions.length - 1];\n            // We assign this variable only after we're sure we've received approval\n            this._client = client;\n\n            return {\n                publicKey: this.publicKey,\n            };\n        } else {\n            const { uri, approval } = await client.connect(getConnectParams(this._network));\n            return new Promise((resolve, reject) => {\n                if (uri) {\n                    QRCodeModal.open(uri, () => {\n                        reject(new QRCodeModalError());\n                    });\n                }\n\n                approval()\n                    .then((session) => {\n                        this._session = session;\n                        // We assign this variable only after we're sure we've received approval\n                        this._client = client;\n\n                        resolve({ publicKey: this.publicKey });\n                    })\n                    .catch(reject)\n                    .finally(() => {\n                        QRCodeModal.close();\n                    });\n            });\n        }\n    }\n\n    async disconnect() {\n        if (this._client && this._session) {\n            await this._client.disconnect({\n                topic: this._session.topic,\n                reason: getSdkError('USER_DISCONNECTED'),\n            });\n            this._session = undefined;\n        } else {\n            throw new ClientNotInitializedError();\n        }\n    }\n\n    get client(): WalletConnectClient {\n        if (this._client) {\n            // TODO: using client.off throws an error\n            return Object.assign({}, this._client, { off: this._client.removeListener });\n            // return this._client;\n        } else {\n            throw new ClientNotInitializedError();\n        }\n    }\n\n    get publicKey(): PublicKey {\n        if (this._client && this._session) {\n            const { address } = parseAccountId(this._session.namespaces.solana.accounts[0]);\n            return new PublicKey(address);\n        } else {\n            throw new ClientNotInitializedError();\n        }\n    }\n\n    async signTransaction<T extends Transaction | VersionedTransaction>(transaction: T): Promise<T> {\n        if (this._client && this._session) {\n            let rawTransaction: string;\n            let legacyTransaction: Transaction | VersionedTransaction | undefined;\n\n            if (isVersionedTransaction(transaction)) {\n                // V0 transactions are serialized and passed in the `transaction` property\n                rawTransaction = Buffer.from(transaction.serialize()).toString('base64');\n\n                if (transaction.version === 'legacy') {\n                    // For backwards-compatible, legacy transactions are spread in the params\n                    legacyTransaction = Transaction.from(transaction.serialize());\n                }\n            } else {\n                rawTransaction = transaction\n                    .serialize({\n                        requireAllSignatures: false,\n                        verifySignatures: false,\n                    })\n                    .toString('base64');\n                legacyTransaction = transaction;\n            }\n\n            const { signature } = await this._client.request<{ signature: string }>({\n                chainId: this._network,\n                topic: this._session.topic,\n                request: {\n                    method: WalletConnectRPCMethods.signTransaction,\n                    params: {\n                        // Passing ...legacyTransaction is deprecated.\n                        // All new clients should rely on the `transaction` parameter.\n                        // The future versions will stop passing ...legacyTransaction.\n                        ...legacyTransaction,\n                        // New base64-encoded serialized transaction request parameter\n                        transaction: rawTransaction,\n                    },\n                },\n            });\n            transaction.addSignature(this.publicKey, Buffer.from(base58.decode(signature)));\n\n            return transaction;\n        } else {\n            throw new ClientNotInitializedError();\n        }\n    }\n\n    async signMessage(message: Uint8Array): Promise<Uint8Array> {\n        if (this._client && this._session) {\n            const { signature } = await this._client.request<{ signature: string }>({\n                // The network does not change the output of message signing, but this is a required parameter for SignClient\n                chainId: this._network,\n                topic: this._session.topic,\n                request: {\n                    method: WalletConnectRPCMethods.signMessage,\n                    params: { pubkey: this.publicKey.toString(), message: base58.encode(message) },\n                },\n            });\n\n            return base58.decode(signature);\n        } else {\n            throw new ClientNotInitializedError();\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}