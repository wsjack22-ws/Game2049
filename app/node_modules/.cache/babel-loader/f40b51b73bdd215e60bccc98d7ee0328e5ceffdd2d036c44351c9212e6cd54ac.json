{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport EventEmitter from 'eventemitter3';\nimport { WalletNotConnectedError } from './errors.js';\nexport { EventEmitter };\n/**\n * A wallet's readiness describes a series of states that the wallet can be in,\n * depending on what kind of wallet it is. An installable wallet (eg. a browser\n * extension like Phantom) might be `Installed` if we've found the Phantom API\n * in the global scope, or `NotDetected` otherwise. A loadable, zero-install\n * runtime (eg. Torus Wallet) might simply signal that it's `Loadable`. Use this\n * metadata to personalize the wallet list for each user (eg. to show their\n * installed wallets first).\n */\nexport var WalletReadyState;\n(function (WalletReadyState) {\n  /**\n   * User-installable wallets can typically be detected by scanning for an API\n   * that they've injected into the global context. If such an API is present,\n   * we consider the wallet to have been installed.\n   */\n  WalletReadyState[\"Installed\"] = \"Installed\";\n  WalletReadyState[\"NotDetected\"] = \"NotDetected\";\n  /**\n   * Loadable wallets are always available to you. Since you can load them at\n   * any time, it's meaningless to say that they have been detected.\n   */\n  WalletReadyState[\"Loadable\"] = \"Loadable\";\n  /**\n   * If a wallet is not supported on a given platform (eg. server-rendering, or\n   * mobile) then it will stay in the `Unsupported` state.\n   */\n  WalletReadyState[\"Unsupported\"] = \"Unsupported\";\n})(WalletReadyState || (WalletReadyState = {}));\nexport var BaseWalletAdapter = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(BaseWalletAdapter, _EventEmitter);\n  var _super = _createSuper(BaseWalletAdapter);\n  function BaseWalletAdapter() {\n    _classCallCheck(this, BaseWalletAdapter);\n    return _super.apply(this, arguments);\n  }\n  _createClass(BaseWalletAdapter, [{\n    key: \"connected\",\n    get: function get() {\n      return !!this.publicKey;\n    }\n  }, {\n    key: \"autoConnect\",\n    value: function () {\n      var _autoConnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return this.connect();\n            case 2:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function autoConnect() {\n        return _autoConnect.apply(this, arguments);\n      }\n      return autoConnect;\n    }()\n  }, {\n    key: \"prepareTransaction\",\n    value: function () {\n      var _prepareTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(transaction, connection) {\n        var options,\n          publicKey,\n          _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              options = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};\n              publicKey = this.publicKey;\n              if (publicKey) {\n                _context2.next = 4;\n                break;\n              }\n              throw new WalletNotConnectedError();\n            case 4:\n              transaction.feePayer = transaction.feePayer || publicKey;\n              _context2.t0 = transaction.recentBlockhash;\n              if (_context2.t0) {\n                _context2.next = 10;\n                break;\n              }\n              _context2.next = 9;\n              return connection.getLatestBlockhash({\n                commitment: options.preflightCommitment,\n                minContextSlot: options.minContextSlot\n              });\n            case 9:\n              _context2.t0 = _context2.sent.blockhash;\n            case 10:\n              transaction.recentBlockhash = _context2.t0;\n              return _context2.abrupt(\"return\", transaction);\n            case 12:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function prepareTransaction(_x, _x2) {\n        return _prepareTransaction.apply(this, arguments);\n      }\n      return prepareTransaction;\n    }()\n  }]);\n  return BaseWalletAdapter;\n}(EventEmitter);\nexport function scopePollingDetectionStrategy(detect) {\n  // Early return when server-side rendering\n  if (typeof window === 'undefined' || typeof document === 'undefined') return;\n  var disposers = [];\n  function detectAndDispose() {\n    var detected = detect();\n    if (detected) {\n      var _iterator = _createForOfIteratorHelper(disposers),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var dispose = _step.value;\n          dispose();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }\n  // Strategy #1: Try detecting every second.\n  var interval =\n  // TODO: #334 Replace with idle callback strategy.\n  setInterval(detectAndDispose, 1000);\n  disposers.push(function () {\n    return clearInterval(interval);\n  });\n  // Strategy #2: Detect as soon as the DOM becomes 'ready'/'interactive'.\n  if (\n  // Implies that `DOMContentLoaded` has not yet fired.\n  document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', detectAndDispose, {\n      once: true\n    });\n    disposers.push(function () {\n      return document.removeEventListener('DOMContentLoaded', detectAndDispose);\n    });\n  }\n  // Strategy #3: Detect after the `window` has fully loaded.\n  if (\n  // If the `complete` state has been reached, we're too late.\n  document.readyState !== 'complete') {\n    window.addEventListener('load', detectAndDispose, {\n      once: true\n    });\n    disposers.push(function () {\n      return window.removeEventListener('load', detectAndDispose);\n    });\n  }\n  // Strategy #4: Detect synchronously, now.\n  detectAndDispose();\n}\n/**\n * Users on iOS can be redirected into a wallet's in-app browser automatically,\n * if that wallet has a universal link configured to do so\n * But should not be redirected from within a webview, eg. if they're already\n * inside a wallet's browser\n * This function can be used to identify users who are on iOS and can be redirected\n *\n * @returns true if the user can be redirected\n */\nexport function isIosAndRedirectable() {\n  // SSR: return false\n  if (!navigator) return false;\n  var userAgent = navigator.userAgent.toLowerCase();\n  // if on iOS the user agent will contain either iPhone or iPad\n  // caveat: if requesting desktop site then this won't work\n  var isIos = userAgent.includes('iphone') || userAgent.includes('ipad');\n  // if in a webview then it will not include Safari\n  // note that other iOS browsers also include Safari\n  // so we will redirect only if Safari is also included\n  var isSafari = userAgent.includes('safari');\n  return isIos && isSafari;\n}","map":{"version":3,"names":["EventEmitter","WalletNotConnectedError","WalletReadyState","BaseWalletAdapter","_EventEmitter","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","get","publicKey","value","_autoConnect","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","connect","stop","autoConnect","_prepareTransaction","_callee2","transaction","connection","options","_args2","_callee2$","_context2","length","undefined","feePayer","t0","recentBlockhash","getLatestBlockhash","commitment","preflightCommitment","minContextSlot","sent","blockhash","abrupt","prepareTransaction","_x","_x2","scopePollingDetectionStrategy","detect","window","document","disposers","detectAndDispose","detected","_iterator","_createForOfIteratorHelper","_step","s","n","done","dispose","err","e","f","interval","setInterval","push","clearInterval","readyState","addEventListener","once","removeEventListener","isIosAndRedirectable","navigator","userAgent","toLowerCase","isIos","includes","isSafari"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@solana/wallet-adapter-base/src/adapter.ts"],"sourcesContent":["import type { Connection, PublicKey, SendOptions, Signer, Transaction, TransactionSignature } from '@solana/web3.js';\nimport EventEmitter from 'eventemitter3';\nimport { type WalletError, WalletNotConnectedError } from './errors.js';\nimport type { SupportedTransactionVersions, TransactionOrVersionedTransaction } from './transaction.js';\n\nexport { EventEmitter };\n\nexport interface WalletAdapterEvents {\n    connect(publicKey: PublicKey): void;\n    disconnect(): void;\n    error(error: WalletError): void;\n    readyStateChange(readyState: WalletReadyState): void;\n}\n\nexport interface SendTransactionOptions extends SendOptions {\n    signers?: Signer[];\n}\n\n// WalletName is a nominal type that wallet adapters should use, e.g. `'MyCryptoWallet' as WalletName<'MyCryptoWallet'>`\n// https://medium.com/@KevinBGreene/surviving-the-typescript-ecosystem-branding-and-type-tagging-6cf6e516523d\nexport type WalletName<T extends string = string> = T & { __brand__: 'WalletName' };\n\nexport interface WalletAdapterProps<Name extends string = string> {\n    name: WalletName<Name>;\n    url: string;\n    icon: string;\n    readyState: WalletReadyState;\n    publicKey: PublicKey | null;\n    connecting: boolean;\n    connected: boolean;\n    supportedTransactionVersions?: SupportedTransactionVersions;\n\n    autoConnect(): Promise<void>;\n    connect(): Promise<void>;\n    disconnect(): Promise<void>;\n    sendTransaction(\n        transaction: TransactionOrVersionedTransaction<this['supportedTransactionVersions']>,\n        connection: Connection,\n        options?: SendTransactionOptions\n    ): Promise<TransactionSignature>;\n}\n\nexport type WalletAdapter<Name extends string = string> = WalletAdapterProps<Name> & EventEmitter<WalletAdapterEvents>;\n\n/**\n * A wallet's readiness describes a series of states that the wallet can be in,\n * depending on what kind of wallet it is. An installable wallet (eg. a browser\n * extension like Phantom) might be `Installed` if we've found the Phantom API\n * in the global scope, or `NotDetected` otherwise. A loadable, zero-install\n * runtime (eg. Torus Wallet) might simply signal that it's `Loadable`. Use this\n * metadata to personalize the wallet list for each user (eg. to show their\n * installed wallets first).\n */\nexport enum WalletReadyState {\n    /**\n     * User-installable wallets can typically be detected by scanning for an API\n     * that they've injected into the global context. If such an API is present,\n     * we consider the wallet to have been installed.\n     */\n    Installed = 'Installed',\n    NotDetected = 'NotDetected',\n    /**\n     * Loadable wallets are always available to you. Since you can load them at\n     * any time, it's meaningless to say that they have been detected.\n     */\n    Loadable = 'Loadable',\n    /**\n     * If a wallet is not supported on a given platform (eg. server-rendering, or\n     * mobile) then it will stay in the `Unsupported` state.\n     */\n    Unsupported = 'Unsupported',\n}\n\nexport abstract class BaseWalletAdapter<Name extends string = string>\n    extends EventEmitter<WalletAdapterEvents>\n    implements WalletAdapter<Name>\n{\n    abstract name: WalletName<Name>;\n    abstract url: string;\n    abstract icon: string;\n    abstract readyState: WalletReadyState;\n    abstract publicKey: PublicKey | null;\n    abstract connecting: boolean;\n    abstract supportedTransactionVersions?: SupportedTransactionVersions;\n\n    get connected() {\n        return !!this.publicKey;\n    }\n\n    async autoConnect() {\n        await this.connect();\n    }\n\n    abstract connect(): Promise<void>;\n    abstract disconnect(): Promise<void>;\n\n    abstract sendTransaction(\n        transaction: TransactionOrVersionedTransaction<this['supportedTransactionVersions']>,\n        connection: Connection,\n        options?: SendTransactionOptions\n    ): Promise<TransactionSignature>;\n\n    protected async prepareTransaction(\n        transaction: Transaction,\n        connection: Connection,\n        options: SendOptions = {}\n    ): Promise<Transaction> {\n        const publicKey = this.publicKey;\n        if (!publicKey) throw new WalletNotConnectedError();\n\n        transaction.feePayer = transaction.feePayer || publicKey;\n        transaction.recentBlockhash =\n            transaction.recentBlockhash ||\n            (\n                await connection.getLatestBlockhash({\n                    commitment: options.preflightCommitment,\n                    minContextSlot: options.minContextSlot,\n                })\n            ).blockhash;\n\n        return transaction;\n    }\n}\n\nexport function scopePollingDetectionStrategy(detect: () => boolean): void {\n    // Early return when server-side rendering\n    if (typeof window === 'undefined' || typeof document === 'undefined') return;\n\n    const disposers: (() => void)[] = [];\n\n    function detectAndDispose() {\n        const detected = detect();\n        if (detected) {\n            for (const dispose of disposers) {\n                dispose();\n            }\n        }\n    }\n\n    // Strategy #1: Try detecting every second.\n    const interval =\n        // TODO: #334 Replace with idle callback strategy.\n        setInterval(detectAndDispose, 1000);\n    disposers.push(() => clearInterval(interval));\n\n    // Strategy #2: Detect as soon as the DOM becomes 'ready'/'interactive'.\n    if (\n        // Implies that `DOMContentLoaded` has not yet fired.\n        document.readyState === 'loading'\n    ) {\n        document.addEventListener('DOMContentLoaded', detectAndDispose, { once: true });\n        disposers.push(() => document.removeEventListener('DOMContentLoaded', detectAndDispose));\n    }\n\n    // Strategy #3: Detect after the `window` has fully loaded.\n    if (\n        // If the `complete` state has been reached, we're too late.\n        document.readyState !== 'complete'\n    ) {\n        window.addEventListener('load', detectAndDispose, { once: true });\n        disposers.push(() => window.removeEventListener('load', detectAndDispose));\n    }\n\n    // Strategy #4: Detect synchronously, now.\n    detectAndDispose();\n}\n\n/**\n * Users on iOS can be redirected into a wallet's in-app browser automatically,\n * if that wallet has a universal link configured to do so\n * But should not be redirected from within a webview, eg. if they're already\n * inside a wallet's browser\n * This function can be used to identify users who are on iOS and can be redirected\n *\n * @returns true if the user can be redirected\n */\nexport function isIosAndRedirectable() {\n    // SSR: return false\n    if (!navigator) return false;\n\n    const userAgent = navigator.userAgent.toLowerCase();\n\n    // if on iOS the user agent will contain either iPhone or iPad\n    // caveat: if requesting desktop site then this won't work\n    const isIos = userAgent.includes('iphone') || userAgent.includes('ipad');\n\n    // if in a webview then it will not include Safari\n    // note that other iOS browsers also include Safari\n    // so we will redirect only if Safari is also included\n    const isSafari = userAgent.includes('safari');\n\n    return isIos && isSafari;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}