{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getJsonRpcIdValidator = exports.assertIsJsonRpcError = exports.isJsonRpcError = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcResponse = exports.isJsonRpcResponse = exports.assertIsPendingJsonRpcResponse = exports.isPendingJsonRpcResponse = exports.JsonRpcResponseStruct = exports.JsonRpcFailureStruct = exports.JsonRpcSuccessStruct = exports.PendingJsonRpcResponseStruct = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.JsonRpcNotificationStruct = exports.JsonRpcRequestStruct = exports.JsonRpcParamsStruct = exports.JsonRpcErrorStruct = exports.JsonRpcIdStruct = exports.JsonRpcVersionStruct = exports.jsonrpc2 = exports.getJsonSize = exports.isValidJson = exports.JsonStruct = exports.UnsafeJsonStruct = void 0;\nconst superstruct_1 = require(\"superstruct\");\nconst assert_1 = require(\"./assert\");\n/**\n * A struct to check if the given value is finite number. Superstruct's\n * `number()` struct does not check if the value is finite.\n *\n * @returns A struct to check if the given value is finite number.\n */\nconst finiteNumber = () => (0, superstruct_1.define)('finite number', value => {\n  return (0, superstruct_1.is)(value, (0, superstruct_1.number)()) && Number.isFinite(value);\n});\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * Note that this struct is unsafe. For safe validation, use {@link JsonStruct}.\n */\n// We cannot infer the type of the struct, because it is recursive.\nexports.UnsafeJsonStruct = (0, superstruct_1.union)([(0, superstruct_1.literal)(null), (0, superstruct_1.boolean)(), finiteNumber(), (0, superstruct_1.string)(), (0, superstruct_1.array)((0, superstruct_1.lazy)(() => exports.UnsafeJsonStruct)), (0, superstruct_1.record)((0, superstruct_1.string)(), (0, superstruct_1.lazy)(() => exports.UnsafeJsonStruct))]);\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * This struct sanitizes the value before validating it, so that it is safe to\n * use with untrusted input.\n */\nexports.JsonStruct = (0, superstruct_1.define)('Json', (value, context) => {\n  /**\n   * Helper function that runs the given struct validator and returns the\n   * validation errors, if any. If the value is valid, it returns `true`.\n   *\n   * @param innerValue - The value to validate.\n   * @param struct - The struct to use for validation.\n   * @returns The validation errors, or `true` if the value is valid.\n   */\n  function checkStruct(innerValue, struct) {\n    const iterator = struct.validator(innerValue, context);\n    const errors = [...iterator];\n    if (errors.length > 0) {\n      return errors;\n    }\n    return true;\n  }\n  try {\n    // The plain value must be a valid JSON value, but it may be altered in the\n    // process of JSON serialization, so we need to validate it again after\n    // serialization. This has the added benefit that the returned error messages\n    // will be more helpful, as they will point to the exact location of the\n    // invalid value.\n    //\n    // This seems overcomplicated, but without checking the plain value first,\n    // there are some cases where the validation passes, even though the value is\n    // not valid JSON. For example, `undefined` is not valid JSON, but serializing\n    // it will remove it from the object, so the validation will pass.\n    const unsafeResult = checkStruct(value, exports.UnsafeJsonStruct);\n    if (unsafeResult !== true) {\n      return unsafeResult;\n    }\n    // JavaScript engines are highly optimized for this specific use case of\n    // JSON parsing and stringifying, so there should be no performance impact.\n    return checkStruct(JSON.parse(JSON.stringify(value)), exports.UnsafeJsonStruct);\n  } catch (error) {\n    if (error instanceof RangeError) {\n      return 'Circular reference detected';\n    }\n    return false;\n  }\n});\n/**\n * Check if the given value is a valid {@link Json} value, i.e., a value that is\n * serializable to JSON.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link Json} value.\n */\nfunction isValidJson(value) {\n  return (0, superstruct_1.is)(value, exports.JsonStruct);\n}\nexports.isValidJson = isValidJson;\n/**\n * Get the size of a JSON value in bytes. This also validates the value.\n *\n * @param value - The JSON value to get the size of.\n * @returns The size of the JSON value in bytes.\n */\nfunction getJsonSize(value) {\n  (0, assert_1.assertStruct)(value, exports.JsonStruct, 'Invalid JSON value');\n  const json = JSON.stringify(value);\n  return new TextEncoder().encode(json).byteLength;\n}\nexports.getJsonSize = getJsonSize;\n/**\n * The string '2.0'.\n */\nexports.jsonrpc2 = '2.0';\nexports.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports.jsonrpc2);\nexports.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.string)()]));\nexports.JsonRpcErrorStruct = (0, superstruct_1.object)({\n  code: (0, superstruct_1.integer)(),\n  message: (0, superstruct_1.string)(),\n  data: (0, superstruct_1.optional)(exports.JsonStruct),\n  stack: (0, superstruct_1.optional)((0, superstruct_1.string)())\n});\nexports.JsonRpcParamsStruct = (0, superstruct_1.optional)((0, superstruct_1.union)([(0, superstruct_1.record)((0, superstruct_1.string)(), exports.JsonStruct), (0, superstruct_1.array)(exports.JsonStruct)]));\nexports.JsonRpcRequestStruct = (0, superstruct_1.object)({\n  id: exports.JsonRpcIdStruct,\n  jsonrpc: exports.JsonRpcVersionStruct,\n  method: (0, superstruct_1.string)(),\n  params: exports.JsonRpcParamsStruct\n});\nexports.JsonRpcNotificationStruct = (0, superstruct_1.omit)(exports.JsonRpcRequestStruct, ['id']);\n/**\n * Check if the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcNotification}\n * object.\n */\nfunction isJsonRpcNotification(value) {\n  return (0, superstruct_1.is)(value, exports.JsonRpcNotificationStruct);\n}\nexports.isJsonRpcNotification = isJsonRpcNotification;\n/**\n * Assert that the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcNotification} object.\n */\nfunction assertIsJsonRpcNotification(value,\n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n  (0, assert_1.assertStruct)(value, exports.JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);\n}\nexports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;\n/**\n * Check if the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcRequest} object.\n */\nfunction isJsonRpcRequest(value) {\n  return (0, superstruct_1.is)(value, exports.JsonRpcRequestStruct);\n}\nexports.isJsonRpcRequest = isJsonRpcRequest;\n/**\n * Assert that the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The JSON-RPC request or notification to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcRequest} object.\n */\nfunction assertIsJsonRpcRequest(value,\n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n  (0, assert_1.assertStruct)(value, exports.JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);\n}\nexports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;\nexports.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({\n  id: exports.JsonRpcIdStruct,\n  jsonrpc: exports.JsonRpcVersionStruct,\n  result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),\n  error: (0, superstruct_1.optional)(exports.JsonRpcErrorStruct)\n});\nexports.JsonRpcSuccessStruct = (0, superstruct_1.object)({\n  id: exports.JsonRpcIdStruct,\n  jsonrpc: exports.JsonRpcVersionStruct,\n  result: exports.JsonStruct\n});\nexports.JsonRpcFailureStruct = (0, superstruct_1.object)({\n  id: exports.JsonRpcIdStruct,\n  jsonrpc: exports.JsonRpcVersionStruct,\n  error: exports.JsonRpcErrorStruct\n});\nexports.JsonRpcResponseStruct = (0, superstruct_1.union)([exports.JsonRpcSuccessStruct, exports.JsonRpcFailureStruct]);\n/**\n * Type guard to check whether specified JSON-RPC response is a\n * {@link PendingJsonRpcResponse}.\n *\n * @param response - The JSON-RPC response to check.\n * @returns Whether the specified JSON-RPC response is pending.\n */\nfunction isPendingJsonRpcResponse(response) {\n  return (0, superstruct_1.is)(response, exports.PendingJsonRpcResponseStruct);\n}\nexports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;\n/**\n * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.\n *\n * @param response - The JSON-RPC response to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link PendingJsonRpcResponse}\n * object.\n */\nfunction assertIsPendingJsonRpcResponse(response,\n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n  (0, assert_1.assertStruct)(response, exports.PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);\n}\nexports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;\n/**\n * Type guard to check if a value is a {@link JsonRpcResponse}.\n *\n * @param response - The object to check.\n * @returns Whether the object is a JsonRpcResponse.\n */\nfunction isJsonRpcResponse(response) {\n  return (0, superstruct_1.is)(response, exports.JsonRpcResponseStruct);\n}\nexports.isJsonRpcResponse = isJsonRpcResponse;\n/**\n * Assert that the given value is a valid {@link JsonRpcResponse} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcResponse} object.\n */\nfunction assertIsJsonRpcResponse(value,\n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n  (0, assert_1.assertStruct)(value, exports.JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);\n}\nexports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;\n/**\n * Check if the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.\n */\nfunction isJsonRpcSuccess(value) {\n  return (0, superstruct_1.is)(value, exports.JsonRpcSuccessStruct);\n}\nexports.isJsonRpcSuccess = isJsonRpcSuccess;\n/**\n * Assert that the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcSuccess} object.\n */\nfunction assertIsJsonRpcSuccess(value,\n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n  (0, assert_1.assertStruct)(value, exports.JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);\n}\nexports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;\n/**\n * Check if the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcFailure} object.\n */\nfunction isJsonRpcFailure(value) {\n  return (0, superstruct_1.is)(value, exports.JsonRpcFailureStruct);\n}\nexports.isJsonRpcFailure = isJsonRpcFailure;\n/**\n * Assert that the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcFailure} object.\n */\nfunction assertIsJsonRpcFailure(value,\n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n  (0, assert_1.assertStruct)(value, exports.JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);\n}\nexports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;\n/**\n * Check if the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcError} object.\n */\nfunction isJsonRpcError(value) {\n  return (0, superstruct_1.is)(value, exports.JsonRpcErrorStruct);\n}\nexports.isJsonRpcError = isJsonRpcError;\n/**\n * Assert that the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcError} object.\n */\nfunction assertIsJsonRpcError(value,\n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n  (0, assert_1.assertStruct)(value, exports.JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);\n}\nexports.assertIsJsonRpcError = assertIsJsonRpcError;\n/**\n * Gets a function for validating JSON-RPC request / response `id` values.\n *\n * By manipulating the options of this factory, you can control the behavior\n * of the resulting validator for some edge cases. This is useful because e.g.\n * `null` should sometimes but not always be permitted.\n *\n * Note that the empty string (`''`) is always permitted by the JSON-RPC\n * specification, but that kind of sucks and you may want to forbid it in some\n * instances anyway.\n *\n * For more details, see the\n * [JSON-RPC Specification](https://www.jsonrpc.org/specification).\n *\n * @param options - An options object.\n * @param options.permitEmptyString - Whether the empty string (i.e. `''`)\n * should be treated as a valid ID. Default: `true`\n * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)\n * should be treated as valid IDs. Default: `false`\n * @param options.permitNull - Whether `null` should be treated as a valid ID.\n * Default: `true`\n * @returns The JSON-RPC ID validator function.\n */\nfunction getJsonRpcIdValidator(options) {\n  const {\n    permitEmptyString,\n    permitFractions,\n    permitNull\n  } = Object.assign({\n    permitEmptyString: true,\n    permitFractions: false,\n    permitNull: true\n  }, options);\n  /**\n   * Type guard for {@link JsonRpcId}.\n   *\n   * @param id - The JSON-RPC ID value to check.\n   * @returns Whether the given ID is valid per the options given to the\n   * factory.\n   */\n  const isValidJsonRpcId = id => {\n    return Boolean(typeof id === 'number' && (permitFractions || Number.isInteger(id)) || typeof id === 'string' && (permitEmptyString || id.length > 0) || permitNull && id === null);\n  };\n  return isValidJsonRpcId;\n}\nexports.getJsonRpcIdValidator = getJsonRpcIdValidator;","map":{"version":3,"names":["superstruct_1","require","assert_1","finiteNumber","define","value","is","number","Number","isFinite","exports","UnsafeJsonStruct","union","literal","boolean","string","array","lazy","record","JsonStruct","context","checkStruct","innerValue","struct","iterator","validator","errors","length","unsafeResult","JSON","parse","stringify","error","RangeError","isValidJson","getJsonSize","assertStruct","json","TextEncoder","encode","byteLength","jsonrpc2","JsonRpcVersionStruct","JsonRpcIdStruct","nullable","JsonRpcErrorStruct","object","code","integer","message","data","optional","stack","JsonRpcParamsStruct","JsonRpcRequestStruct","id","jsonrpc","method","params","JsonRpcNotificationStruct","omit","isJsonRpcNotification","assertIsJsonRpcNotification","ErrorWrapper","isJsonRpcRequest","assertIsJsonRpcRequest","PendingJsonRpcResponseStruct","result","unknown","JsonRpcSuccessStruct","JsonRpcFailureStruct","JsonRpcResponseStruct","isPendingJsonRpcResponse","response","assertIsPendingJsonRpcResponse","isJsonRpcResponse","assertIsJsonRpcResponse","isJsonRpcSuccess","assertIsJsonRpcSuccess","isJsonRpcFailure","assertIsJsonRpcFailure","isJsonRpcError","assertIsJsonRpcError","getJsonRpcIdValidator","options","permitEmptyString","permitFractions","permitNull","Object","assign","isValidJsonRpcId","Boolean","isInteger"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@metamask/utils/src/json.ts"],"sourcesContent":["import {\n  array,\n  boolean,\n  define,\n  Infer,\n  integer,\n  is,\n  lazy,\n  literal,\n  nullable,\n  number,\n  object,\n  omit,\n  optional,\n  record,\n  string,\n  Struct,\n  union,\n  unknown,\n} from 'superstruct';\n\nimport { AssertionErrorConstructor, assertStruct } from './assert';\n\n/**\n * Any JSON-compatible value.\n */\nexport type Json =\n  | null\n  | boolean\n  | number\n  | string\n  | Json[]\n  | { [prop: string]: Json };\n\n/**\n * A struct to check if the given value is finite number. Superstruct's\n * `number()` struct does not check if the value is finite.\n *\n * @returns A struct to check if the given value is finite number.\n */\nconst finiteNumber = () =>\n  define<number>('finite number', (value) => {\n    return is(value, number()) && Number.isFinite(value);\n  });\n\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * Note that this struct is unsafe. For safe validation, use {@link JsonStruct}.\n */\n// We cannot infer the type of the struct, because it is recursive.\nexport const UnsafeJsonStruct: Struct<Json> = union([\n  literal(null),\n  boolean(),\n  finiteNumber(),\n  string(),\n  array(lazy(() => UnsafeJsonStruct)),\n  record(\n    string(),\n    lazy(() => UnsafeJsonStruct),\n  ),\n]);\n\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * This struct sanitizes the value before validating it, so that it is safe to\n * use with untrusted input.\n */\nexport const JsonStruct = define<Json>('Json', (value, context) => {\n  /**\n   * Helper function that runs the given struct validator and returns the\n   * validation errors, if any. If the value is valid, it returns `true`.\n   *\n   * @param innerValue - The value to validate.\n   * @param struct - The struct to use for validation.\n   * @returns The validation errors, or `true` if the value is valid.\n   */\n  function checkStruct<Type>(innerValue: unknown, struct: Struct<Type>) {\n    const iterator = struct.validator(innerValue, context);\n    const errors = [...iterator];\n\n    if (errors.length > 0) {\n      return errors;\n    }\n\n    return true;\n  }\n\n  try {\n    // The plain value must be a valid JSON value, but it may be altered in the\n    // process of JSON serialization, so we need to validate it again after\n    // serialization. This has the added benefit that the returned error messages\n    // will be more helpful, as they will point to the exact location of the\n    // invalid value.\n    //\n    // This seems overcomplicated, but without checking the plain value first,\n    // there are some cases where the validation passes, even though the value is\n    // not valid JSON. For example, `undefined` is not valid JSON, but serializing\n    // it will remove it from the object, so the validation will pass.\n    const unsafeResult = checkStruct(value, UnsafeJsonStruct);\n    if (unsafeResult !== true) {\n      return unsafeResult;\n    }\n\n    // JavaScript engines are highly optimized for this specific use case of\n    // JSON parsing and stringifying, so there should be no performance impact.\n    return checkStruct(JSON.parse(JSON.stringify(value)), UnsafeJsonStruct);\n  } catch (error) {\n    if (error instanceof RangeError) {\n      return 'Circular reference detected';\n    }\n\n    return false;\n  }\n});\n\n/**\n * Check if the given value is a valid {@link Json} value, i.e., a value that is\n * serializable to JSON.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link Json} value.\n */\nexport function isValidJson(value: unknown): value is Json {\n  return is(value, JsonStruct);\n}\n\n/**\n * Get the size of a JSON value in bytes. This also validates the value.\n *\n * @param value - The JSON value to get the size of.\n * @returns The size of the JSON value in bytes.\n */\nexport function getJsonSize(value: unknown): number {\n  assertStruct(value, JsonStruct, 'Invalid JSON value');\n\n  const json = JSON.stringify(value);\n  return new TextEncoder().encode(json).byteLength;\n}\n\n/**\n * The string '2.0'.\n */\nexport const jsonrpc2 = '2.0' as const;\nexport const JsonRpcVersionStruct = literal(jsonrpc2);\n\n/**\n * A String specifying the version of the JSON-RPC protocol.\n * MUST be exactly \"2.0\".\n */\nexport type JsonRpcVersion2 = typeof jsonrpc2;\n\nexport const JsonRpcIdStruct = nullable(union([number(), string()]));\n\n/**\n * An identifier established by the Client that MUST contain a String, Number,\n * or NULL value if included. If it is not included it is assumed to be a\n * notification. The value SHOULD normally not be Null and Numbers SHOULD\n * NOT contain fractional parts.\n */\nexport type JsonRpcId = Infer<typeof JsonRpcIdStruct>;\n\nexport const JsonRpcErrorStruct = object({\n  code: integer(),\n  message: string(),\n  data: optional(JsonStruct),\n  stack: optional(string()),\n});\n\n/**\n * Mark a certain key of a type as optional.\n */\nexport type OptionalField<\n  Type extends Record<string, unknown>,\n  Key extends keyof Type,\n> = Omit<Type, Key> & Partial<Pick<Type, Key>>;\n\n/**\n * A JSON-RPC error object.\n *\n * Note that TypeScript infers `unknown | undefined` as `unknown`, meaning that\n * the `data` field is not optional. To make it optional, we use the\n * `OptionalField` helper, to explicitly make it optional.\n */\nexport type JsonRpcError = OptionalField<\n  Infer<typeof JsonRpcErrorStruct>,\n  'data'\n>;\n\nexport const JsonRpcParamsStruct = optional(\n  union([record(string(), JsonStruct), array(JsonStruct)]),\n);\nexport type JsonRpcParams = Infer<typeof JsonRpcParamsStruct>;\n\nexport const JsonRpcRequestStruct = object({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  method: string(),\n  params: JsonRpcParamsStruct,\n});\n\nexport type InferWithParams<\n  Type extends Struct<any>,\n  Params extends JsonRpcParams,\n> = Omit<Infer<Type>, 'params'> &\n  (keyof Params extends undefined\n    ? {\n        params?: Params;\n      }\n    : {\n        params: Params;\n      });\n\n/**\n * A JSON-RPC request object.\n */\nexport type JsonRpcRequest<Params extends JsonRpcParams = JsonRpcParams> =\n  InferWithParams<typeof JsonRpcRequestStruct, Params>;\n\nexport const JsonRpcNotificationStruct = omit(JsonRpcRequestStruct, ['id']);\n\n/**\n * A JSON-RPC notification object.\n */\nexport type JsonRpcNotification<Params extends JsonRpcParams = JsonRpcParams> =\n  InferWithParams<typeof JsonRpcNotificationStruct, Params>;\n\n/**\n * Check if the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcNotification}\n * object.\n */\nexport function isJsonRpcNotification(\n  value: unknown,\n): value is JsonRpcNotification {\n  return is(value, JsonRpcNotificationStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcNotification} object.\n */\nexport function assertIsJsonRpcNotification(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcNotification {\n  assertStruct(\n    value,\n    JsonRpcNotificationStruct,\n    'Invalid JSON-RPC notification',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Check if the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcRequest} object.\n */\nexport function isJsonRpcRequest(value: unknown): value is JsonRpcRequest {\n  return is(value, JsonRpcRequestStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The JSON-RPC request or notification to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcRequest} object.\n */\nexport function assertIsJsonRpcRequest(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcRequest {\n  assertStruct(\n    value,\n    JsonRpcRequestStruct,\n    'Invalid JSON-RPC request',\n    ErrorWrapper,\n  );\n}\n\nexport const PendingJsonRpcResponseStruct = object({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  result: optional(unknown()),\n  error: optional(JsonRpcErrorStruct),\n});\n\n/**\n * A JSON-RPC response object that has not yet been resolved.\n */\nexport type PendingJsonRpcResponse<Result extends Json> = Omit<\n  Infer<typeof PendingJsonRpcResponseStruct>,\n  'result'\n> & {\n  result?: Result;\n};\n\nexport const JsonRpcSuccessStruct = object({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  result: JsonStruct,\n});\n\n/**\n * A successful JSON-RPC response object.\n */\nexport type JsonRpcSuccess<Result extends Json> = Omit<\n  Infer<typeof JsonRpcSuccessStruct>,\n  'result'\n> & {\n  result: Result;\n};\n\nexport const JsonRpcFailureStruct = object({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  error: JsonRpcErrorStruct as Struct<JsonRpcError>,\n});\n\n/**\n * A failed JSON-RPC response object.\n */\nexport type JsonRpcFailure = Infer<typeof JsonRpcFailureStruct>;\n\nexport const JsonRpcResponseStruct = union([\n  JsonRpcSuccessStruct,\n  JsonRpcFailureStruct,\n]);\n\n/**\n * A JSON-RPC response object. Must be checked to determine whether it's a\n * success or failure.\n *\n * @template Result - The type of the result.\n */\nexport type JsonRpcResponse<Result extends Json> =\n  | JsonRpcSuccess<Result>\n  | JsonRpcFailure;\n\n/**\n * Type guard to check whether specified JSON-RPC response is a\n * {@link PendingJsonRpcResponse}.\n *\n * @param response - The JSON-RPC response to check.\n * @returns Whether the specified JSON-RPC response is pending.\n */\nexport function isPendingJsonRpcResponse(\n  response: unknown,\n): response is PendingJsonRpcResponse<Json> {\n  return is(response, PendingJsonRpcResponseStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.\n *\n * @param response - The JSON-RPC response to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link PendingJsonRpcResponse}\n * object.\n */\nexport function assertIsPendingJsonRpcResponse(\n  response: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts response is PendingJsonRpcResponse<Json> {\n  assertStruct(\n    response,\n    PendingJsonRpcResponseStruct,\n    'Invalid pending JSON-RPC response',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Type guard to check if a value is a {@link JsonRpcResponse}.\n *\n * @param response - The object to check.\n * @returns Whether the object is a JsonRpcResponse.\n */\nexport function isJsonRpcResponse(\n  response: unknown,\n): response is JsonRpcResponse<Json> {\n  return is(response, JsonRpcResponseStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcResponse} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcResponse} object.\n */\nexport function assertIsJsonRpcResponse(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcResponse<Json> {\n  assertStruct(\n    value,\n    JsonRpcResponseStruct,\n    'Invalid JSON-RPC response',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Check if the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.\n */\nexport function isJsonRpcSuccess(\n  value: unknown,\n): value is JsonRpcSuccess<Json> {\n  return is(value, JsonRpcSuccessStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcSuccess} object.\n */\nexport function assertIsJsonRpcSuccess(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcSuccess<Json> {\n  assertStruct(\n    value,\n    JsonRpcSuccessStruct,\n    'Invalid JSON-RPC success response',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Check if the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcFailure} object.\n */\nexport function isJsonRpcFailure(value: unknown): value is JsonRpcFailure {\n  return is(value, JsonRpcFailureStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcFailure} object.\n */\nexport function assertIsJsonRpcFailure(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcFailure {\n  assertStruct(\n    value,\n    JsonRpcFailureStruct,\n    'Invalid JSON-RPC failure response',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Check if the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcError} object.\n */\nexport function isJsonRpcError(value: unknown): value is JsonRpcError {\n  return is(value, JsonRpcErrorStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcError} object.\n */\nexport function assertIsJsonRpcError(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcError {\n  assertStruct(\n    value,\n    JsonRpcErrorStruct,\n    'Invalid JSON-RPC error',\n    ErrorWrapper,\n  );\n}\n\ntype JsonRpcValidatorOptions = {\n  permitEmptyString?: boolean;\n  permitFractions?: boolean;\n  permitNull?: boolean;\n};\n\n/**\n * Gets a function for validating JSON-RPC request / response `id` values.\n *\n * By manipulating the options of this factory, you can control the behavior\n * of the resulting validator for some edge cases. This is useful because e.g.\n * `null` should sometimes but not always be permitted.\n *\n * Note that the empty string (`''`) is always permitted by the JSON-RPC\n * specification, but that kind of sucks and you may want to forbid it in some\n * instances anyway.\n *\n * For more details, see the\n * [JSON-RPC Specification](https://www.jsonrpc.org/specification).\n *\n * @param options - An options object.\n * @param options.permitEmptyString - Whether the empty string (i.e. `''`)\n * should be treated as a valid ID. Default: `true`\n * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)\n * should be treated as valid IDs. Default: `false`\n * @param options.permitNull - Whether `null` should be treated as a valid ID.\n * Default: `true`\n * @returns The JSON-RPC ID validator function.\n */\nexport function getJsonRpcIdValidator(options?: JsonRpcValidatorOptions) {\n  const { permitEmptyString, permitFractions, permitNull } = {\n    permitEmptyString: true,\n    permitFractions: false,\n    permitNull: true,\n    ...options,\n  };\n\n  /**\n   * Type guard for {@link JsonRpcId}.\n   *\n   * @param id - The JSON-RPC ID value to check.\n   * @returns Whether the given ID is valid per the options given to the\n   * factory.\n   */\n  const isValidJsonRpcId = (id: unknown): id is JsonRpcId => {\n    return Boolean(\n      (typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||\n        (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||\n        (permitNull && id === null),\n    );\n  };\n\n  return isValidJsonRpcId;\n}\n"],"mappings":";;;;;;AAAA,MAAAA,aAAA,GAAAC,OAAA;AAqBA,MAAAC,QAAA,GAAAD,OAAA;AAaA;;;;;;AAMA,MAAME,YAAY,GAAGA,CAAA,KACnB,IAAAH,aAAA,CAAAI,MAAM,EAAS,eAAe,EAAGC,KAAK,IAAI;EACxC,OAAO,IAAAL,aAAA,CAAAM,EAAE,EAACD,KAAK,EAAE,IAAAL,aAAA,CAAAO,MAAM,GAAE,CAAC,IAAIC,MAAM,CAACC,QAAQ,CAACJ,KAAK,CAAC;AACtD,CAAC,CAAC;AAEJ;;;;;AAKA;AACaK,OAAA,CAAAC,gBAAgB,GAAiB,IAAAX,aAAA,CAAAY,KAAK,EAAC,CAClD,IAAAZ,aAAA,CAAAa,OAAO,EAAC,IAAI,CAAC,EACb,IAAAb,aAAA,CAAAc,OAAO,GAAE,EACTX,YAAY,EAAE,EACd,IAAAH,aAAA,CAAAe,MAAM,GAAE,EACR,IAAAf,aAAA,CAAAgB,KAAK,EAAC,IAAAhB,aAAA,CAAAiB,IAAI,EAAC,MAAMP,OAAA,CAAAC,gBAAgB,CAAC,CAAC,EACnC,IAAAX,aAAA,CAAAkB,MAAM,EACJ,IAAAlB,aAAA,CAAAe,MAAM,GAAE,EACR,IAAAf,aAAA,CAAAiB,IAAI,EAAC,MAAMP,OAAA,CAAAC,gBAAgB,CAAC,CAC7B,CACF,CAAC;AAEF;;;;;;AAMaD,OAAA,CAAAS,UAAU,GAAG,IAAAnB,aAAA,CAAAI,MAAM,EAAO,MAAM,EAAE,CAACC,KAAK,EAAEe,OAAO,KAAI;EAChE;;;;;;;;EAQA,SAASC,WAAWA,CAAOC,UAAmB,EAAEC,MAAoB;IAClE,MAAMC,QAAQ,GAAGD,MAAM,CAACE,SAAS,CAACH,UAAU,EAAEF,OAAO,CAAC;IACtD,MAAMM,MAAM,GAAG,CAAC,GAAGF,QAAQ,CAAC;IAE5B,IAAIE,MAAM,CAACC,MAAM,GAAG,CAAC,EAAE;MACrB,OAAOD,MAAM;;IAGf,OAAO,IAAI;EACb;EAEA,IAAI;IACF;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,MAAME,YAAY,GAAGP,WAAW,CAAChB,KAAK,EAAEK,OAAA,CAAAC,gBAAgB,CAAC;IACzD,IAAIiB,YAAY,KAAK,IAAI,EAAE;MACzB,OAAOA,YAAY;;IAGrB;IACA;IACA,OAAOP,WAAW,CAACQ,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAAC1B,KAAK,CAAC,CAAC,EAAEK,OAAA,CAAAC,gBAAgB,CAAC;GACxE,CAAC,OAAOqB,KAAK,EAAE;IACd,IAAIA,KAAK,YAAYC,UAAU,EAAE;MAC/B,OAAO,6BAA6B;;IAGtC,OAAO,KAAK;;AAEhB,CAAC,CAAC;AAEF;;;;;;;AAOA,SAAgBC,WAAWA,CAAC7B,KAAc;EACxC,OAAO,IAAAL,aAAA,CAAAM,EAAE,EAACD,KAAK,EAAEK,OAAA,CAAAS,UAAU,CAAC;AAC9B;AAFAT,OAAA,CAAAwB,WAAA,GAAAA,WAAA;AAIA;;;;;;AAMA,SAAgBC,WAAWA,CAAC9B,KAAc;EACxC,IAAAH,QAAA,CAAAkC,YAAY,EAAC/B,KAAK,EAAEK,OAAA,CAAAS,UAAU,EAAE,oBAAoB,CAAC;EAErD,MAAMkB,IAAI,GAAGR,IAAI,CAACE,SAAS,CAAC1B,KAAK,CAAC;EAClC,OAAO,IAAIiC,WAAW,EAAE,CAACC,MAAM,CAACF,IAAI,CAAC,CAACG,UAAU;AAClD;AALA9B,OAAA,CAAAyB,WAAA,GAAAA,WAAA;AAOA;;;AAGazB,OAAA,CAAA+B,QAAQ,GAAG,KAAc;AACzB/B,OAAA,CAAAgC,oBAAoB,GAAG,IAAA1C,aAAA,CAAAa,OAAO,EAACH,OAAA,CAAA+B,QAAQ,CAAC;AAQxC/B,OAAA,CAAAiC,eAAe,GAAG,IAAA3C,aAAA,CAAA4C,QAAQ,EAAC,IAAA5C,aAAA,CAAAY,KAAK,EAAC,CAAC,IAAAZ,aAAA,CAAAO,MAAM,GAAE,EAAE,IAAAP,aAAA,CAAAe,MAAM,GAAE,CAAC,CAAC,CAAC;AAUvDL,OAAA,CAAAmC,kBAAkB,GAAG,IAAA7C,aAAA,CAAA8C,MAAM,EAAC;EACvCC,IAAI,EAAE,IAAA/C,aAAA,CAAAgD,OAAO,GAAE;EACfC,OAAO,EAAE,IAAAjD,aAAA,CAAAe,MAAM,GAAE;EACjBmC,IAAI,EAAE,IAAAlD,aAAA,CAAAmD,QAAQ,EAACzC,OAAA,CAAAS,UAAU,CAAC;EAC1BiC,KAAK,EAAE,IAAApD,aAAA,CAAAmD,QAAQ,EAAC,IAAAnD,aAAA,CAAAe,MAAM,GAAE;CACzB,CAAC;AAsBWL,OAAA,CAAA2C,mBAAmB,GAAG,IAAArD,aAAA,CAAAmD,QAAQ,EACzC,IAAAnD,aAAA,CAAAY,KAAK,EAAC,CAAC,IAAAZ,aAAA,CAAAkB,MAAM,EAAC,IAAAlB,aAAA,CAAAe,MAAM,GAAE,EAAEL,OAAA,CAAAS,UAAU,CAAC,EAAE,IAAAnB,aAAA,CAAAgB,KAAK,EAACN,OAAA,CAAAS,UAAU,CAAC,CAAC,CAAC,CACzD;AAGYT,OAAA,CAAA4C,oBAAoB,GAAG,IAAAtD,aAAA,CAAA8C,MAAM,EAAC;EACzCS,EAAE,EAAE7C,OAAA,CAAAiC,eAAe;EACnBa,OAAO,EAAE9C,OAAA,CAAAgC,oBAAoB;EAC7Be,MAAM,EAAE,IAAAzD,aAAA,CAAAe,MAAM,GAAE;EAChB2C,MAAM,EAAEhD,OAAA,CAAA2C;CACT,CAAC;AAoBW3C,OAAA,CAAAiD,yBAAyB,GAAG,IAAA3D,aAAA,CAAA4D,IAAI,EAAClD,OAAA,CAAA4C,oBAAoB,EAAE,CAAC,IAAI,CAAC,CAAC;AAQ3E;;;;;;;AAOA,SAAgBO,qBAAqBA,CACnCxD,KAAc;EAEd,OAAO,IAAAL,aAAA,CAAAM,EAAE,EAACD,KAAK,EAAEK,OAAA,CAAAiD,yBAAyB,CAAC;AAC7C;AAJAjD,OAAA,CAAAmD,qBAAA,GAAAA,qBAAA;AAMA;;;;;;;;AAQA,SAAgBC,2BAA2BA,CACzCzD,KAAc;AACd;AACA0D,YAAwC;EAExC,IAAA7D,QAAA,CAAAkC,YAAY,EACV/B,KAAK,EACLK,OAAA,CAAAiD,yBAAyB,EACzB,+BAA+B,EAC/BI,YAAY,CACb;AACH;AAXArD,OAAA,CAAAoD,2BAAA,GAAAA,2BAAA;AAaA;;;;;;AAMA,SAAgBE,gBAAgBA,CAAC3D,KAAc;EAC7C,OAAO,IAAAL,aAAA,CAAAM,EAAE,EAACD,KAAK,EAAEK,OAAA,CAAA4C,oBAAoB,CAAC;AACxC;AAFA5C,OAAA,CAAAsD,gBAAA,GAAAA,gBAAA;AAIA;;;;;;;;AAQA,SAAgBC,sBAAsBA,CACpC5D,KAAc;AACd;AACA0D,YAAwC;EAExC,IAAA7D,QAAA,CAAAkC,YAAY,EACV/B,KAAK,EACLK,OAAA,CAAA4C,oBAAoB,EACpB,0BAA0B,EAC1BS,YAAY,CACb;AACH;AAXArD,OAAA,CAAAuD,sBAAA,GAAAA,sBAAA;AAaavD,OAAA,CAAAwD,4BAA4B,GAAG,IAAAlE,aAAA,CAAA8C,MAAM,EAAC;EACjDS,EAAE,EAAE7C,OAAA,CAAAiC,eAAe;EACnBa,OAAO,EAAE9C,OAAA,CAAAgC,oBAAoB;EAC7ByB,MAAM,EAAE,IAAAnE,aAAA,CAAAmD,QAAQ,EAAC,IAAAnD,aAAA,CAAAoE,OAAO,GAAE,CAAC;EAC3BpC,KAAK,EAAE,IAAAhC,aAAA,CAAAmD,QAAQ,EAACzC,OAAA,CAAAmC,kBAAkB;CACnC,CAAC;AAYWnC,OAAA,CAAA2D,oBAAoB,GAAG,IAAArE,aAAA,CAAA8C,MAAM,EAAC;EACzCS,EAAE,EAAE7C,OAAA,CAAAiC,eAAe;EACnBa,OAAO,EAAE9C,OAAA,CAAAgC,oBAAoB;EAC7ByB,MAAM,EAAEzD,OAAA,CAAAS;CACT,CAAC;AAYWT,OAAA,CAAA4D,oBAAoB,GAAG,IAAAtE,aAAA,CAAA8C,MAAM,EAAC;EACzCS,EAAE,EAAE7C,OAAA,CAAAiC,eAAe;EACnBa,OAAO,EAAE9C,OAAA,CAAAgC,oBAAoB;EAC7BV,KAAK,EAAEtB,OAAA,CAAAmC;CACR,CAAC;AAOWnC,OAAA,CAAA6D,qBAAqB,GAAG,IAAAvE,aAAA,CAAAY,KAAK,EAAC,CACzCF,OAAA,CAAA2D,oBAAoB,EACpB3D,OAAA,CAAA4D,oBAAoB,CACrB,CAAC;AAYF;;;;;;;AAOA,SAAgBE,wBAAwBA,CACtCC,QAAiB;EAEjB,OAAO,IAAAzE,aAAA,CAAAM,EAAE,EAACmE,QAAQ,EAAE/D,OAAA,CAAAwD,4BAA4B,CAAC;AACnD;AAJAxD,OAAA,CAAA8D,wBAAA,GAAAA,wBAAA;AAMA;;;;;;;;;AASA,SAAgBE,8BAA8BA,CAC5CD,QAAiB;AACjB;AACAV,YAAwC;EAExC,IAAA7D,QAAA,CAAAkC,YAAY,EACVqC,QAAQ,EACR/D,OAAA,CAAAwD,4BAA4B,EAC5B,mCAAmC,EACnCH,YAAY,CACb;AACH;AAXArD,OAAA,CAAAgE,8BAAA,GAAAA,8BAAA;AAaA;;;;;;AAMA,SAAgBC,iBAAiBA,CAC/BF,QAAiB;EAEjB,OAAO,IAAAzE,aAAA,CAAAM,EAAE,EAACmE,QAAQ,EAAE/D,OAAA,CAAA6D,qBAAqB,CAAC;AAC5C;AAJA7D,OAAA,CAAAiE,iBAAA,GAAAA,iBAAA;AAMA;;;;;;;;AAQA,SAAgBC,uBAAuBA,CACrCvE,KAAc;AACd;AACA0D,YAAwC;EAExC,IAAA7D,QAAA,CAAAkC,YAAY,EACV/B,KAAK,EACLK,OAAA,CAAA6D,qBAAqB,EACrB,2BAA2B,EAC3BR,YAAY,CACb;AACH;AAXArD,OAAA,CAAAkE,uBAAA,GAAAA,uBAAA;AAaA;;;;;;AAMA,SAAgBC,gBAAgBA,CAC9BxE,KAAc;EAEd,OAAO,IAAAL,aAAA,CAAAM,EAAE,EAACD,KAAK,EAAEK,OAAA,CAAA2D,oBAAoB,CAAC;AACxC;AAJA3D,OAAA,CAAAmE,gBAAA,GAAAA,gBAAA;AAMA;;;;;;;;AAQA,SAAgBC,sBAAsBA,CACpCzE,KAAc;AACd;AACA0D,YAAwC;EAExC,IAAA7D,QAAA,CAAAkC,YAAY,EACV/B,KAAK,EACLK,OAAA,CAAA2D,oBAAoB,EACpB,mCAAmC,EACnCN,YAAY,CACb;AACH;AAXArD,OAAA,CAAAoE,sBAAA,GAAAA,sBAAA;AAaA;;;;;;AAMA,SAAgBC,gBAAgBA,CAAC1E,KAAc;EAC7C,OAAO,IAAAL,aAAA,CAAAM,EAAE,EAACD,KAAK,EAAEK,OAAA,CAAA4D,oBAAoB,CAAC;AACxC;AAFA5D,OAAA,CAAAqE,gBAAA,GAAAA,gBAAA;AAIA;;;;;;;;AAQA,SAAgBC,sBAAsBA,CACpC3E,KAAc;AACd;AACA0D,YAAwC;EAExC,IAAA7D,QAAA,CAAAkC,YAAY,EACV/B,KAAK,EACLK,OAAA,CAAA4D,oBAAoB,EACpB,mCAAmC,EACnCP,YAAY,CACb;AACH;AAXArD,OAAA,CAAAsE,sBAAA,GAAAA,sBAAA;AAaA;;;;;;AAMA,SAAgBC,cAAcA,CAAC5E,KAAc;EAC3C,OAAO,IAAAL,aAAA,CAAAM,EAAE,EAACD,KAAK,EAAEK,OAAA,CAAAmC,kBAAkB,CAAC;AACtC;AAFAnC,OAAA,CAAAuE,cAAA,GAAAA,cAAA;AAIA;;;;;;;;AAQA,SAAgBC,oBAAoBA,CAClC7E,KAAc;AACd;AACA0D,YAAwC;EAExC,IAAA7D,QAAA,CAAAkC,YAAY,EACV/B,KAAK,EACLK,OAAA,CAAAmC,kBAAkB,EAClB,wBAAwB,EACxBkB,YAAY,CACb;AACH;AAXArD,OAAA,CAAAwE,oBAAA,GAAAA,oBAAA;AAmBA;;;;;;;;;;;;;;;;;;;;;;;AAuBA,SAAgBC,qBAAqBA,CAACC,OAAiC;EACrE,MAAM;IAAEC,iBAAiB;IAAEC,eAAe;IAAEC;EAAU,CAAE,GAAAC,MAAA,CAAAC,MAAA;IACtDJ,iBAAiB,EAAE,IAAI;IACvBC,eAAe,EAAE,KAAK;IACtBC,UAAU,EAAE;EAAI,GACbH,OAAO,CACX;EAED;;;;;;;EAOA,MAAMM,gBAAgB,GAAInC,EAAW,IAAqB;IACxD,OAAOoC,OAAO,CACX,OAAOpC,EAAE,KAAK,QAAQ,KAAK+B,eAAe,IAAI9E,MAAM,CAACoF,SAAS,CAACrC,EAAE,CAAC,CAAC,IACjE,OAAOA,EAAE,KAAK,QAAQ,KAAK8B,iBAAiB,IAAI9B,EAAE,CAAC5B,MAAM,GAAG,CAAC,CAAE,IAC/D4D,UAAU,IAAIhC,EAAE,KAAK,IAAK,CAC9B;EACH,CAAC;EAED,OAAOmC,gBAAgB;AACzB;AAxBAhF,OAAA,CAAAyE,qBAAA,GAAAA,qBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}