{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toType = exports.TypeOutput = void 0;\nconst bytes_1 = require(\"./bytes\");\nconst internal_1 = require(\"./internal\");\n/**\n * Type output options\n */\nvar TypeOutput;\n(function (TypeOutput) {\n  TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\n  TypeOutput[TypeOutput[\"BigInt\"] = 1] = \"BigInt\";\n  TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\n  TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\nfunction toType(input, outputType) {\n  if (input === null) {\n    return null;\n  }\n  if (input === undefined) {\n    return undefined;\n  }\n  if (typeof input === 'string' && !(0, internal_1.isHexString)(input)) {\n    throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);\n  } else if (typeof input === 'number' && !Number.isSafeInteger(input)) {\n    throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\n  }\n  const output = (0, bytes_1.toBuffer)(input);\n  switch (outputType) {\n    case TypeOutput.Buffer:\n      return output;\n    case TypeOutput.BigInt:\n      return (0, bytes_1.bufferToBigInt)(output);\n    case TypeOutput.Number:\n      {\n        const bigInt = (0, bytes_1.bufferToBigInt)(output);\n        if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {\n          throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');\n        }\n        return Number(bigInt);\n      }\n    case TypeOutput.PrefixedHexString:\n      return (0, bytes_1.bufferToHex)(output);\n    default:\n      throw new Error('unknown outputType');\n  }\n}\nexports.toType = toType;","map":{"version":3,"names":["bytes_1","require","internal_1","TypeOutput","exports","toType","input","outputType","undefined","isHexString","Error","Number","isSafeInteger","output","toBuffer","Buffer","BigInt","bufferToBigInt","bigInt","MAX_SAFE_INTEGER","PrefixedHexString","bufferToHex"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@ethereumjs/util/src/types.ts"],"sourcesContent":["import { bufferToBigInt, bufferToHex, toBuffer } from './bytes'\nimport { isHexString } from './internal'\n\nimport type { Address } from './address'\nimport type { ToBufferInputTypes } from './bytes'\n\n/*\n * A type that represents an input that can be converted to a BigInt.\n */\nexport type BigIntLike = bigint | PrefixedHexString | number | Buffer\n\n/*\n * A type that represents an input that can be converted to a Buffer.\n */\nexport type BufferLike =\n  | Buffer\n  | Uint8Array\n  | number[]\n  | number\n  | bigint\n  | TransformableToBuffer\n  | PrefixedHexString\n\n/*\n * A type that represents a `0x`-prefixed hex string.\n */\nexport type PrefixedHexString = string\n\n/**\n * A type that represents an input that can be converted to an Address.\n */\nexport type AddressLike = Address | Buffer | PrefixedHexString\n\n/*\n * A type that represents an object that has a `toArray()` method.\n */\nexport interface TransformableToArray {\n  toArray(): Uint8Array\n  toBuffer?(): Buffer\n}\n\n/*\n * A type that represents an object that has a `toBuffer()` method.\n */\nexport interface TransformableToBuffer {\n  toBuffer(): Buffer\n  toArray?(): Uint8Array\n}\n\nexport type NestedUint8Array = Array<Uint8Array | NestedUint8Array>\nexport type NestedBufferArray = Array<Buffer | NestedBufferArray>\n\n/**\n * Type output options\n */\nexport enum TypeOutput {\n  Number,\n  BigInt,\n  Buffer,\n  PrefixedHexString,\n}\n\nexport type TypeOutputReturnType = {\n  [TypeOutput.Number]: number\n  [TypeOutput.BigInt]: bigint\n  [TypeOutput.Buffer]: Buffer\n  [TypeOutput.PrefixedHexString]: PrefixedHexString\n}\n\n/**\n * Convert an input to a specified type.\n * Input of null/undefined returns null/undefined regardless of the output type.\n * @param input value to convert\n * @param outputType type to output\n */\nexport function toType<T extends TypeOutput>(input: null, outputType: T): null\nexport function toType<T extends TypeOutput>(input: undefined, outputType: T): undefined\nexport function toType<T extends TypeOutput>(\n  input: ToBufferInputTypes,\n  outputType: T\n): TypeOutputReturnType[T]\nexport function toType<T extends TypeOutput>(\n  input: ToBufferInputTypes,\n  outputType: T\n): TypeOutputReturnType[T] | undefined | null {\n  if (input === null) {\n    return null\n  }\n  if (input === undefined) {\n    return undefined\n  }\n\n  if (typeof input === 'string' && !isHexString(input)) {\n    throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`)\n  } else if (typeof input === 'number' && !Number.isSafeInteger(input)) {\n    throw new Error(\n      'The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)'\n    )\n  }\n\n  const output = toBuffer(input)\n\n  switch (outputType) {\n    case TypeOutput.Buffer:\n      return output as TypeOutputReturnType[T]\n    case TypeOutput.BigInt:\n      return bufferToBigInt(output) as TypeOutputReturnType[T]\n    case TypeOutput.Number: {\n      const bigInt = bufferToBigInt(output)\n      if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {\n        throw new Error(\n          'The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)'\n        )\n      }\n      return Number(bigInt) as TypeOutputReturnType[T]\n    }\n    case TypeOutput.PrefixedHexString:\n      return bufferToHex(output) as TypeOutputReturnType[T]\n    default:\n      throw new Error('unknown outputType')\n  }\n}\n"],"mappings":";;;;;;AAAA,MAAAA,OAAA,GAAAC,OAAA;AACA,MAAAC,UAAA,GAAAD,OAAA;AAmDA;;;AAGA,IAAYE,UAKX;AALD,WAAYA,UAAU;EACpBA,UAAA,CAAAA,UAAA,0BAAM;EACNA,UAAA,CAAAA,UAAA,0BAAM;EACNA,UAAA,CAAAA,UAAA,0BAAM;EACNA,UAAA,CAAAA,UAAA,gDAAiB;AACnB,CAAC,EALWA,UAAU,GAAVC,OAAA,CAAAD,UAAU,KAAVC,OAAA,CAAAD,UAAU;AA0BtB,SAAgBE,MAAMA,CACpBC,KAAyB,EACzBC,UAAa;EAEb,IAAID,KAAK,KAAK,IAAI,EAAE;IAClB,OAAO,IAAI;;EAEb,IAAIA,KAAK,KAAKE,SAAS,EAAE;IACvB,OAAOA,SAAS;;EAGlB,IAAI,OAAOF,KAAK,KAAK,QAAQ,IAAI,CAAC,IAAAJ,UAAA,CAAAO,WAAW,EAACH,KAAK,CAAC,EAAE;IACpD,MAAM,IAAII,KAAK,CAAC,sDAAsDJ,KAAK,EAAE,CAAC;GAC/E,MAAM,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,CAACK,MAAM,CAACC,aAAa,CAACN,KAAK,CAAC,EAAE;IACpE,MAAM,IAAII,KAAK,CACb,6FAA6F,CAC9F;;EAGH,MAAMG,MAAM,GAAG,IAAAb,OAAA,CAAAc,QAAQ,EAACR,KAAK,CAAC;EAE9B,QAAQC,UAAU;IAChB,KAAKJ,UAAU,CAACY,MAAM;MACpB,OAAOF,MAAiC;IAC1C,KAAKV,UAAU,CAACa,MAAM;MACpB,OAAO,IAAAhB,OAAA,CAAAiB,cAAc,EAACJ,MAAM,CAA4B;IAC1D,KAAKV,UAAU,CAACQ,MAAM;MAAE;QACtB,MAAMO,MAAM,GAAG,IAAAlB,OAAA,CAAAiB,cAAc,EAACJ,MAAM,CAAC;QACrC,IAAIK,MAAM,GAAGF,MAAM,CAACL,MAAM,CAACQ,gBAAgB,CAAC,EAAE;UAC5C,MAAM,IAAIT,KAAK,CACb,8FAA8F,CAC/F;;QAEH,OAAOC,MAAM,CAACO,MAAM,CAA4B;;IAElD,KAAKf,UAAU,CAACiB,iBAAiB;MAC/B,OAAO,IAAApB,OAAA,CAAAqB,WAAW,EAACR,MAAM,CAA4B;IACvD;MACE,MAAM,IAAIH,KAAK,CAAC,oBAAoB,CAAC;;AAE3C;AAxCAN,OAAA,CAAAC,MAAA,GAAAA,MAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}