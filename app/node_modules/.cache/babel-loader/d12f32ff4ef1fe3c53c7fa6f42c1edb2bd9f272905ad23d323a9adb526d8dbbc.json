{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _slicedToArray = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StateClient = void 0;\nvar eventemitter3_1 = __importDefault(require(\"eventemitter3\"));\nvar camelcase_1 = __importDefault(require(\"camelcase\"));\nvar web3_js_1 = require(\"@solana/web3.js\");\nvar provider_js_1 = require(\"../../provider.js\");\nvar index_js_1 = require(\"../../coder/index.js\");\nvar common_js_1 = require(\"../common.js\");\nvar pubkey_js_1 = require(\"../../utils/pubkey.js\");\nvar instruction_js_1 = __importDefault(require(\"./instruction.js\"));\nvar rpc_js_1 = __importDefault(require(\"./rpc.js\"));\nvar transaction_js_1 = __importDefault(require(\"./transaction.js\"));\nvar StateFactory = /*#__PURE__*/function () {\n  function StateFactory() {\n    _classCallCheck(this, StateFactory);\n  }\n  _createClass(StateFactory, null, [{\n    key: \"build\",\n    value: function build(idl, coder, programId, provider) {\n      if (idl.state === undefined) {\n        return undefined;\n      }\n      return new StateClient(idl, programId, provider, coder);\n    }\n  }]);\n  return StateFactory;\n}();\nexports.default = StateFactory;\n/**\n * A client for the program state. Similar to the base [[Program]] client,\n * one can use this to send transactions and read accounts for the state\n * abstraction.\n */\nvar StateClient = /*#__PURE__*/function () {\n  function StateClient(idl, programId) {\n    var provider = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, provider_js_1.getProvider)();\n    var coder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new index_js_1.BorshCoder(idl);\n    _classCallCheck(this, StateClient);\n    this.provider = provider;\n    this.coder = coder;\n    this._idl = idl;\n    this._programId = programId;\n    this._address = programStateAddress(programId);\n    this._sub = null;\n    // Build namespaces.\n    var _ref = function () {\n        var _a;\n        var instruction = {};\n        var transaction = {};\n        var rpc = {};\n        (_a = idl.state) === null || _a === void 0 ? void 0 : _a.methods.forEach(function (m) {\n          // Build instruction method.\n          var ixItem = instruction_js_1.default.build(m, function (ixName, ix) {\n            return coder.instruction.encodeState(ixName, ix);\n          }, programId);\n          ixItem[\"accounts\"] = function (accounts) {\n            var keys = stateInstructionKeys(programId, provider, m, accounts);\n            return keys.concat(instruction_js_1.default.accountsArray(accounts, m.accounts, m.name));\n          };\n          // Build transaction method.\n          var txItem = transaction_js_1.default.build(m, ixItem);\n          // Build RPC method.\n          var rpcItem = rpc_js_1.default.build(m, txItem, (0, common_js_1.parseIdlErrors)(idl), provider);\n          // Attach them all to their respective namespaces.\n          var name = (0, camelcase_1.default)(m.name);\n          instruction[name] = ixItem;\n          transaction[name] = txItem;\n          rpc[name] = rpcItem;\n        });\n        return [instruction, transaction, rpc];\n      }(),\n      _ref2 = _slicedToArray(_ref, 3),\n      instruction = _ref2[0],\n      transaction = _ref2[1],\n      rpc = _ref2[2];\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.rpc = rpc;\n  }\n  /**\n   * Returns the program ID owning the state.\n   */\n  _createClass(StateClient, [{\n    key: \"programId\",\n    get: function get() {\n      return this._programId;\n    }\n    /**\n     * Returns the deserialized state account.\n     */\n  }, {\n    key: \"fetch\",\n    value: function () {\n      var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var addr, accountInfo, state, expectedDiscriminator;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              addr = this.address();\n              _context.next = 3;\n              return this.provider.connection.getAccountInfo(addr);\n            case 3:\n              accountInfo = _context.sent;\n              if (!(accountInfo === null)) {\n                _context.next = 6;\n                break;\n              }\n              throw new Error(\"Account does not exist \".concat(addr.toString()));\n            case 6:\n              // Assert the account discriminator is correct.\n              state = this._idl.state;\n              if (state) {\n                _context.next = 9;\n                break;\n              }\n              throw new Error(\"State is not specified in IDL.\");\n            case 9:\n              _context.next = 11;\n              return (0, index_js_1.stateDiscriminator)(state.struct.name);\n            case 11:\n              expectedDiscriminator = _context.sent;\n              if (!expectedDiscriminator.compare(accountInfo.data.slice(0, 8))) {\n                _context.next = 14;\n                break;\n              }\n              throw new Error(\"Invalid account discriminator\");\n            case 14:\n              return _context.abrupt(\"return\", this.coder.state.decode(accountInfo.data));\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function fetch() {\n        return _fetch.apply(this, arguments);\n      }\n      return fetch;\n    }()\n    /**\n     * Returns the state address.\n     */\n  }, {\n    key: \"address\",\n    value: function address() {\n      return this._address;\n    }\n    /**\n     * Returns an `EventEmitter` with a `\"change\"` event that's fired whenever\n     * the state account cahnges.\n     */\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(commitment) {\n      var _this = this;\n      if (this._sub !== null) {\n        return this._sub.ee;\n      }\n      var ee = new eventemitter3_1.default();\n      var listener = this.provider.connection.onAccountChange(this.address(), function (acc) {\n        var account = _this.coder.state.decode(acc.data);\n        ee.emit(\"change\", account);\n      }, commitment);\n      this._sub = {\n        ee: ee,\n        listener: listener\n      };\n      return ee;\n    }\n    /**\n     * Unsubscribes to state changes.\n     */\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      var _this2 = this;\n      if (this._sub !== null) {\n        this.provider.connection.removeAccountChangeListener(this._sub.listener).then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                _this2._sub = null;\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2);\n        }))).catch(console.error);\n      }\n    }\n  }]);\n  return StateClient;\n}();\nexports.StateClient = StateClient;\n// Calculates the deterministic address of the program's \"state\" account.\nfunction programStateAddress(programId) {\n  var _ref4 = (0, pubkey_js_1.findProgramAddressSync)([], programId),\n    _ref5 = _slicedToArray(_ref4, 1),\n    registrySigner = _ref5[0];\n  return (0, pubkey_js_1.createWithSeedSync)(registrySigner, \"unversioned\", programId);\n}\n// Returns the common keys that are prepended to all instructions targeting\n// the \"state\" of a program.\nfunction stateInstructionKeys(programId, provider, m, accounts) {\n  if (m.name === \"new\") {\n    // Ctor `new` method.\n    var _ref6 = (0, pubkey_js_1.findProgramAddressSync)([], programId),\n      _ref7 = _slicedToArray(_ref6, 1),\n      programSigner = _ref7[0];\n    // @ts-expect-error\n    if (provider.wallet === undefined) {\n      throw new Error(\"This function requires the Provider interface implementor to have a 'wallet' field.\");\n    }\n    return [{\n      // @ts-expect-error\n      pubkey: provider.wallet.publicKey,\n      isWritable: false,\n      isSigner: true\n    }, {\n      pubkey: programStateAddress(programId),\n      isWritable: true,\n      isSigner: false\n    }, {\n      pubkey: programSigner,\n      isWritable: false,\n      isSigner: false\n    }, {\n      pubkey: web3_js_1.SystemProgram.programId,\n      isWritable: false,\n      isSigner: false\n    }, {\n      pubkey: programId,\n      isWritable: false,\n      isSigner: false\n    }];\n  } else {\n    (0, common_js_1.validateAccounts)(m.accounts, accounts);\n    return [{\n      pubkey: programStateAddress(programId),\n      isWritable: true,\n      isSigner: false\n    }];\n  }\n}","map":{"version":3,"names":["eventemitter3_1","__importDefault","require","camelcase_1","web3_js_1","provider_js_1","index_js_1","common_js_1","pubkey_js_1","instruction_js_1","rpc_js_1","transaction_js_1","StateFactory","_classCallCheck","_createClass","key","value","build","idl","coder","programId","provider","state","undefined","StateClient","exports","default","arguments","length","getProvider","BorshCoder","_idl","_programId","_address","programStateAddress","_sub","_ref","instruction","transaction","rpc","_a","methods","forEach","m","ixItem","ixName","ix","encodeState","accounts","keys","stateInstructionKeys","concat","accountsArray","name","txItem","rpcItem","parseIdlErrors","_ref2","_slicedToArray","get","_fetch","_asyncToGenerator","_regeneratorRuntime","mark","_callee","addr","accountInfo","expectedDiscriminator","wrap","_callee$","_context","prev","next","address","connection","getAccountInfo","sent","Error","toString","stateDiscriminator","struct","compare","data","slice","abrupt","decode","stop","fetch","apply","subscribe","commitment","_this","ee","listener","onAccountChange","acc","account","emit","unsubscribe","_this2","removeAccountChangeListener","then","_callee2","_callee2$","_context2","catch","console","error","_ref4","findProgramAddressSync","_ref5","registrySigner","createWithSeedSync","_ref6","_ref7","programSigner","wallet","pubkey","publicKey","isWritable","isSigner","SystemProgram","validateAccounts"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/program/namespace/state.ts"],"sourcesContent":["import EventEmitter from \"eventemitter3\";\nimport camelCase from \"camelcase\";\nimport {\n  PublicKey,\n  SystemProgram,\n  Commitment,\n  AccountMeta,\n} from \"@solana/web3.js\";\nimport Provider, { getProvider } from \"../../provider.js\";\nimport { Idl, IdlInstruction, IdlStateMethod, IdlTypeDef } from \"../../idl.js\";\nimport { BorshCoder, Coder, stateDiscriminator } from \"../../coder/index.js\";\nimport {\n  RpcNamespace,\n  InstructionNamespace,\n  TransactionNamespace,\n} from \"./index.js\";\nimport { Subscription, validateAccounts, parseIdlErrors } from \"../common.js\";\nimport {\n  findProgramAddressSync,\n  createWithSeedSync,\n} from \"../../utils/pubkey.js\";\nimport { Accounts } from \"../context.js\";\nimport InstructionNamespaceFactory from \"./instruction.js\";\nimport RpcNamespaceFactory from \"./rpc.js\";\nimport TransactionNamespaceFactory from \"./transaction.js\";\nimport { IdlTypes, TypeDef } from \"./types.js\";\n\nexport default class StateFactory {\n  public static build<IDL extends Idl>(\n    idl: IDL,\n    coder: Coder,\n    programId: PublicKey,\n    provider?: Provider\n  ): StateClient<IDL> | undefined {\n    if (idl.state === undefined) {\n      return undefined;\n    }\n    return new StateClient(idl, programId, provider, coder);\n  }\n}\n\ntype NullableMethods<IDL extends Idl> = IDL[\"state\"] extends undefined\n  ? IdlInstruction[]\n  : NonNullable<IDL[\"state\"]>[\"methods\"];\n\n/**\n * A client for the program state. Similar to the base [[Program]] client,\n * one can use this to send transactions and read accounts for the state\n * abstraction.\n */\nexport class StateClient<IDL extends Idl> {\n  /**\n   * [[RpcNamespace]] for all state methods.\n   */\n  readonly rpc: RpcNamespace<IDL, NullableMethods<IDL>[number]>;\n\n  /**\n   * [[InstructionNamespace]] for all state methods.\n   */\n  readonly instruction: InstructionNamespace<IDL, NullableMethods<IDL>[number]>;\n\n  /**\n   * [[TransactionNamespace]] for all state methods.\n   */\n  readonly transaction: TransactionNamespace<IDL, NullableMethods<IDL>[number]>;\n\n  /**\n   * Returns the program ID owning the state.\n   */\n  get programId(): PublicKey {\n    return this._programId;\n  }\n  private _programId: PublicKey;\n\n  private _address: PublicKey;\n  private _coder: Coder;\n  private _idl: IDL;\n  private _sub: Subscription | null;\n\n  constructor(\n    idl: IDL,\n    programId: PublicKey,\n    /**\n     * Returns the client's wallet and network provider.\n     */\n    public readonly provider: Provider = getProvider(),\n    /**\n     * Returns the coder.\n     */\n    public readonly coder: Coder = new BorshCoder(idl)\n  ) {\n    this._idl = idl;\n    this._programId = programId;\n    this._address = programStateAddress(programId);\n    this._sub = null;\n\n    // Build namespaces.\n    const [instruction, transaction, rpc] = ((): [\n      InstructionNamespace<IDL, NullableMethods<IDL>[number]>,\n      TransactionNamespace<IDL, NullableMethods<IDL>[number]>,\n      RpcNamespace<IDL, NullableMethods<IDL>[number]>\n    ] => {\n      let instruction: InstructionNamespace = {};\n      let transaction: TransactionNamespace = {};\n      let rpc: RpcNamespace = {};\n\n      idl.state?.methods.forEach(\n        <I extends NullableMethods<IDL>[number]>(m: I) => {\n          // Build instruction method.\n          const ixItem = InstructionNamespaceFactory.build<IDL, I>(\n            m,\n            (ixName, ix) => coder.instruction.encodeState(ixName, ix),\n            programId\n          );\n          ixItem[\"accounts\"] = (accounts) => {\n            const keys = stateInstructionKeys(programId, provider, m, accounts);\n            return keys.concat(\n              InstructionNamespaceFactory.accountsArray(\n                accounts,\n                m.accounts,\n                m.name\n              )\n            );\n          };\n          // Build transaction method.\n          const txItem = TransactionNamespaceFactory.build(m, ixItem);\n          // Build RPC method.\n          const rpcItem = RpcNamespaceFactory.build(\n            m,\n            txItem,\n            parseIdlErrors(idl),\n            provider\n          );\n\n          // Attach them all to their respective namespaces.\n          const name = camelCase(m.name);\n          instruction[name] = ixItem;\n          transaction[name] = txItem;\n          rpc[name] = rpcItem;\n        }\n      );\n\n      return [\n        instruction as InstructionNamespace<IDL, NullableMethods<IDL>[number]>,\n        transaction as TransactionNamespace<IDL, NullableMethods<IDL>[number]>,\n        rpc as RpcNamespace<IDL, NullableMethods<IDL>[number]>,\n      ];\n    })();\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.rpc = rpc;\n  }\n\n  /**\n   * Returns the deserialized state account.\n   */\n  async fetch(): Promise<\n    TypeDef<\n      IDL[\"state\"] extends undefined\n        ? IdlTypeDef\n        : NonNullable<IDL[\"state\"]>[\"struct\"],\n      IdlTypes<IDL>\n    >\n  > {\n    const addr = this.address();\n    const accountInfo = await this.provider.connection.getAccountInfo(addr);\n    if (accountInfo === null) {\n      throw new Error(`Account does not exist ${addr.toString()}`);\n    }\n    // Assert the account discriminator is correct.\n    const state = this._idl.state;\n    if (!state) {\n      throw new Error(\"State is not specified in IDL.\");\n    }\n    const expectedDiscriminator = await stateDiscriminator(state.struct.name);\n    if (expectedDiscriminator.compare(accountInfo.data.slice(0, 8))) {\n      throw new Error(\"Invalid account discriminator\");\n    }\n    return this.coder.state.decode(accountInfo.data);\n  }\n\n  /**\n   * Returns the state address.\n   */\n  address(): PublicKey {\n    return this._address;\n  }\n\n  /**\n   * Returns an `EventEmitter` with a `\"change\"` event that's fired whenever\n   * the state account cahnges.\n   */\n  subscribe(commitment?: Commitment): EventEmitter {\n    if (this._sub !== null) {\n      return this._sub.ee;\n    }\n    const ee = new EventEmitter();\n\n    const listener = this.provider.connection.onAccountChange(\n      this.address(),\n      (acc) => {\n        const account = this.coder.state.decode(acc.data);\n        ee.emit(\"change\", account);\n      },\n      commitment\n    );\n\n    this._sub = {\n      ee,\n      listener,\n    };\n\n    return ee;\n  }\n\n  /**\n   * Unsubscribes to state changes.\n   */\n  unsubscribe() {\n    if (this._sub !== null) {\n      this.provider.connection\n        .removeAccountChangeListener(this._sub.listener)\n        .then(async () => {\n          this._sub = null;\n        })\n        .catch(console.error);\n    }\n  }\n}\n\n// Calculates the deterministic address of the program's \"state\" account.\nfunction programStateAddress(programId: PublicKey): PublicKey {\n  let [registrySigner] = findProgramAddressSync([], programId);\n  return createWithSeedSync(registrySigner, \"unversioned\", programId);\n}\n\n// Returns the common keys that are prepended to all instructions targeting\n// the \"state\" of a program.\nfunction stateInstructionKeys<M extends IdlStateMethod>(\n  programId: PublicKey,\n  provider: Provider,\n  m: M,\n  accounts: Accounts<M[\"accounts\"][number]>\n): AccountMeta[] {\n  if (m.name === \"new\") {\n    // Ctor `new` method.\n    const [programSigner] = findProgramAddressSync([], programId);\n    // @ts-expect-error\n    if (provider.wallet === undefined) {\n      throw new Error(\n        \"This function requires the Provider interface implementor to have a 'wallet' field.\"\n      );\n    }\n    return [\n      {\n        // @ts-expect-error\n        pubkey: provider.wallet.publicKey,\n        isWritable: false,\n        isSigner: true,\n      },\n      {\n        pubkey: programStateAddress(programId),\n        isWritable: true,\n        isSigner: false,\n      },\n      { pubkey: programSigner, isWritable: false, isSigner: false },\n      {\n        pubkey: SystemProgram.programId,\n        isWritable: false,\n        isSigner: false,\n      },\n\n      { pubkey: programId, isWritable: false, isSigner: false },\n    ];\n  } else {\n    validateAccounts(m.accounts, accounts);\n    return [\n      {\n        pubkey: programStateAddress(programId),\n        isWritable: true,\n        isSigner: false,\n      },\n    ];\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}