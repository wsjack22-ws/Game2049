{"ast":null,"code":"import { IdlCoder } from \"./idl\";\nimport { sha256 } from \"js-sha256\";\nimport camelcase from \"camelcase\";\n/**\n * Number of bytes of the account discriminator.\n */\nexport const ACCOUNT_DISCRIMINATOR_SIZE = 8;\n/**\n * Encodes and decodes account objects.\n */\nexport class AccountsCoder {\n  constructor(idl) {\n    if (idl.accounts === undefined) {\n      this.accountLayouts = new Map();\n      return;\n    }\n    const layouts = idl.accounts.map(acc => {\n      return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];\n    });\n    this.accountLayouts = new Map(layouts);\n  }\n  async encode(accountName, account) {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n    const layout = this.accountLayouts.get(accountName);\n    if (!layout) {\n      throw new Error(`Unknown account: ${accountName}`);\n    }\n    const len = layout.encode(account, buffer);\n    let accountData = buffer.slice(0, len);\n    let discriminator = AccountsCoder.accountDiscriminator(accountName);\n    return Buffer.concat([discriminator, accountData]);\n  }\n  decode(accountName, ix) {\n    // Chop off the discriminator before decoding.\n    const data = ix.slice(ACCOUNT_DISCRIMINATOR_SIZE);\n    const layout = this.accountLayouts.get(accountName);\n    if (!layout) {\n      throw new Error(`Unknown account: ${accountName}`);\n    }\n    return layout.decode(data);\n  }\n  /**\n   * Calculates and returns a unique 8 byte discriminator prepended to all anchor accounts.\n   *\n   * @param name The name of the account to calculate the discriminator.\n   */\n  static accountDiscriminator(name) {\n    return Buffer.from(sha256.digest(`account:${camelcase(name, {\n      pascalCase: true\n    })}`)).slice(0, ACCOUNT_DISCRIMINATOR_SIZE);\n  }\n}","map":{"version":3,"names":["IdlCoder","sha256","camelcase","ACCOUNT_DISCRIMINATOR_SIZE","AccountsCoder","constructor","idl","accounts","undefined","accountLayouts","Map","layouts","map","acc","name","typeDefLayout","types","encode","accountName","account","buffer","Buffer","alloc","layout","get","Error","len","accountData","slice","discriminator","accountDiscriminator","concat","decode","ix","data","from","digest","pascalCase"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/coder/accounts.ts"],"sourcesContent":["import { Layout } from \"buffer-layout\";\nimport { Idl } from \"../idl\";\nimport { IdlCoder } from \"./idl\";\nimport { sha256 } from \"js-sha256\";\nimport camelcase from \"camelcase\";\n\n/**\n * Number of bytes of the account discriminator.\n */\nexport const ACCOUNT_DISCRIMINATOR_SIZE = 8;\n\n/**\n * Encodes and decodes account objects.\n */\nexport class AccountsCoder<A extends string = string> {\n  /**\n   * Maps account type identifier to a layout.\n   */\n  private accountLayouts: Map<A, Layout>;\n\n  public constructor(idl: Idl) {\n    if (idl.accounts === undefined) {\n      this.accountLayouts = new Map();\n      return;\n    }\n    const layouts: [A, Layout][] = idl.accounts.map((acc) => {\n      return [acc.name as A, IdlCoder.typeDefLayout(acc, idl.types)];\n    });\n\n    this.accountLayouts = new Map(layouts);\n  }\n\n  public async encode<T = any>(accountName: A, account: T): Promise<Buffer> {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n    const layout = this.accountLayouts.get(accountName);\n    if (!layout) {\n      throw new Error(`Unknown account: ${accountName}`);\n    }\n    const len = layout.encode(account, buffer);\n    let accountData = buffer.slice(0, len);\n    let discriminator = AccountsCoder.accountDiscriminator(accountName);\n    return Buffer.concat([discriminator, accountData]);\n  }\n\n  public decode<T = any>(accountName: A, ix: Buffer): T {\n    // Chop off the discriminator before decoding.\n    const data = ix.slice(ACCOUNT_DISCRIMINATOR_SIZE);\n    const layout = this.accountLayouts.get(accountName);\n    if (!layout) {\n      throw new Error(`Unknown account: ${accountName}`);\n    }\n    return layout.decode(data);\n  }\n\n  /**\n   * Calculates and returns a unique 8 byte discriminator prepended to all anchor accounts.\n   *\n   * @param name The name of the account to calculate the discriminator.\n   */\n  public static accountDiscriminator(name: string): Buffer {\n    return Buffer.from(\n      sha256.digest(`account:${camelcase(name, { pascalCase: true })}`)\n    ).slice(0, ACCOUNT_DISCRIMINATOR_SIZE);\n  }\n}\n"],"mappings":"AAEA,SAASA,QAAQ,QAAQ,OAAO;AAChC,SAASC,MAAM,QAAQ,WAAW;AAClC,OAAOC,SAAS,MAAM,WAAW;AAEjC;;;AAGA,OAAO,MAAMC,0BAA0B,GAAG,CAAC;AAE3C;;;AAGA,OAAM,MAAOC,aAAa;EAMxBC,YAAmBC,GAAQ;IACzB,IAAIA,GAAG,CAACC,QAAQ,KAAKC,SAAS,EAAE;MAC9B,IAAI,CAACC,cAAc,GAAG,IAAIC,GAAG,EAAE;MAC/B;;IAEF,MAAMC,OAAO,GAAkBL,GAAG,CAACC,QAAQ,CAACK,GAAG,CAAEC,GAAG,IAAI;MACtD,OAAO,CAACA,GAAG,CAACC,IAAS,EAAEd,QAAQ,CAACe,aAAa,CAACF,GAAG,EAAEP,GAAG,CAACU,KAAK,CAAC,CAAC;IAChE,CAAC,CAAC;IAEF,IAAI,CAACP,cAAc,GAAG,IAAIC,GAAG,CAACC,OAAO,CAAC;EACxC;EAEO,MAAMM,MAAMA,CAAUC,WAAc,EAAEC,OAAU;IACrD,MAAMC,MAAM,GAAGC,MAAM,CAACC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;IACnC,MAAMC,MAAM,GAAG,IAAI,CAACd,cAAc,CAACe,GAAG,CAACN,WAAW,CAAC;IACnD,IAAI,CAACK,MAAM,EAAE;MACX,MAAM,IAAIE,KAAK,CAAC,oBAAoBP,WAAW,EAAE,CAAC;;IAEpD,MAAMQ,GAAG,GAAGH,MAAM,CAACN,MAAM,CAACE,OAAO,EAAEC,MAAM,CAAC;IAC1C,IAAIO,WAAW,GAAGP,MAAM,CAACQ,KAAK,CAAC,CAAC,EAAEF,GAAG,CAAC;IACtC,IAAIG,aAAa,GAAGzB,aAAa,CAAC0B,oBAAoB,CAACZ,WAAW,CAAC;IACnE,OAAOG,MAAM,CAACU,MAAM,CAAC,CAACF,aAAa,EAAEF,WAAW,CAAC,CAAC;EACpD;EAEOK,MAAMA,CAAUd,WAAc,EAAEe,EAAU;IAC/C;IACA,MAAMC,IAAI,GAAGD,EAAE,CAACL,KAAK,CAACzB,0BAA0B,CAAC;IACjD,MAAMoB,MAAM,GAAG,IAAI,CAACd,cAAc,CAACe,GAAG,CAACN,WAAW,CAAC;IACnD,IAAI,CAACK,MAAM,EAAE;MACX,MAAM,IAAIE,KAAK,CAAC,oBAAoBP,WAAW,EAAE,CAAC;;IAEpD,OAAOK,MAAM,CAACS,MAAM,CAACE,IAAI,CAAC;EAC5B;EAEA;;;;;EAKO,OAAOJ,oBAAoBA,CAAChB,IAAY;IAC7C,OAAOO,MAAM,CAACc,IAAI,CAChBlC,MAAM,CAACmC,MAAM,CAAC,WAAWlC,SAAS,CAACY,IAAI,EAAE;MAAEuB,UAAU,EAAE;IAAI,CAAE,CAAC,EAAE,CAAC,CAClE,CAACT,KAAK,CAAC,CAAC,EAAEzB,0BAA0B,CAAC;EACxC"},"metadata":{},"sourceType":"module","externalDependencies":[]}