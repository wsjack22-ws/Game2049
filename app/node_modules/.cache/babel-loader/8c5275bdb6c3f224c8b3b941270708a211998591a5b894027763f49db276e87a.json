{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EventParser = exports.EventManager = void 0;\nconst assert = __importStar(require(\"assert\"));\nconst PROGRAM_LOG = \"Program log: \";\nconst PROGRAM_DATA = \"Program data: \";\nconst PROGRAM_LOG_START_INDEX = PROGRAM_LOG.length;\nconst PROGRAM_DATA_START_INDEX = PROGRAM_DATA.length;\nclass EventManager {\n  constructor(programId, provider, coder) {\n    this._programId = programId;\n    this._provider = provider;\n    this._eventParser = new EventParser(programId, coder);\n    this._eventCallbacks = new Map();\n    this._eventListeners = new Map();\n    this._listenerIdCount = 0;\n  }\n  addEventListener(eventName, callback) {\n    var _a;\n    let listener = this._listenerIdCount;\n    this._listenerIdCount += 1;\n    // Store the listener into the event map.\n    if (!(eventName in this._eventCallbacks)) {\n      this._eventListeners.set(eventName, []);\n    }\n    this._eventListeners.set(eventName, ((_a = this._eventListeners.get(eventName)) !== null && _a !== void 0 ? _a : []).concat(listener));\n    // Store the callback into the listener map.\n    this._eventCallbacks.set(listener, [eventName, callback]);\n    // Create the subscription singleton, if needed.\n    if (this._onLogsSubscriptionId !== undefined) {\n      return listener;\n    }\n    this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (logs, ctx) => {\n      if (logs.err) {\n        return;\n      }\n      this._eventParser.parseLogs(logs.logs, event => {\n        const allListeners = this._eventListeners.get(event.name);\n        if (allListeners) {\n          allListeners.forEach(listener => {\n            const listenerCb = this._eventCallbacks.get(listener);\n            if (listenerCb) {\n              const [, callback] = listenerCb;\n              callback(event.data, ctx.slot);\n            }\n          });\n        }\n      });\n    });\n    return listener;\n  }\n  async removeEventListener(listener) {\n    // Get the callback.\n    const callback = this._eventCallbacks.get(listener);\n    if (!callback) {\n      throw new Error(`Event listener ${listener} doesn't exist!`);\n    }\n    const [eventName] = callback;\n    // Get the listeners.\n    let listeners = this._eventListeners.get(eventName);\n    if (!listeners) {\n      throw new Error(`Event listeners don't exist for ${eventName}!`);\n    }\n    // Update both maps.\n    this._eventCallbacks.delete(listener);\n    listeners = listeners.filter(l => l !== listener);\n    if (listeners.length === 0) {\n      this._eventListeners.delete(eventName);\n    }\n    // Kill the websocket connection if all listeners have been removed.\n    if (this._eventCallbacks.size == 0) {\n      assert.ok(this._eventListeners.size === 0);\n      if (this._onLogsSubscriptionId !== undefined) {\n        await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);\n        this._onLogsSubscriptionId = undefined;\n      }\n    }\n  }\n}\nexports.EventManager = EventManager;\nclass EventParser {\n  constructor(programId, coder) {\n    this.coder = coder;\n    this.programId = programId;\n  }\n  // Each log given, represents an array of messages emitted by\n  // a single transaction, which can execute many different programs across\n  // CPI boundaries. However, the subscription is only interested in the\n  // events emitted by *this* program. In achieving this, we keep track of the\n  // program execution context by parsing each log and looking for a CPI\n  // `invoke` call. If one exists, we know a new program is executing. So we\n  // push the programId onto a stack and switch the program context. This\n  // allows us to track, for a given log, which program was executing during\n  // its emission, thereby allowing us to know if a given log event was\n  // emitted by *this* program. If it was, then we parse the raw string and\n  // emit the event if the string matches the event being subscribed to.\n  parseLogs(logs, callback) {\n    const logScanner = new LogScanner(logs);\n    const execution = new ExecutionContext();\n    let log = logScanner.next();\n    while (log !== null) {\n      let [event, newProgram, didPop] = this.handleLog(execution, log);\n      if (event) {\n        callback(event);\n      }\n      if (newProgram) {\n        execution.push(newProgram);\n      }\n      if (didPop) {\n        execution.pop();\n      }\n      log = logScanner.next();\n    }\n  }\n  // Main log handler. Returns a three element array of the event, the\n  // next program that was invoked for CPI, and a boolean indicating if\n  // a program has completed execution (and thus should be popped off the\n  // execution stack).\n  handleLog(execution, log) {\n    // Executing program is this program.\n    if (execution.stack.length > 0 && execution.program() === this.programId.toString()) {\n      return this.handleProgramLog(log);\n    }\n    // Executing program is not this program.\n    else {\n      return [null, ...this.handleSystemLog(log)];\n    }\n  }\n  // Handles logs from *this* program.\n  handleProgramLog(log) {\n    // This is a `msg!` log or a `sol_log_data` log.\n    if (log.startsWith(PROGRAM_LOG) || log.startsWith(PROGRAM_DATA)) {\n      const logStr = log.startsWith(PROGRAM_LOG) ? log.slice(PROGRAM_LOG_START_INDEX) : log.slice(PROGRAM_DATA_START_INDEX);\n      const event = this.coder.events.decode(logStr);\n      return [event, null, false];\n    }\n    // System log.\n    else {\n      return [null, ...this.handleSystemLog(log)];\n    }\n  }\n  // Handles logs when the current program being executing is *not* this.\n  handleSystemLog(log) {\n    // System component.\n    const logStart = log.split(\":\")[0];\n    // Did the program finish executing?\n    if (logStart.match(/^Program (.*) success/g) !== null) {\n      return [null, true];\n      // Recursive call.\n    } else if (logStart.startsWith(`Program ${this.programId.toString()} invoke`)) {\n      return [this.programId.toString(), false];\n    }\n    // CPI call.\n    else if (logStart.includes(\"invoke\")) {\n      return [\"cpi\", false]; // Any string will do.\n    } else {\n      return [null, false];\n    }\n  }\n}\nexports.EventParser = EventParser;\n// Stack frame execution context, allowing one to track what program is\n// executing for a given log.\nclass ExecutionContext {\n  constructor() {\n    this.stack = [];\n  }\n  program() {\n    assert.ok(this.stack.length > 0);\n    return this.stack[this.stack.length - 1];\n  }\n  push(newProgram) {\n    this.stack.push(newProgram);\n  }\n  pop() {\n    assert.ok(this.stack.length > 0);\n    this.stack.pop();\n  }\n}\nclass LogScanner {\n  constructor(logs) {\n    this.logs = logs;\n  }\n  next() {\n    if (this.logs.length === 0) {\n      return null;\n    }\n    let l = this.logs[0];\n    this.logs = this.logs.slice(1);\n    return l;\n  }\n}","map":{"version":3,"names":["assert","__importStar","require","PROGRAM_LOG","PROGRAM_DATA","PROGRAM_LOG_START_INDEX","length","PROGRAM_DATA_START_INDEX","EventManager","constructor","programId","provider","coder","_programId","_provider","_eventParser","EventParser","_eventCallbacks","Map","_eventListeners","_listenerIdCount","addEventListener","eventName","callback","listener","set","_a","get","concat","_onLogsSubscriptionId","undefined","connection","onLogs","logs","ctx","err","parseLogs","event","allListeners","name","forEach","listenerCb","data","slot","removeEventListener","Error","listeners","delete","filter","l","size","ok","removeOnLogsListener","exports","logScanner","LogScanner","execution","ExecutionContext","log","next","newProgram","didPop","handleLog","push","pop","stack","program","toString","handleProgramLog","handleSystemLog","startsWith","logStr","slice","events","decode","logStart","split","match","includes"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/program/event.ts"],"sourcesContent":["import { PublicKey } from \"@solana/web3.js\";\nimport * as assert from \"assert\";\nimport { IdlEvent, IdlEventField } from \"../idl.js\";\nimport { Coder } from \"../coder/index.js\";\nimport { DecodeType } from \"./namespace/types.js\";\nimport Provider from \"../provider.js\";\n\nconst PROGRAM_LOG = \"Program log: \";\nconst PROGRAM_DATA = \"Program data: \";\nconst PROGRAM_LOG_START_INDEX = PROGRAM_LOG.length;\nconst PROGRAM_DATA_START_INDEX = PROGRAM_DATA.length;\n\n// Deserialized event.\nexport type Event<\n  E extends IdlEvent = IdlEvent,\n  Defined = Record<string, never>\n> = {\n  name: E[\"name\"];\n  data: EventData<E[\"fields\"][number], Defined>;\n};\n\nexport type EventData<T extends IdlEventField, Defined> = {\n  [N in T[\"name\"]]: DecodeType<(T & { name: N })[\"type\"], Defined>;\n};\n\ntype EventCallback = (event: any, slot: number) => void;\n\nexport class EventManager {\n  /**\n   * Program ID for event subscriptions.\n   */\n  private _programId: PublicKey;\n\n  /**\n   * Network and wallet provider.\n   */\n  private _provider: Provider;\n\n  /**\n   * Event parser to handle onLogs callbacks.\n   */\n  private _eventParser: EventParser;\n\n  /**\n   * Maps event listener id to [event-name, callback].\n   */\n  private _eventCallbacks: Map<number, [string, EventCallback]>;\n\n  /**\n   * Maps event name to all listeners for the event.\n   */\n  private _eventListeners: Map<string, Array<number>>;\n\n  /**\n   * The next listener id to allocate.\n   */\n  private _listenerIdCount: number;\n\n  /**\n   * The subscription id from the connection onLogs subscription.\n   */\n  private _onLogsSubscriptionId: number | undefined;\n\n  constructor(programId: PublicKey, provider: Provider, coder: Coder) {\n    this._programId = programId;\n    this._provider = provider;\n    this._eventParser = new EventParser(programId, coder);\n    this._eventCallbacks = new Map();\n    this._eventListeners = new Map();\n    this._listenerIdCount = 0;\n  }\n\n  public addEventListener(\n    eventName: string,\n    callback: (event: any, slot: number) => void\n  ): number {\n    let listener = this._listenerIdCount;\n    this._listenerIdCount += 1;\n\n    // Store the listener into the event map.\n    if (!(eventName in this._eventCallbacks)) {\n      this._eventListeners.set(eventName, []);\n    }\n    this._eventListeners.set(\n      eventName,\n      (this._eventListeners.get(eventName) ?? []).concat(listener)\n    );\n\n    // Store the callback into the listener map.\n    this._eventCallbacks.set(listener, [eventName, callback]);\n\n    // Create the subscription singleton, if needed.\n    if (this._onLogsSubscriptionId !== undefined) {\n      return listener;\n    }\n\n    this._onLogsSubscriptionId = this._provider!.connection.onLogs(\n      this._programId,\n      (logs, ctx) => {\n        if (logs.err) {\n          return;\n        }\n        this._eventParser.parseLogs(logs.logs, (event) => {\n          const allListeners = this._eventListeners.get(event.name);\n          if (allListeners) {\n            allListeners.forEach((listener) => {\n              const listenerCb = this._eventCallbacks.get(listener);\n              if (listenerCb) {\n                const [, callback] = listenerCb;\n                callback(event.data, ctx.slot);\n              }\n            });\n          }\n        });\n      }\n    );\n\n    return listener;\n  }\n\n  public async removeEventListener(listener: number): Promise<void> {\n    // Get the callback.\n    const callback = this._eventCallbacks.get(listener);\n    if (!callback) {\n      throw new Error(`Event listener ${listener} doesn't exist!`);\n    }\n    const [eventName] = callback;\n\n    // Get the listeners.\n    let listeners = this._eventListeners.get(eventName);\n    if (!listeners) {\n      throw new Error(`Event listeners don't exist for ${eventName}!`);\n    }\n\n    // Update both maps.\n    this._eventCallbacks.delete(listener);\n    listeners = listeners.filter((l) => l !== listener);\n    if (listeners.length === 0) {\n      this._eventListeners.delete(eventName);\n    }\n\n    // Kill the websocket connection if all listeners have been removed.\n    if (this._eventCallbacks.size == 0) {\n      assert.ok(this._eventListeners.size === 0);\n      if (this._onLogsSubscriptionId !== undefined) {\n        await this._provider!.connection.removeOnLogsListener(\n          this._onLogsSubscriptionId\n        );\n        this._onLogsSubscriptionId = undefined;\n      }\n    }\n  }\n}\n\nexport class EventParser {\n  private coder: Coder;\n  private programId: PublicKey;\n\n  constructor(programId: PublicKey, coder: Coder) {\n    this.coder = coder;\n    this.programId = programId;\n  }\n\n  // Each log given, represents an array of messages emitted by\n  // a single transaction, which can execute many different programs across\n  // CPI boundaries. However, the subscription is only interested in the\n  // events emitted by *this* program. In achieving this, we keep track of the\n  // program execution context by parsing each log and looking for a CPI\n  // `invoke` call. If one exists, we know a new program is executing. So we\n  // push the programId onto a stack and switch the program context. This\n  // allows us to track, for a given log, which program was executing during\n  // its emission, thereby allowing us to know if a given log event was\n  // emitted by *this* program. If it was, then we parse the raw string and\n  // emit the event if the string matches the event being subscribed to.\n  public parseLogs(logs: string[], callback: (log: Event) => void) {\n    const logScanner = new LogScanner(logs);\n    const execution = new ExecutionContext();\n    let log = logScanner.next();\n    while (log !== null) {\n      let [event, newProgram, didPop] = this.handleLog(execution, log);\n      if (event) {\n        callback(event);\n      }\n      if (newProgram) {\n        execution.push(newProgram);\n      }\n      if (didPop) {\n        execution.pop();\n      }\n      log = logScanner.next();\n    }\n  }\n\n  // Main log handler. Returns a three element array of the event, the\n  // next program that was invoked for CPI, and a boolean indicating if\n  // a program has completed execution (and thus should be popped off the\n  // execution stack).\n  private handleLog(\n    execution: ExecutionContext,\n    log: string\n  ): [Event | null, string | null, boolean] {\n    // Executing program is this program.\n    if (\n      execution.stack.length > 0 &&\n      execution.program() === this.programId.toString()\n    ) {\n      return this.handleProgramLog(log);\n    }\n    // Executing program is not this program.\n    else {\n      return [null, ...this.handleSystemLog(log)];\n    }\n  }\n\n  // Handles logs from *this* program.\n  private handleProgramLog(\n    log: string\n  ): [Event | null, string | null, boolean] {\n    // This is a `msg!` log or a `sol_log_data` log.\n    if (log.startsWith(PROGRAM_LOG) || log.startsWith(PROGRAM_DATA)) {\n      const logStr = log.startsWith(PROGRAM_LOG)\n        ? log.slice(PROGRAM_LOG_START_INDEX)\n        : log.slice(PROGRAM_DATA_START_INDEX);\n      const event = this.coder.events.decode(logStr);\n      return [event, null, false];\n    }\n    // System log.\n    else {\n      return [null, ...this.handleSystemLog(log)];\n    }\n  }\n\n  // Handles logs when the current program being executing is *not* this.\n  private handleSystemLog(log: string): [string | null, boolean] {\n    // System component.\n    const logStart = log.split(\":\")[0];\n\n    // Did the program finish executing?\n    if (logStart.match(/^Program (.*) success/g) !== null) {\n      return [null, true];\n      // Recursive call.\n    } else if (\n      logStart.startsWith(`Program ${this.programId.toString()} invoke`)\n    ) {\n      return [this.programId.toString(), false];\n    }\n    // CPI call.\n    else if (logStart.includes(\"invoke\")) {\n      return [\"cpi\", false]; // Any string will do.\n    } else {\n      return [null, false];\n    }\n  }\n}\n\n// Stack frame execution context, allowing one to track what program is\n// executing for a given log.\nclass ExecutionContext {\n  stack: string[] = [];\n\n  program(): string {\n    assert.ok(this.stack.length > 0);\n    return this.stack[this.stack.length - 1];\n  }\n\n  push(newProgram: string) {\n    this.stack.push(newProgram);\n  }\n\n  pop() {\n    assert.ok(this.stack.length > 0);\n    this.stack.pop();\n  }\n}\n\nclass LogScanner {\n  constructor(public logs: string[]) {}\n\n  next(): string | null {\n    if (this.logs.length === 0) {\n      return null;\n    }\n    let l = this.logs[0];\n    this.logs = this.logs.slice(1);\n    return l;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}