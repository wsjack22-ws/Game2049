{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _FrozenMap_map, _FrozenSet_set;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FrozenSet = exports.FrozenMap = void 0;\n/**\n * A {@link ReadonlyMap} that cannot be modified after instantiation.\n * The implementation uses an inner map hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this map.\n */\nclass FrozenMap {\n  constructor(entries) {\n    _FrozenMap_map.set(this, void 0);\n    __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), \"f\");\n    Object.freeze(this);\n  }\n  get size() {\n    return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").size;\n  }\n  [(_FrozenMap_map = new WeakMap(), Symbol.iterator)]() {\n    return __classPrivateFieldGet(this, _FrozenMap_map, \"f\")[Symbol.iterator]();\n  }\n  entries() {\n    return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").entries();\n  }\n  forEach(callbackfn, thisArg) {\n    // We have to wrap the specified callback in order to prevent it from\n    // receiving a reference to the inner map.\n    return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").forEach((value, key, _map) => callbackfn.call(thisArg, value, key, this));\n  }\n  get(key) {\n    return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").get(key);\n  }\n  has(key) {\n    return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").has(key);\n  }\n  keys() {\n    return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").keys();\n  }\n  values() {\n    return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").values();\n  }\n  toString() {\n    return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[...this.entries()].map(([key, value]) => `${String(key)} => ${String(value)}`).join(', ')} ` : ''}}`;\n  }\n}\nexports.FrozenMap = FrozenMap;\n/**\n * A {@link ReadonlySet} that cannot be modified after instantiation.\n * The implementation uses an inner set hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this set.\n */\nclass FrozenSet {\n  constructor(values) {\n    _FrozenSet_set.set(this, void 0);\n    __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), \"f\");\n    Object.freeze(this);\n  }\n  get size() {\n    return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").size;\n  }\n  [(_FrozenSet_set = new WeakMap(), Symbol.iterator)]() {\n    return __classPrivateFieldGet(this, _FrozenSet_set, \"f\")[Symbol.iterator]();\n  }\n  entries() {\n    return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").entries();\n  }\n  forEach(callbackfn, thisArg) {\n    // We have to wrap the specified callback in order to prevent it from\n    // receiving a reference to the inner set.\n    return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));\n  }\n  has(value) {\n    return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").has(value);\n  }\n  keys() {\n    return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").keys();\n  }\n  values() {\n    return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").values();\n  }\n  toString() {\n    return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[...this.values()].map(member => String(member)).join(', ')} ` : ''}}`;\n  }\n}\nexports.FrozenSet = FrozenSet;\nObject.freeze(FrozenMap);\nObject.freeze(FrozenMap.prototype);\nObject.freeze(FrozenSet);\nObject.freeze(FrozenSet.prototype);","map":{"version":3,"names":["FrozenMap","constructor","entries","_FrozenMap_map","set","__classPrivateFieldSet","Map","Object","freeze","size","__classPrivateFieldGet","WeakMap","Symbol","iterator","forEach","callbackfn","thisArg","value","key","_map","call","get","has","keys","values","toString","map","String","join","exports","FrozenSet","_FrozenSet_set","Set","value2","_set","member","prototype"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@metamask/utils/src/collections.ts"],"sourcesContent":["/**\n * A {@link ReadonlyMap} that cannot be modified after instantiation.\n * The implementation uses an inner map hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this map.\n */\nclass FrozenMap<Key, Value> implements ReadonlyMap<Key, Value> {\n  readonly #map: Map<Key, Value>;\n\n  public get size() {\n    return this.#map.size;\n  }\n\n  public [Symbol.iterator]() {\n    return this.#map[Symbol.iterator]();\n  }\n\n  constructor(entries?: readonly (readonly [Key, Value])[] | null) {\n    this.#map = new Map<Key, Value>(entries);\n    Object.freeze(this);\n  }\n\n  public entries() {\n    return this.#map.entries();\n  }\n\n  public forEach(\n    callbackfn: (value: Value, key: Key, map: this) => void,\n    thisArg?: any,\n  ): void {\n    // We have to wrap the specified callback in order to prevent it from\n    // receiving a reference to the inner map.\n    return this.#map.forEach((value: Value, key: Key, _map: unknown) =>\n      callbackfn.call(thisArg, value, key, this),\n    );\n  }\n\n  public get(key: Key) {\n    return this.#map.get(key);\n  }\n\n  public has(key: Key) {\n    return this.#map.has(key);\n  }\n\n  public keys() {\n    return this.#map.keys();\n  }\n\n  public values() {\n    return this.#map.values();\n  }\n\n  public toString(): string {\n    return `FrozenMap(${this.size}) {${\n      this.size > 0\n        ? ` ${[...this.entries()]\n            .map(([key, value]) => `${String(key)} => ${String(value)}`)\n            .join(', ')} `\n        : ''\n    }}`;\n  }\n}\n\n/**\n * A {@link ReadonlySet} that cannot be modified after instantiation.\n * The implementation uses an inner set hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this set.\n */\nclass FrozenSet<Value> implements ReadonlySet<Value> {\n  readonly #set: Set<Value>;\n\n  public get size() {\n    return this.#set.size;\n  }\n\n  public [Symbol.iterator]() {\n    return this.#set[Symbol.iterator]();\n  }\n\n  constructor(values?: readonly Value[] | null) {\n    this.#set = new Set<Value>(values);\n    Object.freeze(this);\n  }\n\n  public entries() {\n    return this.#set.entries();\n  }\n\n  public forEach(\n    callbackfn: (value: Value, value2: Value, set: this) => void,\n    thisArg?: any,\n  ): void {\n    // We have to wrap the specified callback in order to prevent it from\n    // receiving a reference to the inner set.\n    return this.#set.forEach((value: Value, value2: Value, _set: unknown) =>\n      callbackfn.call(thisArg, value, value2, this),\n    );\n  }\n\n  public has(value: Value) {\n    return this.#set.has(value);\n  }\n\n  public keys() {\n    return this.#set.keys();\n  }\n\n  public values() {\n    return this.#set.values();\n  }\n\n  public toString(): string {\n    return `FrozenSet(${this.size}) {${\n      this.size > 0\n        ? ` ${[...this.values()].map((member) => String(member)).join(', ')} `\n        : ''\n    }}`;\n  }\n}\n\nObject.freeze(FrozenMap);\nObject.freeze(FrozenMap.prototype);\n\nObject.freeze(FrozenSet);\nObject.freeze(FrozenSet.prototype);\n\nexport { FrozenMap, FrozenSet };\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}