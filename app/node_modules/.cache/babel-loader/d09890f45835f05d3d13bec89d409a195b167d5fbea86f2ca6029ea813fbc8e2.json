{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */\n\nimport { ObliviousSet } from 'oblivious-set';\nimport { io } from 'socket.io-client';\nimport { getPublic, sign } from '@toruslabs/eccrypto';\nimport { encryptData, decryptData, keccak256 } from '@toruslabs/metadata-helpers';\nimport { log } from '../util';\nimport { fillOptionsWithDefaults } from '../options';\nimport { sleep, randomToken, microSeconds as micro } from '../util';\nexport var microSeconds = micro;\nvar KEY_PREFIX = 'pubkey.broadcastChannel-';\nexport var type = 'server';\nvar SOCKET_CONN_INSTANCE = null;\n// used to decide to reconnect socket e.g. when socket connection is disconnected unexpectedly\nvar runningChannels = new Set();\nexport function storageKey(channelName) {\n  return KEY_PREFIX + channelName;\n}\n\n/**\n * writes the new message to the storage\n * and fires the storage-event so other readers can find it\n */\nexport function postMessage(channelState, messageJson) {\n  return new Promise(function (res, rej) {\n    sleep().then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var key, channelEncPrivKey, encData, body;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            key = storageKey(channelState.channelName);\n            channelEncPrivKey = keccak256(Buffer.from(key, 'utf8'));\n            _context.next = 4;\n            return encryptData(channelEncPrivKey.toString('hex'), {\n              token: randomToken(),\n              time: new Date().getTime(),\n              data: messageJson,\n              uuid: channelState.uuid\n            });\n          case 4:\n            encData = _context.sent;\n            _context.t0 = getPublic(channelEncPrivKey).toString('hex');\n            _context.t1 = encData;\n            _context.next = 9;\n            return sign(channelEncPrivKey, keccak256(Buffer.from(encData, 'utf8')));\n          case 9:\n            _context.t2 = _context.sent.toString('hex');\n            body = {\n              key: _context.t0,\n              data: _context.t1,\n              signature: _context.t2\n            };\n            if (channelState.timeout) body.timeout = channelState.timeout;\n            return _context.abrupt(\"return\", fetch(channelState.serverUrl + '/channel/set', {\n              method: 'POST',\n              body: JSON.stringify(body),\n              headers: {\n                'Content-Type': 'application/json; charset=utf-8'\n              }\n            }).then(res)[\"catch\"](rej));\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    })));\n  });\n}\nexport function getSocketInstance(serverUrl) {\n  if (SOCKET_CONN_INSTANCE) {\n    return SOCKET_CONN_INSTANCE;\n  }\n  var SOCKET_CONN = io(serverUrl, {\n    transports: ['websocket', 'polling'],\n    // use WebSocket first, if available\n    withCredentials: true,\n    reconnectionDelayMax: 10000,\n    reconnectionAttempts: 10\n  });\n  SOCKET_CONN.on('connect_error', function (err) {\n    // revert to classic upgrade\n    SOCKET_CONN.io.opts.transports = ['polling', 'websocket'];\n    log.error('connect error', err);\n  });\n  SOCKET_CONN.on('connect', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    var engine;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          engine = SOCKET_CONN.io.engine;\n          log.debug('initially connected to', engine.transport.name); // in most cases, prints \"polling\"\n          engine.once('upgrade', function () {\n            // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)\n            log.debug('upgraded', engine.transport.name); // in most cases, prints \"websocket\"\n          });\n\n          engine.once('close', function (reason) {\n            // called when the underlying connection is closed\n            log.debug('connection closed', reason);\n          });\n        case 4:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  })));\n  SOCKET_CONN.on('error', function (err) {\n    log.error('socket errored', err);\n    SOCKET_CONN.disconnect();\n  });\n  SOCKET_CONN_INSTANCE = SOCKET_CONN;\n  return SOCKET_CONN;\n}\nexport function setupSocketConnection(serverUrl, channelName, fn) {\n  var socketConn = getSocketInstance(serverUrl);\n  var key = storageKey(channelName);\n  var channelEncPrivKey = keccak256(Buffer.from(key, 'utf8'));\n  var channelPubKey = getPublic(channelEncPrivKey).toString('hex');\n  if (socketConn.connected) {\n    socketConn.emit('check_auth_status', channelPubKey);\n  } else {\n    socketConn.once('connect', function () {\n      log.debug('connected with socket');\n      socketConn.emit('check_auth_status', channelPubKey);\n    });\n  }\n  var reconnect = function reconnect() {\n    socketConn.once('connect', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            socketConn.emit('check_auth_status', channelPubKey);\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3);\n    })));\n  };\n  var visibilityListener = function visibilityListener() {\n    // if channel is closed, then remove the listener.\n    if (!socketConn) {\n      document.removeEventListener('visibilitychange', visibilityListener);\n      return;\n    }\n    // if not connected, then wait for connection and ping server for latest msg.\n    if (!socketConn.connected && document.visibilityState === 'visible') {\n      reconnect();\n    }\n  };\n  var listener = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(ev) {\n      var decData;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.prev = 0;\n            _context4.next = 3;\n            return decryptData(channelEncPrivKey.toString('hex'), ev);\n          case 3:\n            decData = _context4.sent;\n            log.info(decData);\n            fn(decData);\n            _context4.next = 11;\n            break;\n          case 8:\n            _context4.prev = 8;\n            _context4.t0 = _context4[\"catch\"](0);\n            log.error(_context4.t0);\n          case 11:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4, null, [[0, 8]]);\n    }));\n    return function listener(_x) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n  socketConn.on('disconnect', function () {\n    log.debug('socket disconnected');\n    if (runningChannels.has(channelName)) {\n      log.error('socket disconnected unexpectedly, reconnecting socket');\n      reconnect();\n    }\n  });\n  socketConn.on(channelPubKey + \"_success\", listener);\n  if (typeof document !== 'undefined') document.addEventListener('visibilitychange', visibilityListener);\n  return socketConn;\n}\nexport function removeStorageEventListener() {\n  if (SOCKET_CONN_INSTANCE) {\n    SOCKET_CONN_INSTANCE.disconnect();\n  }\n}\nexport function create(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  if (!canBeUsed(options)) {\n    throw new Error('BroadcastChannel: server cannot be used');\n  }\n  var uuid = randomToken();\n\n  /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */\n  var eMIs = new ObliviousSet(options.server.removeTimeout);\n  var state = {\n    channelName: channelName,\n    uuid: uuid,\n    eMIs: eMIs,\n    // emittedMessagesIds\n    serverUrl: options.server.url\n  };\n  if (options.server.timeout) state.timeout = options.server.timeout;\n  setupSocketConnection(options.server.url, channelName, function (msgObj) {\n    if (!state.messagesCallback) return; // no listener\n    if (msgObj.uuid === state.uuid) return; // own message\n    if (!msgObj.token || state.eMIs.has(msgObj.token)) return; // already emitted\n    // if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n\n    state.eMIs.add(msgObj.token);\n    state.messagesCallback(msgObj.data);\n  });\n  runningChannels.add(channelName);\n  return state;\n}\nexport function close(channelState) {\n  runningChannels[\"delete\"](channelState.channelName);\n  // give 2 sec for all msgs which are in transit to be consumed\n  // by receiver.\n  // window.setTimeout(() => {\n  //     removeStorageEventListener(channelState);\n  //     SOCKET_CONN_INSTANCE = null;\n  // }, 1000);\n}\n\nexport function onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  return true;\n}\nexport function averageResponseTime() {\n  var defaultTime = 500;\n  // TODO: Maybe increase it based on operation\n  return defaultTime;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};","map":{"version":3,"names":["_asyncToGenerator","_regeneratorRuntime","ObliviousSet","io","getPublic","sign","encryptData","decryptData","keccak256","log","fillOptionsWithDefaults","sleep","randomToken","microSeconds","micro","KEY_PREFIX","type","SOCKET_CONN_INSTANCE","runningChannels","Set","storageKey","channelName","postMessage","channelState","messageJson","Promise","res","rej","then","mark","_callee","key","channelEncPrivKey","encData","body","wrap","_callee$","_context","prev","next","Buffer","from","toString","token","time","Date","getTime","data","uuid","sent","t0","t1","t2","signature","timeout","abrupt","fetch","serverUrl","method","JSON","stringify","headers","stop","getSocketInstance","SOCKET_CONN","transports","withCredentials","reconnectionDelayMax","reconnectionAttempts","on","err","opts","error","_callee2","engine","_callee2$","_context2","debug","transport","name","once","reason","disconnect","setupSocketConnection","fn","socketConn","channelPubKey","connected","emit","reconnect","_callee3","_callee3$","_context3","visibilityListener","document","removeEventListener","visibilityState","listener","_ref4","_callee4","ev","decData","_callee4$","_context4","info","_x","apply","arguments","has","addEventListener","removeStorageEventListener","create","options","canBeUsed","Error","eMIs","server","removeTimeout","state","url","msgObj","messagesCallback","add","close","onMessage","messagesCallbackTime","averageResponseTime","defaultTime"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@toruslabs/broadcast-channel/dist/esbrowser/methods/server.js"],"sourcesContent":["import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */\n\nimport { ObliviousSet } from 'oblivious-set';\nimport { io } from 'socket.io-client';\nimport { getPublic, sign } from '@toruslabs/eccrypto';\nimport { encryptData, decryptData, keccak256 } from '@toruslabs/metadata-helpers';\nimport { log } from '../util';\nimport { fillOptionsWithDefaults } from '../options';\nimport { sleep, randomToken, microSeconds as micro } from '../util';\nexport var microSeconds = micro;\nvar KEY_PREFIX = 'pubkey.broadcastChannel-';\nexport var type = 'server';\nvar SOCKET_CONN_INSTANCE = null;\n// used to decide to reconnect socket e.g. when socket connection is disconnected unexpectedly\nvar runningChannels = new Set();\nexport function storageKey(channelName) {\n  return KEY_PREFIX + channelName;\n}\n\n/**\n * writes the new message to the storage\n * and fires the storage-event so other readers can find it\n */\nexport function postMessage(channelState, messageJson) {\n  return new Promise(function (res, rej) {\n    sleep().then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var key, channelEncPrivKey, encData, body;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            key = storageKey(channelState.channelName);\n            channelEncPrivKey = keccak256(Buffer.from(key, 'utf8'));\n            _context.next = 4;\n            return encryptData(channelEncPrivKey.toString('hex'), {\n              token: randomToken(),\n              time: new Date().getTime(),\n              data: messageJson,\n              uuid: channelState.uuid\n            });\n          case 4:\n            encData = _context.sent;\n            _context.t0 = getPublic(channelEncPrivKey).toString('hex');\n            _context.t1 = encData;\n            _context.next = 9;\n            return sign(channelEncPrivKey, keccak256(Buffer.from(encData, 'utf8')));\n          case 9:\n            _context.t2 = _context.sent.toString('hex');\n            body = {\n              key: _context.t0,\n              data: _context.t1,\n              signature: _context.t2\n            };\n            if (channelState.timeout) body.timeout = channelState.timeout;\n            return _context.abrupt(\"return\", fetch(channelState.serverUrl + '/channel/set', {\n              method: 'POST',\n              body: JSON.stringify(body),\n              headers: {\n                'Content-Type': 'application/json; charset=utf-8'\n              }\n            }).then(res)[\"catch\"](rej));\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    })));\n  });\n}\nexport function getSocketInstance(serverUrl) {\n  if (SOCKET_CONN_INSTANCE) {\n    return SOCKET_CONN_INSTANCE;\n  }\n  var SOCKET_CONN = io(serverUrl, {\n    transports: ['websocket', 'polling'],\n    // use WebSocket first, if available\n    withCredentials: true,\n    reconnectionDelayMax: 10000,\n    reconnectionAttempts: 10\n  });\n  SOCKET_CONN.on('connect_error', function (err) {\n    // revert to classic upgrade\n    SOCKET_CONN.io.opts.transports = ['polling', 'websocket'];\n    log.error('connect error', err);\n  });\n  SOCKET_CONN.on('connect', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    var engine;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          engine = SOCKET_CONN.io.engine;\n          log.debug('initially connected to', engine.transport.name); // in most cases, prints \"polling\"\n          engine.once('upgrade', function () {\n            // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)\n            log.debug('upgraded', engine.transport.name); // in most cases, prints \"websocket\"\n          });\n\n          engine.once('close', function (reason) {\n            // called when the underlying connection is closed\n            log.debug('connection closed', reason);\n          });\n        case 4:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  })));\n  SOCKET_CONN.on('error', function (err) {\n    log.error('socket errored', err);\n    SOCKET_CONN.disconnect();\n  });\n  SOCKET_CONN_INSTANCE = SOCKET_CONN;\n  return SOCKET_CONN;\n}\nexport function setupSocketConnection(serverUrl, channelName, fn) {\n  var socketConn = getSocketInstance(serverUrl);\n  var key = storageKey(channelName);\n  var channelEncPrivKey = keccak256(Buffer.from(key, 'utf8'));\n  var channelPubKey = getPublic(channelEncPrivKey).toString('hex');\n  if (socketConn.connected) {\n    socketConn.emit('check_auth_status', channelPubKey);\n  } else {\n    socketConn.once('connect', function () {\n      log.debug('connected with socket');\n      socketConn.emit('check_auth_status', channelPubKey);\n    });\n  }\n  var reconnect = function reconnect() {\n    socketConn.once('connect', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            socketConn.emit('check_auth_status', channelPubKey);\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3);\n    })));\n  };\n  var visibilityListener = function visibilityListener() {\n    // if channel is closed, then remove the listener.\n    if (!socketConn) {\n      document.removeEventListener('visibilitychange', visibilityListener);\n      return;\n    }\n    // if not connected, then wait for connection and ping server for latest msg.\n    if (!socketConn.connected && document.visibilityState === 'visible') {\n      reconnect();\n    }\n  };\n  var listener = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(ev) {\n      var decData;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.prev = 0;\n            _context4.next = 3;\n            return decryptData(channelEncPrivKey.toString('hex'), ev);\n          case 3:\n            decData = _context4.sent;\n            log.info(decData);\n            fn(decData);\n            _context4.next = 11;\n            break;\n          case 8:\n            _context4.prev = 8;\n            _context4.t0 = _context4[\"catch\"](0);\n            log.error(_context4.t0);\n          case 11:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4, null, [[0, 8]]);\n    }));\n    return function listener(_x) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n  socketConn.on('disconnect', function () {\n    log.debug('socket disconnected');\n    if (runningChannels.has(channelName)) {\n      log.error('socket disconnected unexpectedly, reconnecting socket');\n      reconnect();\n    }\n  });\n  socketConn.on(channelPubKey + \"_success\", listener);\n  if (typeof document !== 'undefined') document.addEventListener('visibilitychange', visibilityListener);\n  return socketConn;\n}\nexport function removeStorageEventListener() {\n  if (SOCKET_CONN_INSTANCE) {\n    SOCKET_CONN_INSTANCE.disconnect();\n  }\n}\nexport function create(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  if (!canBeUsed(options)) {\n    throw new Error('BroadcastChannel: server cannot be used');\n  }\n  var uuid = randomToken();\n\n  /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */\n  var eMIs = new ObliviousSet(options.server.removeTimeout);\n  var state = {\n    channelName: channelName,\n    uuid: uuid,\n    eMIs: eMIs,\n    // emittedMessagesIds\n    serverUrl: options.server.url\n  };\n  if (options.server.timeout) state.timeout = options.server.timeout;\n  setupSocketConnection(options.server.url, channelName, function (msgObj) {\n    if (!state.messagesCallback) return; // no listener\n    if (msgObj.uuid === state.uuid) return; // own message\n    if (!msgObj.token || state.eMIs.has(msgObj.token)) return; // already emitted\n    // if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n\n    state.eMIs.add(msgObj.token);\n    state.messagesCallback(msgObj.data);\n  });\n  runningChannels.add(channelName);\n  return state;\n}\nexport function close(channelState) {\n  runningChannels[\"delete\"](channelState.channelName);\n  // give 2 sec for all msgs which are in transit to be consumed\n  // by receiver.\n  // window.setTimeout(() => {\n  //     removeStorageEventListener(channelState);\n  //     SOCKET_CONN_INSTANCE = null;\n  // }, 1000);\n}\n\nexport function onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  return true;\n}\nexport function averageResponseTime() {\n  var defaultTime = 500;\n  // TODO: Maybe increase it based on operation\n  return defaultTime;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}