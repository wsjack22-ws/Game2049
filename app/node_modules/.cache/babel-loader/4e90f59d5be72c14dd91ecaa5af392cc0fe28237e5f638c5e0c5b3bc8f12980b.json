{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StateClient = void 0;\nconst eventemitter3_1 = __importDefault(require(\"eventemitter3\"));\nconst camelcase_1 = __importDefault(require(\"camelcase\"));\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst provider_js_1 = require(\"../../provider.js\");\nconst index_js_1 = require(\"../../coder/index.js\");\nconst common_js_1 = require(\"../common.js\");\nconst pubkey_js_1 = require(\"../../utils/pubkey.js\");\nconst instruction_js_1 = __importDefault(require(\"./instruction.js\"));\nconst rpc_js_1 = __importDefault(require(\"./rpc.js\"));\nconst transaction_js_1 = __importDefault(require(\"./transaction.js\"));\nclass StateFactory {\n  static build(idl, coder, programId, provider) {\n    if (idl.state === undefined) {\n      return undefined;\n    }\n    return new StateClient(idl, programId, provider, coder);\n  }\n}\nexports.default = StateFactory;\n/**\n * A client for the program state. Similar to the base [[Program]] client,\n * one can use this to send transactions and read accounts for the state\n * abstraction.\n */\nclass StateClient {\n  constructor(idl, programId,\n  /**\n   * Returns the client's wallet and network provider.\n   */\n  provider = (0, provider_js_1.getProvider)(),\n  /**\n   * Returns the coder.\n   */\n  coder = new index_js_1.BorshCoder(idl)) {\n    this.provider = provider;\n    this.coder = coder;\n    this._idl = idl;\n    this._programId = programId;\n    this._address = programStateAddress(programId);\n    this._sub = null;\n    // Build namespaces.\n    const [instruction, transaction, rpc] = (() => {\n      var _a;\n      let instruction = {};\n      let transaction = {};\n      let rpc = {};\n      (_a = idl.state) === null || _a === void 0 ? void 0 : _a.methods.forEach(m => {\n        // Build instruction method.\n        const ixItem = instruction_js_1.default.build(m, (ixName, ix) => coder.instruction.encodeState(ixName, ix), programId);\n        ixItem[\"accounts\"] = accounts => {\n          const keys = stateInstructionKeys(programId, provider, m, accounts);\n          return keys.concat(instruction_js_1.default.accountsArray(accounts, m.accounts, m.name));\n        };\n        // Build transaction method.\n        const txItem = transaction_js_1.default.build(m, ixItem);\n        // Build RPC method.\n        const rpcItem = rpc_js_1.default.build(m, txItem, (0, common_js_1.parseIdlErrors)(idl), provider);\n        // Attach them all to their respective namespaces.\n        const name = (0, camelcase_1.default)(m.name);\n        instruction[name] = ixItem;\n        transaction[name] = txItem;\n        rpc[name] = rpcItem;\n      });\n      return [instruction, transaction, rpc];\n    })();\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.rpc = rpc;\n  }\n  /**\n   * Returns the program ID owning the state.\n   */\n  get programId() {\n    return this._programId;\n  }\n  /**\n   * Returns the deserialized state account.\n   */\n  async fetch() {\n    const addr = this.address();\n    const accountInfo = await this.provider.connection.getAccountInfo(addr);\n    if (accountInfo === null) {\n      throw new Error(`Account does not exist ${addr.toString()}`);\n    }\n    // Assert the account discriminator is correct.\n    const state = this._idl.state;\n    if (!state) {\n      throw new Error(\"State is not specified in IDL.\");\n    }\n    const expectedDiscriminator = await (0, index_js_1.stateDiscriminator)(state.struct.name);\n    if (expectedDiscriminator.compare(accountInfo.data.slice(0, 8))) {\n      throw new Error(\"Invalid account discriminator\");\n    }\n    return this.coder.state.decode(accountInfo.data);\n  }\n  /**\n   * Returns the state address.\n   */\n  address() {\n    return this._address;\n  }\n  /**\n   * Returns an `EventEmitter` with a `\"change\"` event that's fired whenever\n   * the state account cahnges.\n   */\n  subscribe(commitment) {\n    if (this._sub !== null) {\n      return this._sub.ee;\n    }\n    const ee = new eventemitter3_1.default();\n    const listener = this.provider.connection.onAccountChange(this.address(), acc => {\n      const account = this.coder.state.decode(acc.data);\n      ee.emit(\"change\", account);\n    }, commitment);\n    this._sub = {\n      ee,\n      listener\n    };\n    return ee;\n  }\n  /**\n   * Unsubscribes to state changes.\n   */\n  unsubscribe() {\n    if (this._sub !== null) {\n      this.provider.connection.removeAccountChangeListener(this._sub.listener).then(async () => {\n        this._sub = null;\n      }).catch(console.error);\n    }\n  }\n}\nexports.StateClient = StateClient;\n// Calculates the deterministic address of the program's \"state\" account.\nfunction programStateAddress(programId) {\n  let [registrySigner] = (0, pubkey_js_1.findProgramAddressSync)([], programId);\n  return (0, pubkey_js_1.createWithSeedSync)(registrySigner, \"unversioned\", programId);\n}\n// Returns the common keys that are prepended to all instructions targeting\n// the \"state\" of a program.\nfunction stateInstructionKeys(programId, provider, m, accounts) {\n  if (m.name === \"new\") {\n    // Ctor `new` method.\n    const [programSigner] = (0, pubkey_js_1.findProgramAddressSync)([], programId);\n    // @ts-expect-error\n    if (provider.wallet === undefined) {\n      throw new Error(\"This function requires the Provider interface implementor to have a 'wallet' field.\");\n    }\n    return [{\n      // @ts-expect-error\n      pubkey: provider.wallet.publicKey,\n      isWritable: false,\n      isSigner: true\n    }, {\n      pubkey: programStateAddress(programId),\n      isWritable: true,\n      isSigner: false\n    }, {\n      pubkey: programSigner,\n      isWritable: false,\n      isSigner: false\n    }, {\n      pubkey: web3_js_1.SystemProgram.programId,\n      isWritable: false,\n      isSigner: false\n    }, {\n      pubkey: programId,\n      isWritable: false,\n      isSigner: false\n    }];\n  } else {\n    (0, common_js_1.validateAccounts)(m.accounts, accounts);\n    return [{\n      pubkey: programStateAddress(programId),\n      isWritable: true,\n      isSigner: false\n    }];\n  }\n}","map":{"version":3,"names":["eventemitter3_1","__importDefault","require","camelcase_1","web3_js_1","provider_js_1","index_js_1","common_js_1","pubkey_js_1","instruction_js_1","rpc_js_1","transaction_js_1","StateFactory","build","idl","coder","programId","provider","state","undefined","StateClient","exports","default","constructor","getProvider","BorshCoder","_idl","_programId","_address","programStateAddress","_sub","instruction","transaction","rpc","_a","methods","forEach","m","ixItem","ixName","ix","encodeState","accounts","keys","stateInstructionKeys","concat","accountsArray","name","txItem","rpcItem","parseIdlErrors","fetch","addr","address","accountInfo","connection","getAccountInfo","Error","toString","expectedDiscriminator","stateDiscriminator","struct","compare","data","slice","decode","subscribe","commitment","ee","listener","onAccountChange","acc","account","emit","unsubscribe","removeAccountChangeListener","then","catch","console","error","registrySigner","findProgramAddressSync","createWithSeedSync","programSigner","wallet","pubkey","publicKey","isWritable","isSigner","SystemProgram","validateAccounts"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/program/namespace/state.ts"],"sourcesContent":["import EventEmitter from \"eventemitter3\";\nimport camelCase from \"camelcase\";\nimport {\n  PublicKey,\n  SystemProgram,\n  Commitment,\n  AccountMeta,\n} from \"@solana/web3.js\";\nimport Provider, { getProvider } from \"../../provider.js\";\nimport { Idl, IdlInstruction, IdlStateMethod, IdlTypeDef } from \"../../idl.js\";\nimport { BorshCoder, Coder, stateDiscriminator } from \"../../coder/index.js\";\nimport {\n  RpcNamespace,\n  InstructionNamespace,\n  TransactionNamespace,\n} from \"./index.js\";\nimport { Subscription, validateAccounts, parseIdlErrors } from \"../common.js\";\nimport {\n  findProgramAddressSync,\n  createWithSeedSync,\n} from \"../../utils/pubkey.js\";\nimport { Accounts } from \"../context.js\";\nimport InstructionNamespaceFactory from \"./instruction.js\";\nimport RpcNamespaceFactory from \"./rpc.js\";\nimport TransactionNamespaceFactory from \"./transaction.js\";\nimport { IdlTypes, TypeDef } from \"./types.js\";\n\nexport default class StateFactory {\n  public static build<IDL extends Idl>(\n    idl: IDL,\n    coder: Coder,\n    programId: PublicKey,\n    provider?: Provider\n  ): StateClient<IDL> | undefined {\n    if (idl.state === undefined) {\n      return undefined;\n    }\n    return new StateClient(idl, programId, provider, coder);\n  }\n}\n\ntype NullableMethods<IDL extends Idl> = IDL[\"state\"] extends undefined\n  ? IdlInstruction[]\n  : NonNullable<IDL[\"state\"]>[\"methods\"];\n\n/**\n * A client for the program state. Similar to the base [[Program]] client,\n * one can use this to send transactions and read accounts for the state\n * abstraction.\n */\nexport class StateClient<IDL extends Idl> {\n  /**\n   * [[RpcNamespace]] for all state methods.\n   */\n  readonly rpc: RpcNamespace<IDL, NullableMethods<IDL>[number]>;\n\n  /**\n   * [[InstructionNamespace]] for all state methods.\n   */\n  readonly instruction: InstructionNamespace<IDL, NullableMethods<IDL>[number]>;\n\n  /**\n   * [[TransactionNamespace]] for all state methods.\n   */\n  readonly transaction: TransactionNamespace<IDL, NullableMethods<IDL>[number]>;\n\n  /**\n   * Returns the program ID owning the state.\n   */\n  get programId(): PublicKey {\n    return this._programId;\n  }\n  private _programId: PublicKey;\n\n  private _address: PublicKey;\n  private _coder: Coder;\n  private _idl: IDL;\n  private _sub: Subscription | null;\n\n  constructor(\n    idl: IDL,\n    programId: PublicKey,\n    /**\n     * Returns the client's wallet and network provider.\n     */\n    public readonly provider: Provider = getProvider(),\n    /**\n     * Returns the coder.\n     */\n    public readonly coder: Coder = new BorshCoder(idl)\n  ) {\n    this._idl = idl;\n    this._programId = programId;\n    this._address = programStateAddress(programId);\n    this._sub = null;\n\n    // Build namespaces.\n    const [instruction, transaction, rpc] = ((): [\n      InstructionNamespace<IDL, NullableMethods<IDL>[number]>,\n      TransactionNamespace<IDL, NullableMethods<IDL>[number]>,\n      RpcNamespace<IDL, NullableMethods<IDL>[number]>\n    ] => {\n      let instruction: InstructionNamespace = {};\n      let transaction: TransactionNamespace = {};\n      let rpc: RpcNamespace = {};\n\n      idl.state?.methods.forEach(\n        <I extends NullableMethods<IDL>[number]>(m: I) => {\n          // Build instruction method.\n          const ixItem = InstructionNamespaceFactory.build<IDL, I>(\n            m,\n            (ixName, ix) => coder.instruction.encodeState(ixName, ix),\n            programId\n          );\n          ixItem[\"accounts\"] = (accounts) => {\n            const keys = stateInstructionKeys(programId, provider, m, accounts);\n            return keys.concat(\n              InstructionNamespaceFactory.accountsArray(\n                accounts,\n                m.accounts,\n                m.name\n              )\n            );\n          };\n          // Build transaction method.\n          const txItem = TransactionNamespaceFactory.build(m, ixItem);\n          // Build RPC method.\n          const rpcItem = RpcNamespaceFactory.build(\n            m,\n            txItem,\n            parseIdlErrors(idl),\n            provider\n          );\n\n          // Attach them all to their respective namespaces.\n          const name = camelCase(m.name);\n          instruction[name] = ixItem;\n          transaction[name] = txItem;\n          rpc[name] = rpcItem;\n        }\n      );\n\n      return [\n        instruction as InstructionNamespace<IDL, NullableMethods<IDL>[number]>,\n        transaction as TransactionNamespace<IDL, NullableMethods<IDL>[number]>,\n        rpc as RpcNamespace<IDL, NullableMethods<IDL>[number]>,\n      ];\n    })();\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.rpc = rpc;\n  }\n\n  /**\n   * Returns the deserialized state account.\n   */\n  async fetch(): Promise<\n    TypeDef<\n      IDL[\"state\"] extends undefined\n        ? IdlTypeDef\n        : NonNullable<IDL[\"state\"]>[\"struct\"],\n      IdlTypes<IDL>\n    >\n  > {\n    const addr = this.address();\n    const accountInfo = await this.provider.connection.getAccountInfo(addr);\n    if (accountInfo === null) {\n      throw new Error(`Account does not exist ${addr.toString()}`);\n    }\n    // Assert the account discriminator is correct.\n    const state = this._idl.state;\n    if (!state) {\n      throw new Error(\"State is not specified in IDL.\");\n    }\n    const expectedDiscriminator = await stateDiscriminator(state.struct.name);\n    if (expectedDiscriminator.compare(accountInfo.data.slice(0, 8))) {\n      throw new Error(\"Invalid account discriminator\");\n    }\n    return this.coder.state.decode(accountInfo.data);\n  }\n\n  /**\n   * Returns the state address.\n   */\n  address(): PublicKey {\n    return this._address;\n  }\n\n  /**\n   * Returns an `EventEmitter` with a `\"change\"` event that's fired whenever\n   * the state account cahnges.\n   */\n  subscribe(commitment?: Commitment): EventEmitter {\n    if (this._sub !== null) {\n      return this._sub.ee;\n    }\n    const ee = new EventEmitter();\n\n    const listener = this.provider.connection.onAccountChange(\n      this.address(),\n      (acc) => {\n        const account = this.coder.state.decode(acc.data);\n        ee.emit(\"change\", account);\n      },\n      commitment\n    );\n\n    this._sub = {\n      ee,\n      listener,\n    };\n\n    return ee;\n  }\n\n  /**\n   * Unsubscribes to state changes.\n   */\n  unsubscribe() {\n    if (this._sub !== null) {\n      this.provider.connection\n        .removeAccountChangeListener(this._sub.listener)\n        .then(async () => {\n          this._sub = null;\n        })\n        .catch(console.error);\n    }\n  }\n}\n\n// Calculates the deterministic address of the program's \"state\" account.\nfunction programStateAddress(programId: PublicKey): PublicKey {\n  let [registrySigner] = findProgramAddressSync([], programId);\n  return createWithSeedSync(registrySigner, \"unversioned\", programId);\n}\n\n// Returns the common keys that are prepended to all instructions targeting\n// the \"state\" of a program.\nfunction stateInstructionKeys<M extends IdlStateMethod>(\n  programId: PublicKey,\n  provider: Provider,\n  m: M,\n  accounts: Accounts<M[\"accounts\"][number]>\n): AccountMeta[] {\n  if (m.name === \"new\") {\n    // Ctor `new` method.\n    const [programSigner] = findProgramAddressSync([], programId);\n    // @ts-expect-error\n    if (provider.wallet === undefined) {\n      throw new Error(\n        \"This function requires the Provider interface implementor to have a 'wallet' field.\"\n      );\n    }\n    return [\n      {\n        // @ts-expect-error\n        pubkey: provider.wallet.publicKey,\n        isWritable: false,\n        isSigner: true,\n      },\n      {\n        pubkey: programStateAddress(programId),\n        isWritable: true,\n        isSigner: false,\n      },\n      { pubkey: programSigner, isWritable: false, isSigner: false },\n      {\n        pubkey: SystemProgram.programId,\n        isWritable: false,\n        isSigner: false,\n      },\n\n      { pubkey: programId, isWritable: false, isSigner: false },\n    ];\n  } else {\n    validateAccounts(m.accounts, accounts);\n    return [\n      {\n        pubkey: programStateAddress(programId),\n        isWritable: true,\n        isSigner: false,\n      },\n    ];\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}