{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.chooseFragments = exports.shuffle = exports.chooseDegree = void 0;\nconst utils_1 = require(\"./utils\");\nconst xoshiro_1 = __importDefault(require(\"./xoshiro\"));\nconst randomSampler = require('@apocentre/alias-sampling');\nconst chooseDegree = (seqLenth, rng) => {\n  const degreeProbabilities = [...new Array(seqLenth)].map((_, index) => 1 / (index + 1));\n  const degreeChooser = randomSampler(degreeProbabilities, null, rng.nextDouble);\n  return degreeChooser.next() + 1;\n};\nexports.chooseDegree = chooseDegree;\nconst shuffle = (items, rng) => {\n  let remaining = [...items];\n  let result = [];\n  while (remaining.length > 0) {\n    let index = rng.nextInt(0, remaining.length - 1);\n    let item = remaining[index];\n    // remaining.erase(remaining.begin() + index);\n    remaining.splice(index, 1);\n    result.push(item);\n  }\n  return result;\n};\nexports.shuffle = shuffle;\nconst chooseFragments = (seqNum, seqLength, checksum) => {\n  // The first `seqLenth` parts are the \"pure\" fragments, not mixed with any\n  // others. This means that if you only generate the first `seqLenth` parts,\n  // then you have all the parts you need to decode the message.\n  if (seqNum <= seqLength) {\n    return [seqNum - 1];\n  } else {\n    const seed = Buffer.concat([utils_1.intToBytes(seqNum), utils_1.intToBytes(checksum)]);\n    const rng = new xoshiro_1.default(seed);\n    const degree = exports.chooseDegree(seqLength, rng);\n    const indexes = [...new Array(seqLength)].map((_, index) => index);\n    const shuffledIndexes = exports.shuffle(indexes, rng);\n    return shuffledIndexes.slice(0, degree);\n  }\n};\nexports.chooseFragments = chooseFragments;","map":{"version":3,"names":["utils_1","require","xoshiro_1","__importDefault","randomSampler","chooseDegree","seqLenth","rng","degreeProbabilities","Array","map","_","index","degreeChooser","nextDouble","next","exports","shuffle","items","remaining","result","length","nextInt","item","splice","push","chooseFragments","seqNum","seqLength","checksum","seed","Buffer","concat","intToBytes","default","degree","indexes","shuffledIndexes","slice"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@ngraveio/bc-ur/src/fountainUtils.ts"],"sourcesContent":["import { intToBytes } from \"./utils\";\nimport Xoshiro from \"./xoshiro\";\nconst randomSampler = require('@apocentre/alias-sampling');\n\nexport const chooseDegree = (seqLenth: number, rng: Xoshiro): number => {\n  const degreeProbabilities = [...new Array(seqLenth)].map((_, index) => 1 / (index + 1));\n  const degreeChooser = randomSampler(degreeProbabilities, null, rng.nextDouble);\n\n  return degreeChooser.next() + 1;\n}\n\n\nexport const shuffle = (items: any[], rng: Xoshiro): any[] => {\n  let remaining = [...items];\n  let result = [];\n\n  while (remaining.length > 0) {\n    let index = rng.nextInt(0, remaining.length - 1);\n    let item = remaining[index];\n    // remaining.erase(remaining.begin() + index);\n    remaining.splice(index, 1);\n    result.push(item);\n  }\n\n  return result;\n}\n\n\nexport const chooseFragments = (seqNum: number, seqLength: number, checksum: number): number[] => {\n  // The first `seqLenth` parts are the \"pure\" fragments, not mixed with any\n  // others. This means that if you only generate the first `seqLenth` parts,\n  // then you have all the parts you need to decode the message.\n  if (seqNum <= seqLength) {\n    return [seqNum - 1];\n  } else {\n    const seed = Buffer.concat([intToBytes(seqNum), intToBytes(checksum)]);\n    const rng = new Xoshiro(seed);\n    const degree = chooseDegree(seqLength, rng);\n    const indexes = [...new Array(seqLength)].map((_, index) => index);\n    const shuffledIndexes = shuffle(indexes, rng);\n\n    return shuffledIndexes.slice(0, degree);\n  }\n}"],"mappings":";;;;;;;;;;;AAAA,MAAAA,OAAA,GAAAC,OAAA;AACA,MAAAC,SAAA,GAAAC,eAAA,CAAAF,OAAA;AACA,MAAMG,aAAa,GAAGH,OAAO,CAAC,2BAA2B,CAAC;AAEnD,MAAMI,YAAY,GAAGA,CAACC,QAAgB,EAAEC,GAAY,KAAY;EACrE,MAAMC,mBAAmB,GAAG,CAAC,GAAG,IAAIC,KAAK,CAACH,QAAQ,CAAC,CAAC,CAACI,GAAG,CAAC,CAACC,CAAC,EAAEC,KAAK,KAAK,CAAC,IAAIA,KAAK,GAAG,CAAC,CAAC,CAAC;EACvF,MAAMC,aAAa,GAAGT,aAAa,CAACI,mBAAmB,EAAE,IAAI,EAAED,GAAG,CAACO,UAAU,CAAC;EAE9E,OAAOD,aAAa,CAACE,IAAI,EAAE,GAAG,CAAC;AACjC,CAAC;AALYC,OAAA,CAAAX,YAAY,GAAAA,YAAA;AAQlB,MAAMY,OAAO,GAAGA,CAACC,KAAY,EAAEX,GAAY,KAAW;EAC3D,IAAIY,SAAS,GAAG,CAAC,GAAGD,KAAK,CAAC;EAC1B,IAAIE,MAAM,GAAG,EAAE;EAEf,OAAOD,SAAS,CAACE,MAAM,GAAG,CAAC,EAAE;IAC3B,IAAIT,KAAK,GAAGL,GAAG,CAACe,OAAO,CAAC,CAAC,EAAEH,SAAS,CAACE,MAAM,GAAG,CAAC,CAAC;IAChD,IAAIE,IAAI,GAAGJ,SAAS,CAACP,KAAK,CAAC;IAC3B;IACAO,SAAS,CAACK,MAAM,CAACZ,KAAK,EAAE,CAAC,CAAC;IAC1BQ,MAAM,CAACK,IAAI,CAACF,IAAI,CAAC;;EAGnB,OAAOH,MAAM;AACf,CAAC;AAbYJ,OAAA,CAAAC,OAAO,GAAAA,OAAA;AAgBb,MAAMS,eAAe,GAAGA,CAACC,MAAc,EAAEC,SAAiB,EAAEC,QAAgB,KAAc;EAC/F;EACA;EACA;EACA,IAAIF,MAAM,IAAIC,SAAS,EAAE;IACvB,OAAO,CAACD,MAAM,GAAG,CAAC,CAAC;GACpB,MAAM;IACL,MAAMG,IAAI,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAChC,OAAA,CAAAiC,UAAU,CAACN,MAAM,CAAC,EAAE3B,OAAA,CAAAiC,UAAU,CAACJ,QAAQ,CAAC,CAAC,CAAC;IACtE,MAAMtB,GAAG,GAAG,IAAIL,SAAA,CAAAgC,OAAO,CAACJ,IAAI,CAAC;IAC7B,MAAMK,MAAM,GAAGnB,OAAA,CAAAX,YAAY,CAACuB,SAAS,EAAErB,GAAG,CAAC;IAC3C,MAAM6B,OAAO,GAAG,CAAC,GAAG,IAAI3B,KAAK,CAACmB,SAAS,CAAC,CAAC,CAAClB,GAAG,CAAC,CAACC,CAAC,EAAEC,KAAK,KAAKA,KAAK,CAAC;IAClE,MAAMyB,eAAe,GAAGrB,OAAA,CAAAC,OAAO,CAACmB,OAAO,EAAE7B,GAAG,CAAC;IAE7C,OAAO8B,eAAe,CAACC,KAAK,CAAC,CAAC,EAAEH,MAAM,CAAC;;AAE3C,CAAC;AAfYnB,OAAA,CAAAU,eAAe,GAAAA,eAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}