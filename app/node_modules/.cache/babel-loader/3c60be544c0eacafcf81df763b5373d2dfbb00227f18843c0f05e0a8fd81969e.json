{"ast":null,"code":"import { PublicKey } from \"@solana/web3.js\";\nimport * as borsh from \"@project-serum/borsh\";\n// Deterministic IDL address as a function of the program id.\nexport async function idlAddress(programId) {\n  const base = (await PublicKey.findProgramAddress([], programId))[0];\n  return await PublicKey.createWithSeed(base, seed(), programId);\n}\n// Seed for generating the idlAddress.\nexport function seed() {\n  return \"anchor:idl\";\n}\nconst IDL_ACCOUNT_LAYOUT = borsh.struct([borsh.publicKey(\"authority\"), borsh.vecU8(\"data\")]);\nexport function decodeIdlAccount(data) {\n  return IDL_ACCOUNT_LAYOUT.decode(data);\n}\nexport function encodeIdlAccount(acc) {\n  const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n  const len = IDL_ACCOUNT_LAYOUT.encode(acc, buffer);\n  return buffer.slice(0, len);\n}","map":{"version":3,"names":["PublicKey","borsh","idlAddress","programId","base","findProgramAddress","createWithSeed","seed","IDL_ACCOUNT_LAYOUT","struct","publicKey","vecU8","decodeIdlAccount","data","decode","encodeIdlAccount","acc","buffer","Buffer","alloc","len","encode","slice"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/idl.ts"],"sourcesContent":["import { PublicKey } from \"@solana/web3.js\";\nimport * as borsh from \"@project-serum/borsh\";\n\nexport type Idl = {\n  version: string;\n  name: string;\n  instructions: IdlInstruction[];\n  state?: IdlState;\n  accounts?: IdlTypeDef[];\n  types?: IdlTypeDef[];\n  events?: IdlEvent[];\n  errors?: IdlErrorCode[];\n};\n\nexport type IdlEvent = {\n  name: string;\n  fields: IdlEventField[];\n};\n\nexport type IdlEventField = {\n  name: string;\n  type: IdlType;\n  index: boolean;\n};\n\nexport type IdlInstruction = {\n  name: string;\n  accounts: IdlAccountItem[];\n  args: IdlField[];\n};\n\nexport type IdlState = {\n  struct: IdlTypeDef;\n  methods: IdlStateMethod[];\n};\n\nexport type IdlStateMethod = IdlInstruction;\n\nexport type IdlAccountItem = IdlAccount | IdlAccounts;\n\nexport type IdlAccount = {\n  name: string;\n  isMut: boolean;\n  isSigner: boolean;\n};\n\n// A nested/recursive version of IdlAccount.\nexport type IdlAccounts = {\n  name: string;\n  accounts: IdlAccountItem[];\n};\n\nexport type IdlField = {\n  name: string;\n  type: IdlType;\n};\n\nexport type IdlTypeDef = {\n  name: string;\n  type: IdlTypeDefTy;\n};\n\nexport type IdlTypeDefTyStruct = {\n  kind: \"struct\";\n  fields: IdlTypeDefStruct;\n};\n\nexport type IdlTypeDefTyEnum = {\n  kind: \"enum\";\n  variants: IdlEnumVariant[];\n};\n\ntype IdlTypeDefTy = IdlTypeDefTyEnum | IdlTypeDefTyStruct;\n\ntype IdlTypeDefStruct = Array<IdlField>;\n\nexport type IdlType =\n  | \"bool\"\n  | \"u8\"\n  | \"i8\"\n  | \"u16\"\n  | \"i16\"\n  | \"u32\"\n  | \"i32\"\n  | \"u64\"\n  | \"i64\"\n  | \"u128\"\n  | \"i128\"\n  | \"bytes\"\n  | \"string\"\n  | \"publicKey\"\n  | IdlTypeDefined\n  | IdlTypeOption\n  | IdlTypeVec\n  | IdlTypeArray;\n\n// User defined type.\nexport type IdlTypeDefined = {\n  defined: string;\n};\n\nexport type IdlTypeOption = {\n  option: IdlType;\n};\n\nexport type IdlTypeVec = {\n  vec: IdlType;\n};\n\nexport type IdlTypeArray = {\n  array: [idlType: IdlType, size: number];\n};\n\nexport type IdlEnumVariant = {\n  name: string;\n  fields?: IdlEnumFields;\n};\n\ntype IdlEnumFields = IdlEnumFieldsNamed | IdlEnumFieldsTuple;\n\ntype IdlEnumFieldsNamed = IdlField[];\n\ntype IdlEnumFieldsTuple = IdlType[];\n\nexport type IdlErrorCode = {\n  code: number;\n  name: string;\n  msg?: string;\n};\n\n// Deterministic IDL address as a function of the program id.\nexport async function idlAddress(programId: PublicKey): Promise<PublicKey> {\n  const base = (await PublicKey.findProgramAddress([], programId))[0];\n  return await PublicKey.createWithSeed(base, seed(), programId);\n}\n\n// Seed for generating the idlAddress.\nexport function seed(): string {\n  return \"anchor:idl\";\n}\n\n// The on-chain account of the IDL.\nexport interface IdlProgramAccount {\n  authority: PublicKey;\n  data: Buffer;\n}\n\nconst IDL_ACCOUNT_LAYOUT: borsh.Layout<IdlProgramAccount> = borsh.struct([\n  borsh.publicKey(\"authority\"),\n  borsh.vecU8(\"data\"),\n]);\n\nexport function decodeIdlAccount(data: Buffer): IdlProgramAccount {\n  return IDL_ACCOUNT_LAYOUT.decode(data);\n}\n\nexport function encodeIdlAccount(acc: IdlProgramAccount): Buffer {\n  const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n  const len = IDL_ACCOUNT_LAYOUT.encode(acc, buffer);\n  return buffer.slice(0, len);\n}\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,iBAAiB;AAC3C,OAAO,KAAKC,KAAK,MAAM,sBAAsB;AAiI7C;AACA,OAAO,eAAeC,UAAUA,CAACC,SAAoB;EACnD,MAAMC,IAAI,GAAG,CAAC,MAAMJ,SAAS,CAACK,kBAAkB,CAAC,EAAE,EAAEF,SAAS,CAAC,EAAE,CAAC,CAAC;EACnE,OAAO,MAAMH,SAAS,CAACM,cAAc,CAACF,IAAI,EAAEG,IAAI,EAAE,EAAEJ,SAAS,CAAC;AAChE;AAEA;AACA,OAAM,SAAUI,IAAIA,CAAA;EAClB,OAAO,YAAY;AACrB;AAQA,MAAMC,kBAAkB,GAAoCP,KAAK,CAACQ,MAAM,CAAC,CACvER,KAAK,CAACS,SAAS,CAAC,WAAW,CAAC,EAC5BT,KAAK,CAACU,KAAK,CAAC,MAAM,CAAC,CACpB,CAAC;AAEF,OAAM,SAAUC,gBAAgBA,CAACC,IAAY;EAC3C,OAAOL,kBAAkB,CAACM,MAAM,CAACD,IAAI,CAAC;AACxC;AAEA,OAAM,SAAUE,gBAAgBA,CAACC,GAAsB;EACrD,MAAMC,MAAM,GAAGC,MAAM,CAACC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;EACnC,MAAMC,GAAG,GAAGZ,kBAAkB,CAACa,MAAM,CAACL,GAAG,EAAEC,MAAM,CAAC;EAClD,OAAOA,MAAM,CAACK,KAAK,CAAC,CAAC,EAAEF,GAAG,CAAC;AAC7B"},"metadata":{},"sourceType":"module","externalDependencies":[]}