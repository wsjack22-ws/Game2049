{"ast":null,"code":"import { splitArgsAndCtx } from \"../context\";\nimport { EventParser } from \"../event\";\nimport { ProgramError } from \"../../error\";\nexport default class SimulateFactory {\n  static build(idlIx, txFn, idlErrors, provider, coder, programId, idl) {\n    const simulate = async (...args) => {\n      const tx = txFn(...args);\n      const [, ctx] = splitArgsAndCtx(idlIx, [...args]);\n      let resp = undefined;\n      try {\n        resp = await provider.simulate(tx, ctx.signers, ctx.options);\n      } catch (err) {\n        console.log(\"Translating error\", err);\n        let translatedErr = ProgramError.parse(err, idlErrors);\n        if (translatedErr === null) {\n          throw err;\n        }\n        throw translatedErr;\n      }\n      if (resp === undefined) {\n        throw new Error(\"Unable to simulate transaction\");\n      }\n      if (resp.value.err) {\n        throw new Error(`Simulate error: ${resp.value.err.toString()}`);\n      }\n      const logs = resp.value.logs;\n      if (!logs) {\n        throw new Error(\"Simulated logs not found\");\n      }\n      const events = [];\n      if (idl.events) {\n        let parser = new EventParser(programId, coder);\n        parser.parseLogs(logs, event => {\n          events.push(event);\n        });\n      }\n      return {\n        events,\n        raw: logs\n      };\n    };\n    return simulate;\n  }\n}","map":{"version":3,"names":["splitArgsAndCtx","EventParser","ProgramError","SimulateFactory","build","idlIx","txFn","idlErrors","provider","coder","programId","idl","simulate","args","tx","ctx","resp","undefined","signers","options","err","console","log","translatedErr","parse","Error","value","toString","logs","events","parser","parseLogs","event","push","raw"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/program/namespace/simulate.ts"],"sourcesContent":["import {\n  PublicKey,\n  RpcResponseAndContext,\n  SimulatedTransactionResponse,\n} from \"@solana/web3.js\";\nimport Provider from \"../../provider\";\nimport { splitArgsAndCtx } from \"../context\";\nimport { TransactionFn } from \"./transaction\";\nimport { EventParser, Event } from \"../event\";\nimport Coder from \"../../coder\";\nimport { Idl, IdlEvent } from \"../../idl\";\nimport { ProgramError } from \"../../error\";\nimport {\n  AllInstructions,\n  IdlTypes,\n  InstructionContextFn,\n  MakeInstructionsNamespace,\n} from \"./types\";\n\nexport default class SimulateFactory {\n  public static build<IDL extends Idl, I extends AllInstructions<IDL>>(\n    idlIx: AllInstructions<IDL>,\n    txFn: TransactionFn<IDL>,\n    idlErrors: Map<number, string>,\n    provider: Provider,\n    coder: Coder,\n    programId: PublicKey,\n    idl: IDL\n  ): SimulateFn<IDL, I> {\n    const simulate: SimulateFn<IDL> = async (...args) => {\n      const tx = txFn(...args);\n      const [, ctx] = splitArgsAndCtx(idlIx, [...args]);\n      let resp:\n        | RpcResponseAndContext<SimulatedTransactionResponse>\n        | undefined = undefined;\n      try {\n        resp = await provider!.simulate(tx, ctx.signers, ctx.options);\n      } catch (err) {\n        console.log(\"Translating error\", err);\n        let translatedErr = ProgramError.parse(err, idlErrors);\n        if (translatedErr === null) {\n          throw err;\n        }\n        throw translatedErr;\n      }\n      if (resp === undefined) {\n        throw new Error(\"Unable to simulate transaction\");\n      }\n      if (resp.value.err) {\n        throw new Error(`Simulate error: ${resp.value.err.toString()}`);\n      }\n      const logs = resp.value.logs;\n      if (!logs) {\n        throw new Error(\"Simulated logs not found\");\n      }\n\n      const events: Event<IdlEvent, IdlTypes<IDL>>[] = [];\n      if (idl.events) {\n        let parser = new EventParser(programId, coder);\n        parser.parseLogs(logs, (event) => {\n          events.push(event);\n        });\n      }\n      return { events, raw: logs };\n    };\n\n    return simulate;\n  }\n}\n\n/**\n * The namespace provides functions to simulate transactions for each method\n * of a program, returning a list of deserialized events *and* raw program\n * logs.\n *\n * One can use this to read data calculated from a program on chain, by\n * emitting an event in the program and reading the emitted event client side\n * via the `simulate` namespace.\n *\n * ## Usage\n *\n * ```javascript\n * program.simulate.<method>(...args, ctx);\n * ```\n *\n * ## Parameters\n *\n * 1. `args` - The positional arguments for the program. The type and number\n *    of these arguments depend on the program being used.\n * 2. `ctx`  - [[Context]] non-argument parameters to pass to the method.\n *    Always the last parameter in the method call.\n *\n * ## Example\n *\n * To simulate the `increment` method above,\n *\n * ```javascript\n * const events = await program.simulate.increment({\n *   accounts: {\n *     counter,\n *   },\n * });\n * ```\n */\nexport type SimulateNamespace<\n  IDL extends Idl = Idl,\n  I extends AllInstructions<IDL> = AllInstructions<IDL>\n> = MakeInstructionsNamespace<\n  IDL,\n  I,\n  Promise<SimulateResponse<NullableEvents<IDL>, IdlTypes<IDL>>>\n>;\n\ntype NullableEvents<IDL extends Idl> = IDL[\"events\"] extends undefined\n  ? IdlEvent\n  : NonNullable<IDL[\"events\"]>[number];\n\n/**\n * SimulateFn is a single method generated from an IDL. It simulates a method\n * against a cluster configured by the provider, returning a list of all the\n * events and raw logs that were emitted during the execution of the\n * method.\n */\nexport type SimulateFn<\n  IDL extends Idl = Idl,\n  I extends AllInstructions<IDL> = AllInstructions<IDL>\n> = InstructionContextFn<\n  IDL,\n  I,\n  Promise<SimulateResponse<NullableEvents<IDL>, IdlTypes<IDL>>>\n>;\n\ntype SimulateResponse<E extends IdlEvent, Defined> = {\n  events: readonly Event<E, Defined>[];\n  raw: readonly string[];\n};\n"],"mappings":"AAMA,SAASA,eAAe,QAAQ,YAAY;AAE5C,SAASC,WAAW,QAAe,UAAU;AAG7C,SAASC,YAAY,QAAQ,aAAa;AAQ1C,eAAc,MAAOC,eAAe;EAC3B,OAAOC,KAAKA,CACjBC,KAA2B,EAC3BC,IAAwB,EACxBC,SAA8B,EAC9BC,QAAkB,EAClBC,KAAY,EACZC,SAAoB,EACpBC,GAAQ;IAER,MAAMC,QAAQ,GAAoB,MAAAA,CAAO,GAAGC,IAAI,KAAI;MAClD,MAAMC,EAAE,GAAGR,IAAI,CAAC,GAAGO,IAAI,CAAC;MACxB,MAAM,GAAGE,GAAG,CAAC,GAAGf,eAAe,CAACK,KAAK,EAAE,CAAC,GAAGQ,IAAI,CAAC,CAAC;MACjD,IAAIG,IAAI,GAEQC,SAAS;MACzB,IAAI;QACFD,IAAI,GAAG,MAAMR,QAAS,CAACI,QAAQ,CAACE,EAAE,EAAEC,GAAG,CAACG,OAAO,EAAEH,GAAG,CAACI,OAAO,CAAC;OAC9D,CAAC,OAAOC,GAAG,EAAE;QACZC,OAAO,CAACC,GAAG,CAAC,mBAAmB,EAAEF,GAAG,CAAC;QACrC,IAAIG,aAAa,GAAGrB,YAAY,CAACsB,KAAK,CAACJ,GAAG,EAAEb,SAAS,CAAC;QACtD,IAAIgB,aAAa,KAAK,IAAI,EAAE;UAC1B,MAAMH,GAAG;;QAEX,MAAMG,aAAa;;MAErB,IAAIP,IAAI,KAAKC,SAAS,EAAE;QACtB,MAAM,IAAIQ,KAAK,CAAC,gCAAgC,CAAC;;MAEnD,IAAIT,IAAI,CAACU,KAAK,CAACN,GAAG,EAAE;QAClB,MAAM,IAAIK,KAAK,CAAC,mBAAmBT,IAAI,CAACU,KAAK,CAACN,GAAG,CAACO,QAAQ,EAAE,EAAE,CAAC;;MAEjE,MAAMC,IAAI,GAAGZ,IAAI,CAACU,KAAK,CAACE,IAAI;MAC5B,IAAI,CAACA,IAAI,EAAE;QACT,MAAM,IAAIH,KAAK,CAAC,0BAA0B,CAAC;;MAG7C,MAAMI,MAAM,GAAqC,EAAE;MACnD,IAAIlB,GAAG,CAACkB,MAAM,EAAE;QACd,IAAIC,MAAM,GAAG,IAAI7B,WAAW,CAACS,SAAS,EAAED,KAAK,CAAC;QAC9CqB,MAAM,CAACC,SAAS,CAACH,IAAI,EAAGI,KAAK,IAAI;UAC/BH,MAAM,CAACI,IAAI,CAACD,KAAK,CAAC;QACpB,CAAC,CAAC;;MAEJ,OAAO;QAAEH,MAAM;QAAEK,GAAG,EAAEN;MAAI,CAAE;IAC9B,CAAC;IAED,OAAOhB,QAAQ;EACjB"},"metadata":{},"sourceType":"module","externalDependencies":[]}