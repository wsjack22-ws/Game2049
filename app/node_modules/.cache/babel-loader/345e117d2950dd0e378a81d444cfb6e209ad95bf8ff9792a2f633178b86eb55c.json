{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nvar errors_1 = require(\"@ledgerhq/errors\");\nvar Tag = 0x05;\nfunction asUInt16BE(value) {\n  var b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\nvar initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0\n};\n/**\n *\n */\nvar createHIDframing = function (channel, packetSize) {\n  return {\n    makeBlocks: function (apdu) {\n      var data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n      var blockSize = packetSize - 5;\n      var nbBlocks = Math.ceil(data.length / blockSize);\n      data = Buffer.concat([data, Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0)]);\n      var blocks = [];\n      for (var i = 0; i < nbBlocks; i++) {\n        var head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n        var chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n      return blocks;\n    },\n    reduceResponse: function (acc, chunk) {\n      var _a = acc || initialAcc,\n        data = _a.data,\n        dataLength = _a.dataLength,\n        sequence = _a.sequence;\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new errors_1.TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new errors_1.TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new errors_1.TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n      sequence++;\n      var chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n      return {\n        data: data,\n        dataLength: dataLength,\n        sequence: sequence\n      };\n    },\n    getReducedResult: function (acc) {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    }\n  };\n};\nexports[\"default\"] = createHIDframing;","map":{"version":3,"names":["errors_1","require","Tag","asUInt16BE","value","b","Buffer","alloc","writeUInt16BE","initialAcc","data","dataLength","sequence","createHIDframing","channel","packetSize","makeBlocks","apdu","concat","length","blockSize","nbBlocks","Math","ceil","fill","blocks","i","head","writeUInt8","chunk","slice","push","reduceResponse","acc","_a","readUInt16BE","TransportError","readUInt8","chunkData","getReducedResult","exports"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@ledgerhq/devices/src/hid-framing.ts"],"sourcesContent":["import { TransportError } from \"@ledgerhq/errors\";\nexport type ResponseAcc =\n  | {\n      data: Buffer;\n      dataLength: number;\n      sequence: number;\n    }\n  | null\n  | undefined;\nconst Tag = 0x05;\n\nfunction asUInt16BE(value) {\n  const b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\n\nconst initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0,\n};\n\n/**\n *\n */\nconst createHIDframing = (channel: number, packetSize: number) => {\n  return {\n    makeBlocks(apdu: Buffer): Buffer[] {\n      let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n      const blockSize = packetSize - 5;\n      const nbBlocks = Math.ceil(data.length / blockSize);\n      data = Buffer.concat([\n        data, // fill data with padding\n        Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0),\n      ]);\n      const blocks: Buffer[] = [];\n\n      for (let i = 0; i < nbBlocks; i++) {\n        const head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n        const chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n\n      return blocks;\n    },\n\n    reduceResponse(acc: ResponseAcc, chunk: Buffer): ResponseAcc {\n      let { data, dataLength, sequence } = acc || initialAcc;\n\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n\n      sequence++;\n      const chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n\n      return {\n        data,\n        dataLength,\n        sequence,\n      };\n    },\n\n    getReducedResult(acc: ResponseAcc): Buffer | null | undefined {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    },\n  };\n};\n\nexport default createHIDframing;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}