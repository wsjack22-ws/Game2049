{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _toConsumableArray = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _classCallCheck = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BorshInstructionCoder = exports.SIGHASH_GLOBAL_NAMESPACE = exports.SIGHASH_STATE_NAMESPACE = void 0;\nvar bs58_1 = __importDefault(require(\"bs58\"));\nvar buffer_1 = require(\"buffer\");\nvar camelcase_1 = __importDefault(require(\"camelcase\"));\nvar snake_case_1 = require(\"snake-case\");\nvar js_sha256_1 = require(\"js-sha256\");\nvar borsh = __importStar(require(\"@project-serum/borsh\"));\nvar idl_js_1 = require(\"./idl.js\");\n/**\n * Namespace for state method function signatures.\n */\nexports.SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\nexports.SIGHASH_GLOBAL_NAMESPACE = \"global\";\n/**\n * Encodes and decodes program instructions.\n */\nvar BorshInstructionCoder = /*#__PURE__*/function () {\n  function BorshInstructionCoder(idl) {\n    var _this = this;\n    _classCallCheck(this, BorshInstructionCoder);\n    this.idl = idl;\n    this.ixLayout = BorshInstructionCoder.parseIxLayout(idl);\n    var sighashLayouts = new Map();\n    idl.instructions.forEach(function (ix) {\n      var sh = sighash(exports.SIGHASH_GLOBAL_NAMESPACE, ix.name);\n      sighashLayouts.set(bs58_1.default.encode(sh), {\n        layout: _this.ixLayout.get(ix.name),\n        name: ix.name\n      });\n    });\n    if (idl.state) {\n      idl.state.methods.map(function (ix) {\n        var sh = sighash(exports.SIGHASH_STATE_NAMESPACE, ix.name);\n        sighashLayouts.set(bs58_1.default.encode(sh), {\n          layout: _this.ixLayout.get(ix.name),\n          name: ix.name\n        });\n      });\n    }\n    this.sighashLayouts = sighashLayouts;\n  }\n  /**\n   * Encodes a program instruction.\n   */\n  _createClass(BorshInstructionCoder, [{\n    key: \"encode\",\n    value: function encode(ixName, ix) {\n      return this._encode(exports.SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n    }\n    /**\n     * Encodes a program state instruction.\n     */\n  }, {\n    key: \"encodeState\",\n    value: function encodeState(ixName, ix) {\n      return this._encode(exports.SIGHASH_STATE_NAMESPACE, ixName, ix);\n    }\n  }, {\n    key: \"_encode\",\n    value: function _encode(nameSpace, ixName, ix) {\n      var buffer = buffer_1.Buffer.alloc(1000); // TODO: use a tighter buffer.\n      var methodName = (0, camelcase_1.default)(ixName);\n      var layout = this.ixLayout.get(methodName);\n      if (!layout) {\n        throw new Error(\"Unknown method: \".concat(methodName));\n      }\n      var len = layout.encode(ix, buffer);\n      var data = buffer.slice(0, len);\n      return buffer_1.Buffer.concat([sighash(nameSpace, ixName), data]);\n    }\n  }, {\n    key: \"decode\",\n    value:\n    /**\n     * Dewcodes a program instruction.\n     */\n    function decode(ix) {\n      var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"hex\";\n      if (typeof ix === \"string\") {\n        ix = encoding === \"hex\" ? buffer_1.Buffer.from(ix, \"hex\") : bs58_1.default.decode(ix);\n      }\n      var sighash = bs58_1.default.encode(ix.slice(0, 8));\n      var data = ix.slice(8);\n      var decoder = this.sighashLayouts.get(sighash);\n      if (!decoder) {\n        return null;\n      }\n      return {\n        data: decoder.layout.decode(data),\n        name: decoder.name\n      };\n    }\n    /**\n     * Returns a formatted table of all the fields in the given instruction data.\n     */\n  }, {\n    key: \"format\",\n    value: function format(ix, accountMetas) {\n      return InstructionFormatter.format(ix, accountMetas, this.idl);\n    }\n  }], [{\n    key: \"parseIxLayout\",\n    value: function parseIxLayout(idl) {\n      var stateMethods = idl.state ? idl.state.methods : [];\n      var ixLayouts = stateMethods.map(function (m) {\n        var fieldLayouts = m.args.map(function (arg) {\n          var _a, _b;\n          return idl_js_1.IdlCoder.fieldLayout(arg, Array.from([].concat(_toConsumableArray((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), _toConsumableArray((_b = idl.types) !== null && _b !== void 0 ? _b : []))));\n        });\n        var name = (0, camelcase_1.default)(m.name);\n        return [name, borsh.struct(fieldLayouts, name)];\n      }).concat(idl.instructions.map(function (ix) {\n        var fieldLayouts = ix.args.map(function (arg) {\n          var _a, _b;\n          return idl_js_1.IdlCoder.fieldLayout(arg, Array.from([].concat(_toConsumableArray((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), _toConsumableArray((_b = idl.types) !== null && _b !== void 0 ? _b : []))));\n        });\n        var name = (0, camelcase_1.default)(ix.name);\n        return [name, borsh.struct(fieldLayouts, name)];\n      }));\n      return new Map(ixLayouts);\n    }\n  }]);\n  return BorshInstructionCoder;\n}();\nexports.BorshInstructionCoder = BorshInstructionCoder;\nvar InstructionFormatter = /*#__PURE__*/function () {\n  function InstructionFormatter() {\n    _classCallCheck(this, InstructionFormatter);\n  }\n  _createClass(InstructionFormatter, null, [{\n    key: \"format\",\n    value: function format(ix, accountMetas, idl) {\n      var idlIx = idl.instructions.filter(function (i) {\n        return ix.name === i.name;\n      })[0];\n      if (idlIx === undefined) {\n        console.error(\"Invalid instruction given\");\n        return null;\n      }\n      var args = idlIx.args.map(function (idlField) {\n        return {\n          name: idlField.name,\n          type: InstructionFormatter.formatIdlType(idlField.type),\n          data: InstructionFormatter.formatIdlData(idlField, ix.data[idlField.name], idl.types)\n        };\n      });\n      var flatIdlAccounts = InstructionFormatter.flattenIdlAccounts(idlIx.accounts);\n      var accounts = accountMetas.map(function (meta, idx) {\n        if (idx < flatIdlAccounts.length) {\n          return _objectSpread({\n            name: flatIdlAccounts[idx].name\n          }, meta);\n        }\n        // \"Remaining accounts\" are unnamed in Anchor.\n        else {\n          return _objectSpread({\n            name: undefined\n          }, meta);\n        }\n      });\n      return {\n        args: args,\n        accounts: accounts\n      };\n    }\n  }, {\n    key: \"formatIdlType\",\n    value: function formatIdlType(idlType) {\n      if (typeof idlType === \"string\") {\n        return idlType;\n      }\n      if (\"vec\" in idlType) {\n        return \"Vec<\".concat(this.formatIdlType(idlType.vec), \">\");\n      }\n      if (\"option\" in idlType) {\n        return \"Option<\".concat(this.formatIdlType(idlType.option), \">\");\n      }\n      if (\"defined\" in idlType) {\n        return idlType.defined;\n      }\n      if (\"array\" in idlType) {\n        return \"Array<\".concat(idlType.array[0], \"; \").concat(idlType.array[1], \">\");\n      }\n      throw new Error(\"Unknown IDL type: \".concat(idlType));\n    }\n  }, {\n    key: \"formatIdlData\",\n    value: function formatIdlData(idlField, data, types) {\n      var _this2 = this;\n      if (typeof idlField.type === \"string\") {\n        return data.toString();\n      }\n      if (idlField.type.hasOwnProperty(\"vec\")) {\n        return \"[\" + data.map(function (d) {\n          return _this2.formatIdlData({\n            name: \"\",\n            type: idlField.type.vec\n          }, d);\n        }).join(\", \") + \"]\";\n      }\n      if (idlField.type.hasOwnProperty(\"option\")) {\n        return data === null ? \"null\" : this.formatIdlData({\n          name: \"\",\n          type: idlField.type.option\n        }, data, types);\n      }\n      if (idlField.type.hasOwnProperty(\"defined\")) {\n        if (types === undefined) {\n          throw new Error(\"User defined types not provided\");\n        }\n        var filtered = types.filter(function (t) {\n          return t.name === idlField.type.defined;\n        });\n        if (filtered.length !== 1) {\n          throw new Error(\"Type not found: \".concat(idlField.type.defined));\n        }\n        return InstructionFormatter.formatIdlDataDefined(filtered[0], data, types);\n      }\n      return \"unknown\";\n    }\n  }, {\n    key: \"formatIdlDataDefined\",\n    value: function formatIdlDataDefined(typeDef, data, types) {\n      if (typeDef.type.kind === \"struct\") {\n        var struct = typeDef.type;\n        var fields = Object.keys(data).map(function (k) {\n          var f = struct.fields.filter(function (f) {\n            return f.name === k;\n          })[0];\n          if (f === undefined) {\n            throw new Error(\"Unable to find type\");\n          }\n          return k + \": \" + InstructionFormatter.formatIdlData(f, data[k], types);\n        }).join(\", \");\n        return \"{ \" + fields + \" }\";\n      } else {\n        if (typeDef.type.variants.length === 0) {\n          return \"{}\";\n        }\n        // Struct enum.\n        if (typeDef.type.variants[0].name) {\n          var variants = typeDef.type.variants;\n          var variant = Object.keys(data)[0];\n          var enumType = data[variant];\n          var namedFields = Object.keys(enumType).map(function (f) {\n            var _a;\n            var fieldData = enumType[f];\n            var idlField = (_a = variants[variant]) === null || _a === void 0 ? void 0 : _a.filter(function (v) {\n              return v.name === f;\n            })[0];\n            if (idlField === undefined) {\n              throw new Error(\"Unable to find variant\");\n            }\n            return f + \": \" + InstructionFormatter.formatIdlData(idlField, fieldData, types);\n          }).join(\", \");\n          var variantName = (0, camelcase_1.default)(variant, {\n            pascalCase: true\n          });\n          if (namedFields.length === 0) {\n            return variantName;\n          }\n          return \"\".concat(variantName, \" { \").concat(namedFields, \" }\");\n        }\n        // Tuple enum.\n        else {\n          // TODO.\n          return \"Tuple formatting not yet implemented\";\n        }\n      }\n    }\n  }, {\n    key: \"flattenIdlAccounts\",\n    value: function flattenIdlAccounts(accounts, prefix) {\n      return accounts.map(function (account) {\n        var accName = sentenceCase(account.name);\n        if (account.hasOwnProperty(\"accounts\")) {\n          var newPrefix = prefix ? \"\".concat(prefix, \" > \").concat(accName) : accName;\n          return InstructionFormatter.flattenIdlAccounts(account.accounts, newPrefix);\n        } else {\n          return _objectSpread(_objectSpread({}, account), {}, {\n            name: prefix ? \"\".concat(prefix, \" > \").concat(accName) : accName\n          });\n        }\n      }).flat();\n    }\n  }]);\n  return InstructionFormatter;\n}();\nfunction sentenceCase(field) {\n  var result = field.replace(/([A-Z])/g, \" $1\");\n  return result.charAt(0).toUpperCase() + result.slice(1);\n}\n// Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\nfunction sighash(nameSpace, ixName) {\n  var name = (0, snake_case_1.snakeCase)(ixName);\n  var preimage = \"\".concat(nameSpace, \":\").concat(name);\n  return buffer_1.Buffer.from(js_sha256_1.sha256.digest(preimage)).slice(0, 8);\n}","map":{"version":3,"names":["bs58_1","__importDefault","require","buffer_1","camelcase_1","snake_case_1","js_sha256_1","borsh","__importStar","idl_js_1","exports","SIGHASH_STATE_NAMESPACE","SIGHASH_GLOBAL_NAMESPACE","BorshInstructionCoder","idl","_this","_classCallCheck","ixLayout","parseIxLayout","sighashLayouts","Map","instructions","forEach","ix","sh","sighash","name","set","default","encode","layout","get","state","methods","map","_createClass","key","value","ixName","_encode","encodeState","nameSpace","buffer","Buffer","alloc","methodName","Error","concat","len","data","slice","decode","encoding","arguments","length","undefined","from","decoder","format","accountMetas","InstructionFormatter","stateMethods","ixLayouts","m","fieldLayouts","args","arg","IdlCoder","fieldLayout","Array","_toConsumableArray","_a","accounts","_b","types","struct","idlIx","filter","i","console","error","idlField","type","formatIdlType","formatIdlData","flatIdlAccounts","flattenIdlAccounts","meta","idx","_objectSpread","idlType","vec","option","defined","array","_this2","toString","hasOwnProperty","d","join","filtered","t","formatIdlDataDefined","typeDef","kind","fields","Object","keys","k","f","variants","variant","enumType","namedFields","fieldData","v","variantName","pascalCase","prefix","account","accName","sentenceCase","newPrefix","flat","field","result","replace","charAt","toUpperCase","snakeCase","preimage","sha256","digest"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/coder/borsh/instruction.ts"],"sourcesContent":["import bs58 from \"bs58\";\nimport { Buffer } from \"buffer\";\nimport { Layout } from \"buffer-layout\";\nimport camelCase from \"camelcase\";\nimport { snakeCase } from \"snake-case\";\nimport { sha256 } from \"js-sha256\";\nimport * as borsh from \"@project-serum/borsh\";\nimport { AccountMeta, PublicKey } from \"@solana/web3.js\";\nimport {\n  Idl,\n  IdlField,\n  IdlStateMethod,\n  IdlType,\n  IdlTypeDef,\n  IdlAccount,\n  IdlAccountItem,\n  IdlTypeDefTyStruct,\n  IdlTypeVec,\n  IdlTypeOption,\n  IdlTypeDefined,\n  IdlAccounts,\n} from \"../../idl.js\";\nimport { IdlCoder } from \"./idl.js\";\nimport { InstructionCoder } from \"../index.js\";\n\n/**\n * Namespace for state method function signatures.\n */\nexport const SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\nexport const SIGHASH_GLOBAL_NAMESPACE = \"global\";\n\n/**\n * Encodes and decodes program instructions.\n */\nexport class BorshInstructionCoder implements InstructionCoder {\n  // Instruction args layout. Maps namespaced method\n  private ixLayout: Map<string, Layout>;\n\n  // Base58 encoded sighash to instruction layout.\n  private sighashLayouts: Map<string, { layout: Layout; name: string }>;\n\n  public constructor(private idl: Idl) {\n    this.ixLayout = BorshInstructionCoder.parseIxLayout(idl);\n\n    const sighashLayouts = new Map();\n    idl.instructions.forEach((ix) => {\n      const sh = sighash(SIGHASH_GLOBAL_NAMESPACE, ix.name);\n      sighashLayouts.set(bs58.encode(sh), {\n        layout: this.ixLayout.get(ix.name),\n        name: ix.name,\n      });\n    });\n\n    if (idl.state) {\n      idl.state.methods.map((ix) => {\n        const sh = sighash(SIGHASH_STATE_NAMESPACE, ix.name);\n        sighashLayouts.set(bs58.encode(sh), {\n          layout: this.ixLayout.get(ix.name) as Layout,\n          name: ix.name,\n        });\n      });\n    }\n\n    this.sighashLayouts = sighashLayouts;\n  }\n\n  /**\n   * Encodes a program instruction.\n   */\n  public encode(ixName: string, ix: any): Buffer {\n    return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n  }\n\n  /**\n   * Encodes a program state instruction.\n   */\n  public encodeState(ixName: string, ix: any): Buffer {\n    return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);\n  }\n\n  private _encode(nameSpace: string, ixName: string, ix: any): Buffer {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n    const methodName = camelCase(ixName);\n    const layout = this.ixLayout.get(methodName);\n    if (!layout) {\n      throw new Error(`Unknown method: ${methodName}`);\n    }\n    const len = layout.encode(ix, buffer);\n    const data = buffer.slice(0, len);\n    return Buffer.concat([sighash(nameSpace, ixName), data]);\n  }\n\n  private static parseIxLayout(idl: Idl): Map<string, Layout> {\n    const stateMethods = idl.state ? idl.state.methods : [];\n\n    const ixLayouts = stateMethods\n      .map((m: IdlStateMethod): [string, Layout<unknown>] => {\n        let fieldLayouts = m.args.map((arg: IdlField) => {\n          return IdlCoder.fieldLayout(\n            arg,\n            Array.from([...(idl.accounts ?? []), ...(idl.types ?? [])])\n          );\n        });\n        const name = camelCase(m.name);\n        return [name, borsh.struct(fieldLayouts, name)];\n      })\n      .concat(\n        idl.instructions.map((ix) => {\n          let fieldLayouts = ix.args.map((arg: IdlField) =>\n            IdlCoder.fieldLayout(\n              arg,\n              Array.from([...(idl.accounts ?? []), ...(idl.types ?? [])])\n            )\n          );\n          const name = camelCase(ix.name);\n          return [name, borsh.struct(fieldLayouts, name)];\n        })\n      );\n    return new Map(ixLayouts);\n  }\n\n  /**\n   * Dewcodes a program instruction.\n   */\n  public decode(\n    ix: Buffer | string,\n    encoding: \"hex\" | \"base58\" = \"hex\"\n  ): Instruction | null {\n    if (typeof ix === \"string\") {\n      ix = encoding === \"hex\" ? Buffer.from(ix, \"hex\") : bs58.decode(ix);\n    }\n    let sighash = bs58.encode(ix.slice(0, 8));\n    let data = ix.slice(8);\n    const decoder = this.sighashLayouts.get(sighash);\n    if (!decoder) {\n      return null;\n    }\n    return {\n      data: decoder.layout.decode(data),\n      name: decoder.name,\n    };\n  }\n\n  /**\n   * Returns a formatted table of all the fields in the given instruction data.\n   */\n  public format(\n    ix: Instruction,\n    accountMetas: AccountMeta[]\n  ): InstructionDisplay | null {\n    return InstructionFormatter.format(ix, accountMetas, this.idl);\n  }\n}\n\nexport type Instruction = {\n  name: string;\n  data: Object;\n};\n\nexport type InstructionDisplay = {\n  args: { name: string; type: string; data: string }[];\n  accounts: {\n    name?: string;\n    pubkey: PublicKey;\n    isSigner: boolean;\n    isWritable: boolean;\n  }[];\n};\n\nclass InstructionFormatter {\n  public static format(\n    ix: Instruction,\n    accountMetas: AccountMeta[],\n    idl: Idl\n  ): InstructionDisplay | null {\n    const idlIx = idl.instructions.filter((i) => ix.name === i.name)[0];\n    if (idlIx === undefined) {\n      console.error(\"Invalid instruction given\");\n      return null;\n    }\n\n    const args = idlIx.args.map((idlField) => {\n      return {\n        name: idlField.name,\n        type: InstructionFormatter.formatIdlType(idlField.type),\n        data: InstructionFormatter.formatIdlData(\n          idlField,\n          ix.data[idlField.name],\n          idl.types\n        ),\n      };\n    });\n\n    const flatIdlAccounts = InstructionFormatter.flattenIdlAccounts(\n      idlIx.accounts\n    );\n\n    const accounts = accountMetas.map((meta, idx) => {\n      if (idx < flatIdlAccounts.length) {\n        return {\n          name: flatIdlAccounts[idx].name,\n          ...meta,\n        };\n      }\n      // \"Remaining accounts\" are unnamed in Anchor.\n      else {\n        return {\n          name: undefined,\n          ...meta,\n        };\n      }\n    });\n\n    return {\n      args,\n      accounts,\n    };\n  }\n\n  private static formatIdlType(idlType: IdlType): string {\n    if (typeof idlType === \"string\") {\n      return idlType as string;\n    }\n\n    if (\"vec\" in idlType) {\n      return `Vec<${this.formatIdlType(idlType.vec)}>`;\n    }\n    if (\"option\" in idlType) {\n      return `Option<${this.formatIdlType(idlType.option)}>`;\n    }\n    if (\"defined\" in idlType) {\n      return idlType.defined;\n    }\n    if (\"array\" in idlType) {\n      return `Array<${idlType.array[0]}; ${idlType.array[1]}>`;\n    }\n\n    throw new Error(`Unknown IDL type: ${idlType}`);\n  }\n\n  private static formatIdlData(\n    idlField: IdlField,\n    data: Object,\n    types?: IdlTypeDef[]\n  ): string {\n    if (typeof idlField.type === \"string\") {\n      return data.toString();\n    }\n    if (idlField.type.hasOwnProperty(\"vec\")) {\n      return (\n        \"[\" +\n        (<Array<IdlField>>data)\n          .map((d: IdlField) =>\n            this.formatIdlData(\n              { name: \"\", type: (<IdlTypeVec>idlField.type).vec },\n              d\n            )\n          )\n          .join(\", \") +\n        \"]\"\n      );\n    }\n    if (idlField.type.hasOwnProperty(\"option\")) {\n      return data === null\n        ? \"null\"\n        : this.formatIdlData(\n            { name: \"\", type: (<IdlTypeOption>idlField.type).option },\n            data,\n            types\n          );\n    }\n    if (idlField.type.hasOwnProperty(\"defined\")) {\n      if (types === undefined) {\n        throw new Error(\"User defined types not provided\");\n      }\n      const filtered = types.filter(\n        (t) => t.name === (<IdlTypeDefined>idlField.type).defined\n      );\n      if (filtered.length !== 1) {\n        throw new Error(\n          `Type not found: ${(<IdlTypeDefined>idlField.type).defined}`\n        );\n      }\n      return InstructionFormatter.formatIdlDataDefined(\n        filtered[0],\n        data,\n        types\n      );\n    }\n\n    return \"unknown\";\n  }\n\n  private static formatIdlDataDefined(\n    typeDef: IdlTypeDef,\n    data: Object,\n    types: IdlTypeDef[]\n  ): string {\n    if (typeDef.type.kind === \"struct\") {\n      const struct: IdlTypeDefTyStruct = typeDef.type;\n      const fields = Object.keys(data)\n        .map((k) => {\n          const f = struct.fields.filter((f) => f.name === k)[0];\n          if (f === undefined) {\n            throw new Error(\"Unable to find type\");\n          }\n          return (\n            k + \": \" + InstructionFormatter.formatIdlData(f, data[k], types)\n          );\n        })\n        .join(\", \");\n      return \"{ \" + fields + \" }\";\n    } else {\n      if (typeDef.type.variants.length === 0) {\n        return \"{}\";\n      }\n      // Struct enum.\n      if (typeDef.type.variants[0].name) {\n        const variants = typeDef.type.variants;\n        const variant = Object.keys(data)[0];\n        const enumType = data[variant];\n        const namedFields = Object.keys(enumType)\n          .map((f) => {\n            const fieldData = enumType[f];\n            const idlField = variants[variant]?.filter(\n              (v: IdlField) => v.name === f\n            )[0];\n            if (idlField === undefined) {\n              throw new Error(\"Unable to find variant\");\n            }\n            return (\n              f +\n              \": \" +\n              InstructionFormatter.formatIdlData(idlField, fieldData, types)\n            );\n          })\n          .join(\", \");\n\n        const variantName = camelCase(variant, { pascalCase: true });\n        if (namedFields.length === 0) {\n          return variantName;\n        }\n        return `${variantName} { ${namedFields} }`;\n      }\n      // Tuple enum.\n      else {\n        // TODO.\n        return \"Tuple formatting not yet implemented\";\n      }\n    }\n  }\n\n  private static flattenIdlAccounts(\n    accounts: IdlAccountItem[],\n    prefix?: string\n  ): IdlAccount[] {\n    return accounts\n      .map((account) => {\n        const accName = sentenceCase(account.name);\n        if (account.hasOwnProperty(\"accounts\")) {\n          const newPrefix = prefix ? `${prefix} > ${accName}` : accName;\n          return InstructionFormatter.flattenIdlAccounts(\n            (<IdlAccounts>account).accounts,\n            newPrefix\n          );\n        } else {\n          return {\n            ...(<IdlAccount>account),\n            name: prefix ? `${prefix} > ${accName}` : accName,\n          };\n        }\n      })\n      .flat();\n  }\n}\n\nfunction sentenceCase(field: string): string {\n  const result = field.replace(/([A-Z])/g, \" $1\");\n  return result.charAt(0).toUpperCase() + result.slice(1);\n}\n\n// Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\nfunction sighash(nameSpace: string, ixName: string): Buffer {\n  let name = snakeCase(ixName);\n  let preimage = `${nameSpace}:${name}`;\n  return Buffer.from(sha256.digest(preimage)).slice(0, 8);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}