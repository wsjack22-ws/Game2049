{"ast":null,"code":"import camelCase from \"camelcase\";\nimport * as borsh from \"@project-serum/borsh\";\nimport { IdlError } from \"../error\";\nexport class IdlCoder {\n  static fieldLayout(field, types) {\n    const fieldName = field.name !== undefined ? camelCase(field.name) : undefined;\n    switch (field.type) {\n      case \"bool\":\n        {\n          return borsh.bool(fieldName);\n        }\n      case \"u8\":\n        {\n          return borsh.u8(fieldName);\n        }\n      case \"i8\":\n        {\n          return borsh.i8(fieldName);\n        }\n      case \"u16\":\n        {\n          return borsh.u16(fieldName);\n        }\n      case \"i16\":\n        {\n          return borsh.i16(fieldName);\n        }\n      case \"u32\":\n        {\n          return borsh.u32(fieldName);\n        }\n      case \"i32\":\n        {\n          return borsh.i32(fieldName);\n        }\n      case \"u64\":\n        {\n          return borsh.u64(fieldName);\n        }\n      case \"i64\":\n        {\n          return borsh.i64(fieldName);\n        }\n      case \"u128\":\n        {\n          return borsh.u128(fieldName);\n        }\n      case \"i128\":\n        {\n          return borsh.i128(fieldName);\n        }\n      case \"bytes\":\n        {\n          return borsh.vecU8(fieldName);\n        }\n      case \"string\":\n        {\n          return borsh.str(fieldName);\n        }\n      case \"publicKey\":\n        {\n          return borsh.publicKey(fieldName);\n        }\n      default:\n        {\n          if (\"vec\" in field.type) {\n            return borsh.vec(IdlCoder.fieldLayout({\n              name: undefined,\n              // @ts-ignore\n              type: field.type.vec\n            }, types), fieldName);\n          } else if (\"option\" in field.type) {\n            return borsh.option(IdlCoder.fieldLayout({\n              name: undefined,\n              type: field.type.option\n            }, types), fieldName);\n          } else if (\"defined\" in field.type) {\n            const defined = field.type.defined;\n            // User defined type.\n            if (types === undefined) {\n              throw new IdlError(\"User defined types not provided\");\n            }\n            const filtered = types.filter(t => t.name === defined);\n            if (filtered.length !== 1) {\n              throw new IdlError(`Type not found: ${JSON.stringify(field)}`);\n            }\n            return IdlCoder.typeDefLayout(filtered[0], types, fieldName);\n          } else if (\"array\" in field.type) {\n            let arrayTy = field.type.array[0];\n            let arrayLen = field.type.array[1];\n            let innerLayout = IdlCoder.fieldLayout({\n              name: undefined,\n              type: arrayTy\n            }, types);\n            return borsh.array(innerLayout, arrayLen, fieldName);\n          } else {\n            throw new Error(`Not yet implemented: ${field}`);\n          }\n        }\n    }\n  }\n  static typeDefLayout(typeDef, types = [], name) {\n    if (typeDef.type.kind === \"struct\") {\n      const fieldLayouts = typeDef.type.fields.map(field => {\n        const x = IdlCoder.fieldLayout(field, types);\n        return x;\n      });\n      return borsh.struct(fieldLayouts, name);\n    } else if (typeDef.type.kind === \"enum\") {\n      let variants = typeDef.type.variants.map(variant => {\n        const name = camelCase(variant.name);\n        if (variant.fields === undefined) {\n          return borsh.struct([], name);\n        }\n        // @ts-ignore\n        const fieldLayouts = variant.fields.map(f => {\n          // @ts-ignore\n          if (f.name === undefined) {\n            throw new Error(\"Tuple enum variants not yet implemented.\");\n          }\n          // @ts-ignore\n          return IdlCoder.fieldLayout(f, types);\n        });\n        return borsh.struct(fieldLayouts, name);\n      });\n      if (name !== undefined) {\n        // Buffer-layout lib requires the name to be null (on construction)\n        // when used as a field.\n        return borsh.rustEnum(variants).replicate(name);\n      }\n      return borsh.rustEnum(variants, name);\n    } else {\n      throw new Error(`Unknown type kint: ${typeDef}`);\n    }\n  }\n}","map":{"version":3,"names":["camelCase","borsh","IdlError","IdlCoder","fieldLayout","field","types","fieldName","name","undefined","type","bool","u8","i8","u16","i16","u32","i32","u64","i64","u128","i128","vecU8","str","publicKey","vec","option","defined","filtered","filter","t","length","JSON","stringify","typeDefLayout","arrayTy","array","arrayLen","innerLayout","Error","typeDef","kind","fieldLayouts","fields","map","x","struct","variants","variant","f","rustEnum","replicate"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/coder/idl.ts"],"sourcesContent":["import camelCase from \"camelcase\";\nimport { Layout } from \"buffer-layout\";\nimport * as borsh from \"@project-serum/borsh\";\nimport { IdlField, IdlTypeDef, IdlEnumVariant, IdlType } from \"../idl\";\nimport { IdlError } from \"../error\";\n\nexport class IdlCoder {\n  public static fieldLayout(\n    field: { name?: string } & Pick<IdlField, \"type\">,\n    types?: IdlTypeDef[]\n  ): Layout {\n    const fieldName =\n      field.name !== undefined ? camelCase(field.name) : undefined;\n    switch (field.type) {\n      case \"bool\": {\n        return borsh.bool(fieldName);\n      }\n      case \"u8\": {\n        return borsh.u8(fieldName);\n      }\n      case \"i8\": {\n        return borsh.i8(fieldName);\n      }\n      case \"u16\": {\n        return borsh.u16(fieldName);\n      }\n      case \"i16\": {\n        return borsh.i16(fieldName);\n      }\n      case \"u32\": {\n        return borsh.u32(fieldName);\n      }\n      case \"i32\": {\n        return borsh.i32(fieldName);\n      }\n      case \"u64\": {\n        return borsh.u64(fieldName);\n      }\n      case \"i64\": {\n        return borsh.i64(fieldName);\n      }\n      case \"u128\": {\n        return borsh.u128(fieldName);\n      }\n      case \"i128\": {\n        return borsh.i128(fieldName);\n      }\n      case \"bytes\": {\n        return borsh.vecU8(fieldName);\n      }\n      case \"string\": {\n        return borsh.str(fieldName);\n      }\n      case \"publicKey\": {\n        return borsh.publicKey(fieldName);\n      }\n      default: {\n        if (\"vec\" in field.type) {\n          return borsh.vec(\n            IdlCoder.fieldLayout(\n              {\n                name: undefined,\n                // @ts-ignore\n                type: field.type.vec,\n              },\n              types\n            ),\n            fieldName\n          );\n        } else if (\"option\" in field.type) {\n          return borsh.option(\n            IdlCoder.fieldLayout(\n              {\n                name: undefined,\n                type: field.type.option,\n              },\n              types\n            ),\n            fieldName\n          );\n        } else if (\"defined\" in field.type) {\n          const defined = field.type.defined;\n          // User defined type.\n          if (types === undefined) {\n            throw new IdlError(\"User defined types not provided\");\n          }\n          const filtered = types.filter((t) => t.name === defined);\n          if (filtered.length !== 1) {\n            throw new IdlError(`Type not found: ${JSON.stringify(field)}`);\n          }\n          return IdlCoder.typeDefLayout(filtered[0], types, fieldName);\n        } else if (\"array\" in field.type) {\n          let arrayTy = field.type.array[0];\n          let arrayLen = field.type.array[1];\n          let innerLayout = IdlCoder.fieldLayout(\n            {\n              name: undefined,\n              type: arrayTy,\n            },\n            types\n          );\n          return borsh.array(innerLayout, arrayLen, fieldName);\n        } else {\n          throw new Error(`Not yet implemented: ${field}`);\n        }\n      }\n    }\n  }\n\n  public static typeDefLayout(\n    typeDef: IdlTypeDef,\n    types: IdlTypeDef[] = [],\n    name?: string\n  ): Layout {\n    if (typeDef.type.kind === \"struct\") {\n      const fieldLayouts = typeDef.type.fields.map((field) => {\n        const x = IdlCoder.fieldLayout(field, types);\n        return x;\n      });\n      return borsh.struct(fieldLayouts, name);\n    } else if (typeDef.type.kind === \"enum\") {\n      let variants = typeDef.type.variants.map((variant: IdlEnumVariant) => {\n        const name = camelCase(variant.name);\n        if (variant.fields === undefined) {\n          return borsh.struct([], name);\n        }\n        // @ts-ignore\n        const fieldLayouts = variant.fields.map((f: IdlField | IdlType) => {\n          // @ts-ignore\n          if (f.name === undefined) {\n            throw new Error(\"Tuple enum variants not yet implemented.\");\n          }\n          // @ts-ignore\n          return IdlCoder.fieldLayout(f, types);\n        });\n        return borsh.struct(fieldLayouts, name);\n      });\n\n      if (name !== undefined) {\n        // Buffer-layout lib requires the name to be null (on construction)\n        // when used as a field.\n        return borsh.rustEnum(variants).replicate(name);\n      }\n\n      return borsh.rustEnum(variants, name);\n    } else {\n      throw new Error(`Unknown type kint: ${typeDef}`);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}