{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IdlCoder = void 0;\nvar camelcase_1 = __importDefault(require(\"camelcase\"));\nvar borsh = __importStar(require(\"@project-serum/borsh\"));\nvar error_js_1 = require(\"../../error.js\");\nvar IdlCoder = /*#__PURE__*/function () {\n  function IdlCoder() {\n    _classCallCheck(this, IdlCoder);\n  }\n  _createClass(IdlCoder, null, [{\n    key: \"fieldLayout\",\n    value: function fieldLayout(field, types) {\n      var fieldName = field.name !== undefined ? (0, camelcase_1.default)(field.name) : undefined;\n      switch (field.type) {\n        case \"bool\":\n          {\n            return borsh.bool(fieldName);\n          }\n        case \"u8\":\n          {\n            return borsh.u8(fieldName);\n          }\n        case \"i8\":\n          {\n            return borsh.i8(fieldName);\n          }\n        case \"u16\":\n          {\n            return borsh.u16(fieldName);\n          }\n        case \"i16\":\n          {\n            return borsh.i16(fieldName);\n          }\n        case \"u32\":\n          {\n            return borsh.u32(fieldName);\n          }\n        case \"i32\":\n          {\n            return borsh.i32(fieldName);\n          }\n        case \"f32\":\n          {\n            return borsh.f32(fieldName);\n          }\n        case \"u64\":\n          {\n            return borsh.u64(fieldName);\n          }\n        case \"i64\":\n          {\n            return borsh.i64(fieldName);\n          }\n        case \"f64\":\n          {\n            return borsh.f64(fieldName);\n          }\n        case \"u128\":\n          {\n            return borsh.u128(fieldName);\n          }\n        case \"i128\":\n          {\n            return borsh.i128(fieldName);\n          }\n        case \"bytes\":\n          {\n            return borsh.vecU8(fieldName);\n          }\n        case \"string\":\n          {\n            return borsh.str(fieldName);\n          }\n        case \"publicKey\":\n          {\n            return borsh.publicKey(fieldName);\n          }\n        default:\n          {\n            if (\"vec\" in field.type) {\n              return borsh.vec(IdlCoder.fieldLayout({\n                name: undefined,\n                type: field.type.vec\n              }, types), fieldName);\n            } else if (\"option\" in field.type) {\n              return borsh.option(IdlCoder.fieldLayout({\n                name: undefined,\n                type: field.type.option\n              }, types), fieldName);\n            } else if (\"defined\" in field.type) {\n              var defined = field.type.defined;\n              // User defined type.\n              if (types === undefined) {\n                throw new error_js_1.IdlError(\"User defined types not provided\");\n              }\n              var filtered = types.filter(function (t) {\n                return t.name === defined;\n              });\n              if (filtered.length !== 1) {\n                throw new error_js_1.IdlError(\"Type not found: \".concat(JSON.stringify(field)));\n              }\n              return IdlCoder.typeDefLayout(filtered[0], types, fieldName);\n            } else if (\"array\" in field.type) {\n              var arrayTy = field.type.array[0];\n              var arrayLen = field.type.array[1];\n              var innerLayout = IdlCoder.fieldLayout({\n                name: undefined,\n                type: arrayTy\n              }, types);\n              return borsh.array(innerLayout, arrayLen, fieldName);\n            } else {\n              throw new Error(\"Not yet implemented: \".concat(field));\n            }\n          }\n      }\n    }\n  }, {\n    key: \"typeDefLayout\",\n    value: function typeDefLayout(typeDef) {\n      var types = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var name = arguments.length > 2 ? arguments[2] : undefined;\n      if (typeDef.type.kind === \"struct\") {\n        var fieldLayouts = typeDef.type.fields.map(function (field) {\n          var x = IdlCoder.fieldLayout(field, types);\n          return x;\n        });\n        return borsh.struct(fieldLayouts, name);\n      } else if (typeDef.type.kind === \"enum\") {\n        var variants = typeDef.type.variants.map(function (variant) {\n          var name = (0, camelcase_1.default)(variant.name);\n          if (variant.fields === undefined) {\n            return borsh.struct([], name);\n          }\n          var fieldLayouts = variant.fields.map(function (f) {\n            if (!f.hasOwnProperty(\"name\")) {\n              throw new Error(\"Tuple enum variants not yet implemented.\");\n            }\n            // this typescript conversion is ok\n            // because if f were of type IdlType\n            // (that does not have a name property)\n            // the check before would've errored\n            return IdlCoder.fieldLayout(f, types);\n          });\n          return borsh.struct(fieldLayouts, name);\n        });\n        if (name !== undefined) {\n          // Buffer-layout lib requires the name to be null (on construction)\n          // when used as a field.\n          return borsh.rustEnum(variants).replicate(name);\n        }\n        return borsh.rustEnum(variants, name);\n      } else {\n        throw new Error(\"Unknown type kint: \".concat(typeDef));\n      }\n    }\n  }]);\n  return IdlCoder;\n}();\nexports.IdlCoder = IdlCoder;","map":{"version":3,"names":["camelcase_1","__importDefault","require","borsh","__importStar","error_js_1","IdlCoder","_classCallCheck","_createClass","key","value","fieldLayout","field","types","fieldName","name","undefined","default","type","bool","u8","i8","u16","i16","u32","i32","f32","u64","i64","f64","u128","i128","vecU8","str","publicKey","vec","option","defined","IdlError","filtered","filter","t","length","concat","JSON","stringify","typeDefLayout","arrayTy","array","arrayLen","innerLayout","Error","typeDef","arguments","kind","fieldLayouts","fields","map","x","struct","variants","variant","f","hasOwnProperty","rustEnum","replicate","exports"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/coder/borsh/idl.ts"],"sourcesContent":["import camelCase from \"camelcase\";\nimport { Layout } from \"buffer-layout\";\nimport * as borsh from \"@project-serum/borsh\";\nimport { IdlField, IdlTypeDef, IdlEnumVariant, IdlType } from \"../../idl.js\";\nimport { IdlError } from \"../../error.js\";\n\nexport class IdlCoder {\n  public static fieldLayout(\n    field: { name?: string } & Pick<IdlField, \"type\">,\n    types?: IdlTypeDef[]\n  ): Layout {\n    const fieldName =\n      field.name !== undefined ? camelCase(field.name) : undefined;\n    switch (field.type) {\n      case \"bool\": {\n        return borsh.bool(fieldName);\n      }\n      case \"u8\": {\n        return borsh.u8(fieldName);\n      }\n      case \"i8\": {\n        return borsh.i8(fieldName);\n      }\n      case \"u16\": {\n        return borsh.u16(fieldName);\n      }\n      case \"i16\": {\n        return borsh.i16(fieldName);\n      }\n      case \"u32\": {\n        return borsh.u32(fieldName);\n      }\n      case \"i32\": {\n        return borsh.i32(fieldName);\n      }\n      case \"f32\": {\n        return borsh.f32(fieldName);\n      }\n      case \"u64\": {\n        return borsh.u64(fieldName);\n      }\n      case \"i64\": {\n        return borsh.i64(fieldName);\n      }\n      case \"f64\": {\n        return borsh.f64(fieldName);\n      }\n      case \"u128\": {\n        return borsh.u128(fieldName);\n      }\n      case \"i128\": {\n        return borsh.i128(fieldName);\n      }\n      case \"bytes\": {\n        return borsh.vecU8(fieldName);\n      }\n      case \"string\": {\n        return borsh.str(fieldName);\n      }\n      case \"publicKey\": {\n        return borsh.publicKey(fieldName);\n      }\n      default: {\n        if (\"vec\" in field.type) {\n          return borsh.vec(\n            IdlCoder.fieldLayout(\n              {\n                name: undefined,\n                type: field.type.vec,\n              },\n              types\n            ),\n            fieldName\n          );\n        } else if (\"option\" in field.type) {\n          return borsh.option(\n            IdlCoder.fieldLayout(\n              {\n                name: undefined,\n                type: field.type.option,\n              },\n              types\n            ),\n            fieldName\n          );\n        } else if (\"defined\" in field.type) {\n          const defined = field.type.defined;\n          // User defined type.\n          if (types === undefined) {\n            throw new IdlError(\"User defined types not provided\");\n          }\n          const filtered = types.filter((t) => t.name === defined);\n          if (filtered.length !== 1) {\n            throw new IdlError(`Type not found: ${JSON.stringify(field)}`);\n          }\n          return IdlCoder.typeDefLayout(filtered[0], types, fieldName);\n        } else if (\"array\" in field.type) {\n          let arrayTy = field.type.array[0];\n          let arrayLen = field.type.array[1];\n          let innerLayout = IdlCoder.fieldLayout(\n            {\n              name: undefined,\n              type: arrayTy,\n            },\n            types\n          );\n          return borsh.array(innerLayout, arrayLen, fieldName);\n        } else {\n          throw new Error(`Not yet implemented: ${field}`);\n        }\n      }\n    }\n  }\n\n  public static typeDefLayout(\n    typeDef: IdlTypeDef,\n    types: IdlTypeDef[] = [],\n    name?: string\n  ): Layout {\n    if (typeDef.type.kind === \"struct\") {\n      const fieldLayouts = typeDef.type.fields.map((field) => {\n        const x = IdlCoder.fieldLayout(field, types);\n        return x;\n      });\n      return borsh.struct(fieldLayouts, name);\n    } else if (typeDef.type.kind === \"enum\") {\n      let variants = typeDef.type.variants.map((variant: IdlEnumVariant) => {\n        const name = camelCase(variant.name);\n        if (variant.fields === undefined) {\n          return borsh.struct([], name);\n        }\n        const fieldLayouts = variant.fields.map((f: IdlField | IdlType) => {\n          if (!f.hasOwnProperty(\"name\")) {\n            throw new Error(\"Tuple enum variants not yet implemented.\");\n          }\n          // this typescript conversion is ok\n          // because if f were of type IdlType\n          // (that does not have a name property)\n          // the check before would've errored\n          return IdlCoder.fieldLayout(f as IdlField, types);\n        });\n        return borsh.struct(fieldLayouts, name);\n      });\n\n      if (name !== undefined) {\n        // Buffer-layout lib requires the name to be null (on construction)\n        // when used as a field.\n        return borsh.rustEnum(variants).replicate(name);\n      }\n\n      return borsh.rustEnum(variants, name);\n    } else {\n      throw new Error(`Unknown type kint: ${typeDef}`);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}