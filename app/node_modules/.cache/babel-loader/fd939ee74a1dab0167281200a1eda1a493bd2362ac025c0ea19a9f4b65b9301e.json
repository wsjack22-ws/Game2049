{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BorshAccountsCoder = exports.ACCOUNT_DISCRIMINATOR_SIZE = void 0;\nconst bs58_1 = __importDefault(require(\"bs58\"));\nconst buffer_1 = require(\"buffer\");\nconst camelcase_1 = __importDefault(require(\"camelcase\"));\nconst js_sha256_1 = require(\"js-sha256\");\nconst idl_js_1 = require(\"./idl.js\");\nconst common_js_1 = require(\"../common.js\");\n/**\n * Number of bytes of the account discriminator.\n */\nexports.ACCOUNT_DISCRIMINATOR_SIZE = 8;\n/**\n * Encodes and decodes account objects.\n */\nclass BorshAccountsCoder {\n  constructor(idl) {\n    if (idl.accounts === undefined) {\n      this.accountLayouts = new Map();\n      return;\n    }\n    const layouts = idl.accounts.map(acc => {\n      return [acc.name, idl_js_1.IdlCoder.typeDefLayout(acc, idl.types)];\n    });\n    this.accountLayouts = new Map(layouts);\n    this.idl = idl;\n  }\n  async encode(accountName, account) {\n    const buffer = buffer_1.Buffer.alloc(1000); // TODO: use a tighter buffer.\n    const layout = this.accountLayouts.get(accountName);\n    if (!layout) {\n      throw new Error(`Unknown account: ${accountName}`);\n    }\n    const len = layout.encode(account, buffer);\n    let accountData = buffer.slice(0, len);\n    let discriminator = BorshAccountsCoder.accountDiscriminator(accountName);\n    return buffer_1.Buffer.concat([discriminator, accountData]);\n  }\n  decode(accountName, data) {\n    // Assert the account discriminator is correct.\n    const discriminator = BorshAccountsCoder.accountDiscriminator(accountName);\n    if (discriminator.compare(data.slice(0, 8))) {\n      throw new Error(\"Invalid account discriminator\");\n    }\n    return this.decodeUnchecked(accountName, data);\n  }\n  decodeUnchecked(accountName, ix) {\n    // Chop off the discriminator before decoding.\n    const data = ix.slice(exports.ACCOUNT_DISCRIMINATOR_SIZE);\n    const layout = this.accountLayouts.get(accountName);\n    if (!layout) {\n      throw new Error(`Unknown account: ${accountName}`);\n    }\n    return layout.decode(data);\n  }\n  memcmp(accountName, appendData) {\n    const discriminator = BorshAccountsCoder.accountDiscriminator(accountName);\n    return {\n      offset: 0,\n      bytes: bs58_1.default.encode(appendData ? buffer_1.Buffer.concat([discriminator, appendData]) : discriminator)\n    };\n  }\n  size(idlAccount) {\n    var _a;\n    return exports.ACCOUNT_DISCRIMINATOR_SIZE + ((_a = (0, common_js_1.accountSize)(this.idl, idlAccount)) !== null && _a !== void 0 ? _a : 0);\n  }\n  /**\n   * Calculates and returns a unique 8 byte discriminator prepended to all anchor accounts.\n   *\n   * @param name The name of the account to calculate the discriminator.\n   */\n  static accountDiscriminator(name) {\n    return buffer_1.Buffer.from(js_sha256_1.sha256.digest(`account:${(0, camelcase_1.default)(name, {\n      pascalCase: true\n    })}`)).slice(0, exports.ACCOUNT_DISCRIMINATOR_SIZE);\n  }\n}\nexports.BorshAccountsCoder = BorshAccountsCoder;","map":{"version":3,"names":["bs58_1","__importDefault","require","buffer_1","camelcase_1","js_sha256_1","idl_js_1","common_js_1","exports","ACCOUNT_DISCRIMINATOR_SIZE","BorshAccountsCoder","constructor","idl","accounts","undefined","accountLayouts","Map","layouts","map","acc","name","IdlCoder","typeDefLayout","types","encode","accountName","account","buffer","Buffer","alloc","layout","get","Error","len","accountData","slice","discriminator","accountDiscriminator","concat","decode","data","compare","decodeUnchecked","ix","memcmp","appendData","offset","bytes","default","size","idlAccount","_a","accountSize","from","sha256","digest","pascalCase"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/coder/borsh/accounts.ts"],"sourcesContent":["import bs58 from \"bs58\";\nimport { Buffer } from \"buffer\";\nimport { Layout } from \"buffer-layout\";\nimport camelcase from \"camelcase\";\nimport { sha256 } from \"js-sha256\";\nimport { Idl, IdlTypeDef } from \"../../idl.js\";\nimport { IdlCoder } from \"./idl.js\";\nimport { AccountsCoder } from \"../index.js\";\nimport { accountSize } from \"../common.js\";\n\n/**\n * Number of bytes of the account discriminator.\n */\nexport const ACCOUNT_DISCRIMINATOR_SIZE = 8;\n\n/**\n * Encodes and decodes account objects.\n */\nexport class BorshAccountsCoder<A extends string = string>\n  implements AccountsCoder\n{\n  /**\n   * Maps account type identifier to a layout.\n   */\n  private accountLayouts: Map<A, Layout>;\n\n  /**\n   * IDL whose acconts will be coded.\n   */\n  private idl: Idl;\n\n  public constructor(idl: Idl) {\n    if (idl.accounts === undefined) {\n      this.accountLayouts = new Map();\n      return;\n    }\n    const layouts: [A, Layout][] = idl.accounts.map((acc) => {\n      return [acc.name as A, IdlCoder.typeDefLayout(acc, idl.types)];\n    });\n\n    this.accountLayouts = new Map(layouts);\n    this.idl = idl;\n  }\n\n  public async encode<T = any>(accountName: A, account: T): Promise<Buffer> {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n    const layout = this.accountLayouts.get(accountName);\n    if (!layout) {\n      throw new Error(`Unknown account: ${accountName}`);\n    }\n    const len = layout.encode(account, buffer);\n    let accountData = buffer.slice(0, len);\n    let discriminator = BorshAccountsCoder.accountDiscriminator(accountName);\n    return Buffer.concat([discriminator, accountData]);\n  }\n\n  public decode<T = any>(accountName: A, data: Buffer): T {\n    // Assert the account discriminator is correct.\n    const discriminator = BorshAccountsCoder.accountDiscriminator(accountName);\n    if (discriminator.compare(data.slice(0, 8))) {\n      throw new Error(\"Invalid account discriminator\");\n    }\n    return this.decodeUnchecked(accountName, data);\n  }\n\n  public decodeUnchecked<T = any>(accountName: A, ix: Buffer): T {\n    // Chop off the discriminator before decoding.\n    const data = ix.slice(ACCOUNT_DISCRIMINATOR_SIZE);\n    const layout = this.accountLayouts.get(accountName);\n    if (!layout) {\n      throw new Error(`Unknown account: ${accountName}`);\n    }\n    return layout.decode(data);\n  }\n\n  public memcmp(accountName: A, appendData?: Buffer): any {\n    const discriminator = BorshAccountsCoder.accountDiscriminator(accountName);\n    return {\n      offset: 0,\n      bytes: bs58.encode(\n        appendData ? Buffer.concat([discriminator, appendData]) : discriminator\n      ),\n    };\n  }\n\n  public size(idlAccount: IdlTypeDef): number {\n    return (\n      ACCOUNT_DISCRIMINATOR_SIZE + (accountSize(this.idl, idlAccount) ?? 0)\n    );\n  }\n\n  /**\n   * Calculates and returns a unique 8 byte discriminator prepended to all anchor accounts.\n   *\n   * @param name The name of the account to calculate the discriminator.\n   */\n  public static accountDiscriminator(name: string): Buffer {\n    return Buffer.from(\n      sha256.digest(`account:${camelcase(name, { pascalCase: true })}`)\n    ).slice(0, ACCOUNT_DISCRIMINATOR_SIZE);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}