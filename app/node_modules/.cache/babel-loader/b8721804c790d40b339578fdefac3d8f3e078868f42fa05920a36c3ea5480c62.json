{"ast":null,"code":"import _classCallCheck from \"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _objectSpread from \"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y²\nimport { mod } from './modular.js';\nimport * as ut from './utils.js';\nimport { ensureBytes } from './utils.js';\nimport { wNAF, validateBasic } from './curve.js';\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nvar _0n = BigInt(0),\n  _1n = BigInt(1),\n  _2n = BigInt(2),\n  _8n = BigInt(8);\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nvar VERIFY_DEFAULT = {\n  zip215: true\n};\nfunction validateOpts(curve) {\n  var opts = validateBasic(curve);\n  ut.validateObject(curve, {\n    hash: 'function',\n    a: 'bigint',\n    d: 'bigint',\n    randomBytes: 'function'\n  }, {\n    adjustScalarBytes: 'function',\n    domain: 'function',\n    uvRatio: 'function',\n    mapToCurve: 'function'\n  });\n  // Set defaults\n  return Object.freeze(_objectSpread({}, opts));\n}\n// It is not generic twisted curve for now, but ed25519/ed448 generic implementation\nexport function twistedEdwards(curveDef) {\n  var CURVE = validateOpts(curveDef);\n  var Fp = CURVE.Fp,\n    CURVE_ORDER = CURVE.n,\n    prehash = CURVE.prehash,\n    cHash = CURVE.hash,\n    randomBytes = CURVE.randomBytes,\n    nByteLength = CURVE.nByteLength,\n    cofactor = CURVE.h;\n  var MASK = _2n << BigInt(nByteLength * 8) - _1n;\n  var modP = Fp.create; // Function overrides\n  // sqrt(u/v)\n  var uvRatio = CURVE.uvRatio || function (u, v) {\n    try {\n      return {\n        isValid: true,\n        value: Fp.sqrt(u * Fp.inv(v))\n      };\n    } catch (e) {\n      return {\n        isValid: false,\n        value: _0n\n      };\n    }\n  };\n  var adjustScalarBytes = CURVE.adjustScalarBytes || function (bytes) {\n    return bytes;\n  }; // NOOP\n  var domain = CURVE.domain || function (data, ctx, phflag) {\n    if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n    return data;\n  }; // NOOP\n  var inBig = function inBig(n) {\n    return typeof n === 'bigint' && _0n < n;\n  }; // n in [1..]\n  var inRange = function inRange(n, max) {\n    return inBig(n) && inBig(max) && n < max;\n  }; // n in [1..max-1]\n  var in0MaskRange = function in0MaskRange(n) {\n    return n === _0n || inRange(n, MASK);\n  }; // n in [0..MASK-1]\n  function assertInRange(n, max) {\n    // n in [1..max-1]\n    if (inRange(n, max)) return n;\n    throw new Error(\"Expected valid scalar < \".concat(max, \", got \").concat(typeof n, \" \").concat(n));\n  }\n  function assertGE0(n) {\n    // n in [0..CURVE_ORDER-1]\n    return n === _0n ? n : assertInRange(n, CURVE_ORDER); // GE = prime subgroup, not full group\n  }\n\n  var pointPrecomputes = new Map();\n  function isPoint(other) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Extended Point works in extended coordinates: (x, y, z, t) ∋ (x=x/z, y=y/z, t=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  var Point = /*#__PURE__*/function () {\n    function Point(ex, ey, ez, et) {\n      _classCallCheck(this, Point);\n      this.ex = ex;\n      this.ey = ey;\n      this.ez = ez;\n      this.et = et;\n      if (!in0MaskRange(ex)) throw new Error('x required');\n      if (!in0MaskRange(ey)) throw new Error('y required');\n      if (!in0MaskRange(ez)) throw new Error('z required');\n      if (!in0MaskRange(et)) throw new Error('t required');\n    }\n    _createClass(Point, [{\n      key: \"x\",\n      get: function get() {\n        return this.toAffine().x;\n      }\n    }, {\n      key: \"y\",\n      get: function get() {\n        return this.toAffine().y;\n      }\n    }, {\n      key: \"_setWindowSize\",\n      value:\n      // \"Private method\", don't use it directly\n      function _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n      }\n      // Not required for fromHex(), which always creates valid points.\n      // Could be useful for fromAffine().\n    }, {\n      key: \"assertValidity\",\n      value: function assertValidity() {\n        var a = CURVE.a,\n          d = CURVE.d;\n        if (this.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n        // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n        var X = this.ex,\n          Y = this.ey,\n          Z = this.ez,\n          T = this.et;\n        var X2 = modP(X * X); // X²\n        var Y2 = modP(Y * Y); // Y²\n        var Z2 = modP(Z * Z); // Z²\n        var Z4 = modP(Z2 * Z2); // Z⁴\n        var aX2 = modP(X2 * a); // aX²\n        var left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n        var right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n        if (left !== right) throw new Error('bad point: equation left != right (1)');\n        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n        var XY = modP(X * Y);\n        var ZT = modP(Z * T);\n        if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n      }\n      // Compare one point to another.\n    }, {\n      key: \"equals\",\n      value: function equals(other) {\n        isPoint(other);\n        var X1 = this.ex,\n          Y1 = this.ey,\n          Z1 = this.ez;\n        var X2 = other.ex,\n          Y2 = other.ey,\n          Z2 = other.ez;\n        var X1Z2 = modP(X1 * Z2);\n        var X2Z1 = modP(X2 * Z1);\n        var Y1Z2 = modP(Y1 * Z2);\n        var Y2Z1 = modP(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n      }\n    }, {\n      key: \"is0\",\n      value: function is0() {\n        return this.equals(Point.ZERO);\n      }\n    }, {\n      key: \"negate\",\n      value: function negate() {\n        // Flips point sign to a negative one (-x, y in affine coords)\n        return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n      }\n      // Fast algo for doubling Extended Point.\n      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n      // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    }, {\n      key: \"double\",\n      value: function double() {\n        var a = CURVE.a;\n        var X1 = this.ex,\n          Y1 = this.ey,\n          Z1 = this.ez;\n        var A = modP(X1 * X1); // A = X12\n        var B = modP(Y1 * Y1); // B = Y12\n        var C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n        var D = modP(a * A); // D = a*A\n        var x1y1 = X1 + Y1;\n        var E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n        var G = D + B; // G = D+B\n        var F = G - C; // F = G-C\n        var H = D - B; // H = D-B\n        var X3 = modP(E * F); // X3 = E*F\n        var Y3 = modP(G * H); // Y3 = G*H\n        var T3 = modP(E * H); // T3 = E*H\n        var Z3 = modP(F * G); // Z3 = F*G\n        return new Point(X3, Y3, Z3, T3);\n      }\n      // Fast algo for adding 2 Extended Points.\n      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n      // Cost: 9M + 1*a + 1*d + 7add.\n    }, {\n      key: \"add\",\n      value: function add(other) {\n        isPoint(other);\n        var a = CURVE.a,\n          d = CURVE.d;\n        var X1 = this.ex,\n          Y1 = this.ey,\n          Z1 = this.ez,\n          T1 = this.et;\n        var X2 = other.ex,\n          Y2 = other.ey,\n          Z2 = other.ez,\n          T2 = other.et;\n        // Faster algo for adding 2 Extended Points when curve's a=-1.\n        // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n        // Cost: 8M + 8add + 2*2.\n        // Note: It does not check whether the `other` point is valid.\n        if (a === BigInt(-1)) {\n          var _A = modP((Y1 - X1) * (Y2 + X2));\n          var _B = modP((Y1 + X1) * (Y2 - X2));\n          var _F = modP(_B - _A);\n          if (_F === _0n) return this.double(); // Same point. Tests say it doesn't affect timing\n          var _C = modP(Z1 * _2n * T2);\n          var _D = modP(T1 * _2n * Z2);\n          var _E = _D + _C;\n          var _G = _B + _A;\n          var _H = _D - _C;\n          var _X = modP(_E * _F);\n          var _Y = modP(_G * _H);\n          var _T = modP(_E * _H);\n          var _Z = modP(_F * _G);\n          return new Point(_X, _Y, _Z, _T);\n        }\n        var A = modP(X1 * X2); // A = X1*X2\n        var B = modP(Y1 * Y2); // B = Y1*Y2\n        var C = modP(T1 * d * T2); // C = T1*d*T2\n        var D = modP(Z1 * Z2); // D = Z1*Z2\n        var E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n        var F = D - C; // F = D-C\n        var G = D + C; // G = D+C\n        var H = modP(B - a * A); // H = B-a*A\n        var X3 = modP(E * F); // X3 = E*F\n        var Y3 = modP(G * H); // Y3 = G*H\n        var T3 = modP(E * H); // T3 = E*H\n        var Z3 = modP(F * G); // Z3 = F*G\n        return new Point(X3, Y3, Z3, T3);\n      }\n    }, {\n      key: \"subtract\",\n      value: function subtract(other) {\n        return this.add(other.negate());\n      }\n    }, {\n      key: \"wNAF\",\n      value: function wNAF(n) {\n        return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);\n      }\n      // Constant-time multiplication.\n    }, {\n      key: \"multiply\",\n      value: function multiply(scalar) {\n        var _this$wNAF = this.wNAF(assertInRange(scalar, CURVE_ORDER)),\n          p = _this$wNAF.p,\n          f = _this$wNAF.f;\n        return Point.normalizeZ([p, f])[0];\n      }\n      // Non-constant-time multiplication. Uses double-and-add algorithm.\n      // It's faster, but should only be used when you don't care about\n      // an exposed private key e.g. sig verification.\n      // Does NOT allow scalars higher than CURVE.n.\n    }, {\n      key: \"multiplyUnsafe\",\n      value: function multiplyUnsafe(scalar) {\n        var n = assertGE0(scalar); // 0 <= scalar < CURVE.n\n        if (n === _0n) return I;\n        if (this.equals(I) || n === _1n) return this;\n        if (this.equals(G)) return this.wNAF(n).p;\n        return wnaf.unsafeLadder(this, n);\n      }\n      // Checks if point is of small order.\n      // If you add something to small order point, you will have \"dirty\"\n      // point with torsion component.\n      // Multiplies point by cofactor and checks if the result is 0.\n    }, {\n      key: \"isSmallOrder\",\n      value: function isSmallOrder() {\n        return this.multiplyUnsafe(cofactor).is0();\n      }\n      // Multiplies point by curve order and checks if the result is 0.\n      // Returns `false` is the point is dirty.\n    }, {\n      key: \"isTorsionFree\",\n      value: function isTorsionFree() {\n        return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n      }\n      // Converts Extended point to default (x, y) coordinates.\n      // Can accept precomputed Z^-1 - for example, from invertBatch.\n    }, {\n      key: \"toAffine\",\n      value: function toAffine(iz) {\n        var x = this.ex,\n          y = this.ey,\n          z = this.ez;\n        var is0 = this.is0();\n        if (iz == null) iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n        var ax = modP(x * iz);\n        var ay = modP(y * iz);\n        var zz = modP(z * iz);\n        if (is0) return {\n          x: _0n,\n          y: _1n\n        };\n        if (zz !== _1n) throw new Error('invZ was invalid');\n        return {\n          x: ax,\n          y: ay\n        };\n      }\n    }, {\n      key: \"clearCofactor\",\n      value: function clearCofactor() {\n        var cofactor = CURVE.h;\n        if (cofactor === _1n) return this;\n        return this.multiplyUnsafe(cofactor);\n      }\n      // Converts hash string or Uint8Array to Point.\n      // Uses algo from RFC8032 5.1.3.\n    }, {\n      key: \"toRawBytes\",\n      value: function toRawBytes() {\n        var _this$toAffine = this.toAffine(),\n          x = _this$toAffine.x,\n          y = _this$toAffine.y;\n        var bytes = ut.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n        bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n        return bytes; // and use the last byte to encode sign of x\n      }\n    }, {\n      key: \"toHex\",\n      value: function toHex() {\n        return ut.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n      }\n    }], [{\n      key: \"fromAffine\",\n      value: function fromAffine(p) {\n        if (p instanceof Point) throw new Error('extended point not allowed');\n        var _ref = p || {},\n          x = _ref.x,\n          y = _ref.y;\n        if (!in0MaskRange(x) || !in0MaskRange(y)) throw new Error('invalid affine point');\n        return new Point(x, y, _1n, modP(x * y));\n      }\n    }, {\n      key: \"normalizeZ\",\n      value: function normalizeZ(points) {\n        var toInv = Fp.invertBatch(points.map(function (p) {\n          return p.ez;\n        }));\n        return points.map(function (p, i) {\n          return p.toAffine(toInv[i]);\n        }).map(Point.fromAffine);\n      }\n    }, {\n      key: \"fromHex\",\n      value: function fromHex(hex) {\n        var zip215 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var d = CURVE.d,\n          a = CURVE.a;\n        var len = Fp.BYTES;\n        hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n        var normed = hex.slice(); // copy again, we'll manipulate it\n        var lastByte = hex[len - 1]; // select last byte\n        normed[len - 1] = lastByte & ~0x80; // clear last bit\n        var y = ut.bytesToNumberLE(normed);\n        if (y === _0n) {\n          // y=0 is allowed\n        } else {\n          // RFC8032 prohibits >= p, but ZIP215 doesn't\n          if (zip215) assertInRange(y, MASK); // zip215=true [1..P-1] (2^255-19-1 for ed25519)\n          else assertInRange(y, Fp.ORDER); // zip215=false [1..MASK-1] (2^256-1 for ed25519)\n        }\n        // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n        // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n        var y2 = modP(y * y); // denominator is always non-0 mod p.\n        var u = modP(y2 - _1n); // u = y² - 1\n        var v = modP(d * y2 - a); // v = d y² + 1.\n        var _uvRatio = uvRatio(u, v),\n          isValid = _uvRatio.isValid,\n          x = _uvRatio.value; // √(u/v)\n        if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n        var isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n        var isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n        if (!zip215 && x === _0n && isLastByteOdd)\n          // if x=0 and x_0 = 1, fail\n          throw new Error('Point.fromHex: x=0 and x_0=1');\n        if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n        return Point.fromAffine({\n          x: x,\n          y: y\n        });\n      }\n    }, {\n      key: \"fromPrivateKey\",\n      value: function fromPrivateKey(privKey) {\n        return getExtendedPublicKey(privKey).point;\n      }\n    }]);\n    return Point;\n  }();\n  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n  Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n  var G = Point.BASE,\n    I = Point.ZERO;\n  var wnaf = wNAF(Point, nByteLength * 8);\n  function modN(a) {\n    return mod(a, CURVE_ORDER);\n  }\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash) {\n    return modN(ut.bytesToNumberLE(hash));\n  }\n  /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */\n  function getExtendedPublicKey(key) {\n    var len = nByteLength;\n    key = ensureBytes('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    var hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n    var head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    var prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    var scalar = modN_LE(head); // The actual private scalar\n    var point = G.multiply(scalar); // Point on Edwards curve aka public key\n    var pointBytes = point.toRawBytes(); // Uint8Array representation\n    return {\n      head: head,\n      prefix: prefix,\n      scalar: scalar,\n      point: point,\n      pointBytes: pointBytes\n    };\n  }\n  // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n  function getPublicKey(privKey) {\n    return getExtendedPublicKey(privKey).pointBytes;\n  }\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar() {\n    var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();\n    for (var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      msgs[_key - 1] = arguments[_key];\n    }\n    var msg = ut.concatBytes.apply(ut, msgs);\n    return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n  }\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg, privKey) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    var _getExtendedPublicKey = getExtendedPublicKey(privKey),\n      prefix = _getExtendedPublicKey.prefix,\n      scalar = _getExtendedPublicKey.scalar,\n      pointBytes = _getExtendedPublicKey.pointBytes;\n    var r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    var R = G.multiply(r).toRawBytes(); // R = rG\n    var k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    var s = modN(r + k * scalar); // S = (r + k * s) mod L\n    assertGE0(s); // 0 <= s < l\n    var res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));\n    return ensureBytes('result', res, nByteLength * 2); // 64-byte signature\n  }\n\n  var verifyOpts = VERIFY_DEFAULT;\n  function verify(sig, msg, publicKey) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : verifyOpts;\n    var context = options.context,\n      zip215 = options.zip215;\n    var len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n    sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n    var s = ut.bytesToNumberLE(sig.slice(len, 2 * len));\n    // zip215: true is good for consensus-critical apps and allows points < 2^256\n    // zip215: false follows RFC8032 / NIST186-5 and restricts points to CURVE.p\n    var A, R, SB;\n    try {\n      A = Point.fromHex(publicKey, zip215);\n      R = Point.fromHex(sig.slice(0, len), zip215);\n      SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false;\n    var k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n    var RkA = R.add(A.multiplyUnsafe(k));\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n  }\n  G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n  var utils = {\n    getExtendedPublicKey: getExtendedPublicKey,\n    // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n    randomPrivateKey: function randomPrivateKey() {\n      return randomBytes(Fp.BYTES);\n    },\n    /**\n     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n     * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n     * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n     * @param windowSize 2, 4, 8, 16\n     */\n    precompute: function precompute() {\n      var windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n      var point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3));\n      return point;\n    }\n  };\n  return {\n    CURVE: CURVE,\n    getPublicKey: getPublicKey,\n    sign: sign,\n    verify: verify,\n    ExtendedPoint: Point,\n    utils: utils\n  };\n}","map":{"version":3,"names":["mod","ut","ensureBytes","wNAF","validateBasic","_0n","BigInt","_1n","_2n","_8n","VERIFY_DEFAULT","zip215","validateOpts","curve","opts","validateObject","hash","a","d","randomBytes","adjustScalarBytes","domain","uvRatio","mapToCurve","Object","freeze","_objectSpread","twistedEdwards","curveDef","CURVE","Fp","CURVE_ORDER","n","prehash","cHash","nByteLength","cofactor","h","MASK","modP","create","u","v","isValid","value","sqrt","inv","e","bytes","data","ctx","phflag","length","Error","inBig","inRange","max","in0MaskRange","assertInRange","concat","assertGE0","pointPrecomputes","Map","isPoint","other","Point","ex","ey","ez","et","_classCallCheck","_createClass","key","get","toAffine","x","y","_setWindowSize","windowSize","_WINDOW_SIZE","delete","assertValidity","is0","X","Y","Z","T","X2","Y2","Z2","Z4","aX2","left","right","XY","ZT","equals","X1","Y1","Z1","X1Z2","X2Z1","Y1Z2","Y2Z1","ZERO","negate","double","A","B","C","D","x1y1","E","G","F","H","X3","Y3","T3","Z3","add","T1","T2","subtract","wnaf","wNAFCached","normalizeZ","multiply","scalar","_this$wNAF","p","f","multiplyUnsafe","I","unsafeLadder","isSmallOrder","isTorsionFree","iz","z","ax","ay","zz","clearCofactor","toRawBytes","_this$toAffine","numberToBytesLE","BYTES","toHex","bytesToHex","fromAffine","_ref","points","toInv","invertBatch","map","i","fromHex","hex","arguments","undefined","len","normed","slice","lastByte","bytesToNumberLE","ORDER","y2","_uvRatio","isXOdd","isLastByteOdd","fromPrivateKey","privKey","getExtendedPublicKey","point","BASE","Gx","Gy","modN","modN_LE","hashed","head","prefix","pointBytes","getPublicKey","hashDomainToScalar","context","Uint8Array","_len","msgs","Array","_key","msg","concatBytes","apply","sign","options","_getExtendedPublicKey","r","R","k","s","res","verifyOpts","verify","sig","publicKey","SB","error","RkA","utils","randomPrivateKey","precompute","ExtendedPoint"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@noble/curves/src/abstract/edwards.ts"],"sourcesContent":["/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y²\nimport { mod } from './modular.js';\nimport * as ut from './utils.js';\nimport { ensureBytes, FHash, Hex } from './utils.js';\nimport { Group, GroupConstructor, wNAF, BasicCurve, validateBasic, AffinePoint } from './curve.js';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n\n// Edwards curves must declare params a & d.\nexport type CurveType = BasicCurve<bigint> & {\n  a: bigint; // curve param a\n  d: bigint; // curve param d\n  hash: FHash; // Hashing\n  randomBytes: (bytesLength?: number) => Uint8Array; // CSPRNG\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array; // clears bits to get valid field elemtn\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array; // Used for hashing\n  uvRatio?: (u: bigint, v: bigint) => { isValid: boolean; value: bigint }; // Ratio √(u/v)\n  prehash?: FHash; // RFC 8032 pre-hashing of messages to sign() / verify()\n  mapToCurve?: (scalar: bigint[]) => AffinePoint<bigint>; // for hash-to-curve standard\n};\n\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\n\nfunction validateOpts(curve: CurveType) {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    curve,\n    {\n      hash: 'function',\n      a: 'bigint',\n      d: 'bigint',\n      randomBytes: 'function',\n    },\n    {\n      adjustScalarBytes: 'function',\n      domain: 'function',\n      uvRatio: 'function',\n      mapToCurve: 'function',\n    }\n  );\n  // Set defaults\n  return Object.freeze({ ...opts } as const);\n}\n\n// Instance of Extended Point with coordinates in X, Y, Z, T\nexport interface ExtPointType extends Group<ExtPointType> {\n  readonly ex: bigint;\n  readonly ey: bigint;\n  readonly ez: bigint;\n  readonly et: bigint;\n  get x(): bigint;\n  get y(): bigint;\n  assertValidity(): void;\n  multiply(scalar: bigint): ExtPointType;\n  multiplyUnsafe(scalar: bigint): ExtPointType;\n  isSmallOrder(): boolean;\n  isTorsionFree(): boolean;\n  clearCofactor(): ExtPointType;\n  toAffine(iz?: bigint): AffinePoint<bigint>;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n}\n// Static methods of Extended Point with coordinates in X, Y, Z, T\nexport interface ExtPointConstructor extends GroupConstructor<ExtPointType> {\n  new (x: bigint, y: bigint, z: bigint, t: bigint): ExtPointType;\n  fromAffine(p: AffinePoint<bigint>): ExtPointType;\n  fromHex(hex: Hex): ExtPointType;\n  fromPrivateKey(privateKey: Hex): ExtPointType;\n}\n\nexport type CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  sign: (message: Hex, privateKey: Hex, options?: { context?: Hex }) => Uint8Array;\n  verify: (\n    sig: Hex,\n    message: Hex,\n    publicKey: Hex,\n    options?: { context?: Hex; zip215: boolean }\n  ) => boolean;\n  ExtendedPoint: ExtPointConstructor;\n  utils: {\n    randomPrivateKey: () => Uint8Array;\n    getExtendedPublicKey: (key: Hex) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: ExtPointType;\n      pointBytes: Uint8Array;\n    };\n  };\n};\n\n// It is not generic twisted curve for now, but ed25519/ed448 generic implementation\nexport function twistedEdwards(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\n  const {\n    Fp,\n    n: CURVE_ORDER,\n    prehash: prehash,\n    hash: cHash,\n    randomBytes,\n    nByteLength,\n    h: cofactor,\n  } = CURVE;\n  const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n  const modP = Fp.create; // Function overrides\n\n  // sqrt(u/v)\n  const uvRatio =\n    CURVE.uvRatio ||\n    ((u: bigint, v: bigint) => {\n      try {\n        return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n      } catch (e) {\n        return { isValid: false, value: _0n };\n      }\n    });\n  const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes: Uint8Array) => bytes); // NOOP\n  const domain =\n    CURVE.domain ||\n    ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => {\n      if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n      return data;\n    }); // NOOP\n  const inBig = (n: bigint) => typeof n === 'bigint' && _0n < n; // n in [1..]\n  const inRange = (n: bigint, max: bigint) => inBig(n) && inBig(max) && n < max; // n in [1..max-1]\n  const in0MaskRange = (n: bigint) => n === _0n || inRange(n, MASK); // n in [0..MASK-1]\n  function assertInRange(n: bigint, max: bigint) {\n    // n in [1..max-1]\n    if (inRange(n, max)) return n;\n    throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);\n  }\n  function assertGE0(n: bigint) {\n    // n in [0..CURVE_ORDER-1]\n    return n === _0n ? n : assertInRange(n, CURVE_ORDER); // GE = prime subgroup, not full group\n  }\n  const pointPrecomputes = new Map<Point, Point[]>();\n  function isPoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Extended Point works in extended coordinates: (x, y, z, t) ∋ (x=x/z, y=y/z, t=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point implements ExtPointType {\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    static readonly ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n\n    constructor(\n      readonly ex: bigint,\n      readonly ey: bigint,\n      readonly ez: bigint,\n      readonly et: bigint\n    ) {\n      if (!in0MaskRange(ex)) throw new Error('x required');\n      if (!in0MaskRange(ey)) throw new Error('y required');\n      if (!in0MaskRange(ez)) throw new Error('z required');\n      if (!in0MaskRange(et)) throw new Error('t required');\n    }\n\n    get x(): bigint {\n      return this.toAffine().x;\n    }\n    get y(): bigint {\n      return this.toAffine().y;\n    }\n\n    static fromAffine(p: AffinePoint<bigint>): Point {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const { x, y } = p || {};\n      if (!in0MaskRange(x) || !in0MaskRange(y)) throw new Error('invalid affine point');\n      return new Point(x, y, _1n, modP(x * y));\n    }\n    static normalizeZ(points: Point[]): Point[] {\n      const toInv = Fp.invertBatch(points.map((p) => p.ez));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    _WINDOW_SIZE?: number;\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      this._WINDOW_SIZE = windowSize;\n      pointPrecomputes.delete(this);\n    }\n    // Not required for fromHex(), which always creates valid points.\n    // Could be useful for fromAffine().\n    assertValidity(): void {\n      const { a, d } = CURVE;\n      if (this.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n      // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n      // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n      const { ex: X, ey: Y, ez: Z, et: T } = this;\n      const X2 = modP(X * X); // X²\n      const Y2 = modP(Y * Y); // Y²\n      const Z2 = modP(Z * Z); // Z²\n      const Z4 = modP(Z2 * Z2); // Z⁴\n      const aX2 = modP(X2 * a); // aX²\n      const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n      const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n      if (left !== right) throw new Error('bad point: equation left != right (1)');\n      // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n      const XY = modP(X * Y);\n      const ZT = modP(Z * T);\n      if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    }\n\n    // Compare one point to another.\n    equals(other: Point): boolean {\n      isPoint(other);\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2 } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n\n    protected is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    negate(): Point {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n    }\n\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double(): Point {\n      const { a } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other: Point) {\n      isPoint(other);\n      const { a, d } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n      // Faster algo for adding 2 Extended Points when curve's a=-1.\n      // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n      // Cost: 8M + 8add + 2*2.\n      // Note: It does not check whether the `other` point is valid.\n      if (a === BigInt(-1)) {\n        const A = modP((Y1 - X1) * (Y2 + X2));\n        const B = modP((Y1 + X1) * (Y2 - X2));\n        const F = modP(B - A);\n        if (F === _0n) return this.double(); // Same point. Tests say it doesn't affect timing\n        const C = modP(Z1 * _2n * T2);\n        const D = modP(T1 * _2n * Z2);\n        const E = D + C;\n        const G = B + A;\n        const H = D - C;\n        const X3 = modP(E * F);\n        const Y3 = modP(G * H);\n        const T3 = modP(E * H);\n        const Z3 = modP(F * G);\n        return new Point(X3, Y3, Z3, T3);\n      }\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    subtract(other: Point): Point {\n      return this.add(other.negate());\n    }\n\n    private wNAF(n: bigint): { p: Point; f: Point } {\n      return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);\n    }\n\n    // Constant-time multiplication.\n    multiply(scalar: bigint): Point {\n      const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));\n      return Point.normalizeZ([p, f])[0];\n    }\n\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    multiplyUnsafe(scalar: bigint): Point {\n      let n = assertGE0(scalar); // 0 <= scalar < CURVE.n\n      if (n === _0n) return I;\n      if (this.equals(I) || n === _1n) return this;\n      if (this.equals(G)) return this.wNAF(n).p;\n      return wnaf.unsafeLadder(this, n);\n    }\n\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder(): boolean {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree(): boolean {\n      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n    }\n\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(iz?: bigint): AffinePoint<bigint> {\n      const { ex: x, ey: y, ez: z } = this;\n      const is0 = this.is0();\n      if (iz == null) iz = is0 ? _8n : (Fp.inv(z) as bigint); // 8 was chosen arbitrarily\n      const ax = modP(x * iz);\n      const ay = modP(y * iz);\n      const zz = modP(z * iz);\n      if (is0) return { x: _0n, y: _1n };\n      if (zz !== _1n) throw new Error('invZ was invalid');\n      return { x: ax, y: ay };\n    }\n\n    clearCofactor(): Point {\n      const { h: cofactor } = CURVE;\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    // Converts hash string or Uint8Array to Point.\n    // Uses algo from RFC8032 5.1.3.\n    static fromHex(hex: Hex, zip215 = false): Point {\n      const { d, a } = CURVE;\n      const len = Fp.BYTES;\n      hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n      const normed = hex.slice(); // copy again, we'll manipulate it\n      const lastByte = hex[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = ut.bytesToNumberLE(normed);\n      if (y === _0n) {\n        // y=0 is allowed\n      } else {\n        // RFC8032 prohibits >= p, but ZIP215 doesn't\n        if (zip215) assertInRange(y, MASK); // zip215=true [1..P-1] (2^255-19-1 for ed25519)\n        else assertInRange(y, Fp.ORDER); // zip215=false [1..MASK-1] (2^256-1 for ed25519)\n      }\n\n      // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n      // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y² - 1\n      const v = modP(d * y2 - a); // v = d y² + 1.\n      let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n      if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('Point.fromHex: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({ x, y });\n    }\n    static fromPrivateKey(privKey: Hex) {\n      return getExtendedPublicKey(privKey).point;\n    }\n    toRawBytes(): Uint8Array {\n      const { x, y } = this.toAffine();\n      const bytes = ut.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n      return bytes; // and use the last byte to encode sign of x\n    }\n    toHex(): string {\n      return ut.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n    }\n  }\n  const { BASE: G, ZERO: I } = Point;\n  const wnaf = wNAF(Point, nByteLength * 8);\n\n  function modN(a: bigint) {\n    return mod(a, CURVE_ORDER);\n  }\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash: Uint8Array): bigint {\n    return modN(ut.bytesToNumberLE(hash));\n  }\n\n  /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */\n  function getExtendedPublicKey(key: Hex) {\n    const len = nByteLength;\n    key = ensureBytes('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    const point = G.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toRawBytes(); // Uint8Array representation\n    return { head, prefix, scalar, point, pointBytes };\n  }\n\n  // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n  function getPublicKey(privKey: Hex): Uint8Array {\n    return getExtendedPublicKey(privKey).pointBytes;\n  }\n\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context: Hex = new Uint8Array(), ...msgs: Uint8Array[]) {\n    const msg = ut.concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n  }\n\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg: Hex, privKey: Hex, options: { context?: Hex } = {}): Uint8Array {\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = G.multiply(r).toRawBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = modN(r + k * scalar); // S = (r + k * s) mod L\n    assertGE0(s); // 0 <= s < l\n    const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));\n    return ensureBytes('result', res, nByteLength * 2); // 64-byte signature\n  }\n\n  const verifyOpts: { context?: Hex; zip215?: boolean } = VERIFY_DEFAULT;\n  function verify(sig: Hex, msg: Hex, publicKey: Hex, options = verifyOpts): boolean {\n    const { context, zip215 } = options;\n    const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n    sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n\n    const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));\n    // zip215: true is good for consensus-critical apps and allows points < 2^256\n    // zip215: false follows RFC8032 / NIST186-5 and restricts points to CURVE.p\n    let A, R, SB;\n    try {\n      A = Point.fromHex(publicKey, zip215);\n      R = Point.fromHex(sig.slice(0, len), zip215);\n      SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false;\n\n    const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n  }\n\n  G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n\n  const utils = {\n    getExtendedPublicKey,\n    // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n    randomPrivateKey: (): Uint8Array => randomBytes(Fp.BYTES),\n\n    /**\n     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n     * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n     * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n     * @param windowSize 2, 4, 8, 16\n     */\n    precompute(windowSize = 8, point = Point.BASE): typeof Point.BASE {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3));\n      return point;\n    },\n  };\n\n  return {\n    CURVE,\n    getPublicKey,\n    sign,\n    verify,\n    ExtendedPoint: Point,\n    utils,\n  };\n}\n"],"mappings":";;;AAAA;AACA;AACA,SAASA,GAAG,QAAQ,cAAc;AAClC,OAAO,KAAKC,EAAE,MAAM,YAAY;AAChC,SAASC,WAAW,QAAoB,YAAY;AACpD,SAAkCC,IAAI,EAAcC,aAAa,QAAqB,YAAY;AAElG;AACA;AACA,IAAMC,GAAG,GAAGC,MAAM,CAAC,CAAC,CAAC;EAAEC,GAAG,GAAGD,MAAM,CAAC,CAAC,CAAC;EAAEE,GAAG,GAAGF,MAAM,CAAC,CAAC,CAAC;EAAEG,GAAG,GAAGH,MAAM,CAAC,CAAC,CAAC;AAexE;AACA,IAAMI,cAAc,GAAG;EAAEC,MAAM,EAAE;AAAI,CAAE;AAEvC,SAASC,YAAYA,CAACC,KAAgB;EACpC,IAAMC,IAAI,GAAGV,aAAa,CAACS,KAAK,CAAC;EACjCZ,EAAE,CAACc,cAAc,CACfF,KAAK,EACL;IACEG,IAAI,EAAE,UAAU;IAChBC,CAAC,EAAE,QAAQ;IACXC,CAAC,EAAE,QAAQ;IACXC,WAAW,EAAE;GACd,EACD;IACEC,iBAAiB,EAAE,UAAU;IAC7BC,MAAM,EAAE,UAAU;IAClBC,OAAO,EAAE,UAAU;IACnBC,UAAU,EAAE;GACb,CACF;EACD;EACA,OAAOC,MAAM,CAACC,MAAM,CAAAC,aAAA,KAAMZ,IAAI,CAAW,CAAC;AAC5C;AAmDA;AACA,OAAM,SAAUa,cAAcA,CAACC,QAAmB;EAChD,IAAMC,KAAK,GAAGjB,YAAY,CAACgB,QAAQ,CAAoC;EACvE,IACEE,EAAE,GAOAD,KAAK,CAPPC,EAAE;IACCC,WAAW,GAMZF,KAAK,CANPG,CAAC;IACQC,OAAO,GAKdJ,KAAK,CALPI,OAAO;IACDC,KAAK,GAITL,KAAK,CAJPb,IAAI;IACJG,WAAW,GAGTU,KAAK,CAHPV,WAAW;IACXgB,WAAW,GAETN,KAAK,CAFPM,WAAW;IACRC,QAAQ,GACTP,KAAK,CADPQ,CAAC;EAEH,IAAMC,IAAI,GAAG9B,GAAG,IAAKF,MAAM,CAAC6B,WAAW,GAAG,CAAC,CAAC,GAAG5B,GAAI;EACnD,IAAMgC,IAAI,GAAGT,EAAE,CAACU,MAAM,CAAC,CAAC;EAExB;EACA,IAAMlB,OAAO,GACXO,KAAK,CAACP,OAAO,IACZ,UAACmB,CAAS,EAAEC,CAAS,EAAI;IACxB,IAAI;MACF,OAAO;QAAEC,OAAO,EAAE,IAAI;QAAEC,KAAK,EAAEd,EAAE,CAACe,IAAI,CAACJ,CAAC,GAAGX,EAAE,CAACgB,GAAG,CAACJ,CAAC,CAAC;MAAC,CAAE;KACxD,CAAC,OAAOK,CAAC,EAAE;MACV,OAAO;QAAEJ,OAAO,EAAE,KAAK;QAAEC,KAAK,EAAEvC;MAAG,CAAE;;EAEzC,CAAE;EACJ,IAAMe,iBAAiB,GAAGS,KAAK,CAACT,iBAAiB,IAAK,UAAC4B,KAAiB;IAAA,OAAKA,KAAK;EAAA,CAAC,CAAC,CAAC;EACrF,IAAM3B,MAAM,GACVQ,KAAK,CAACR,MAAM,IACX,UAAC4B,IAAgB,EAAEC,GAAe,EAAEC,MAAe,EAAI;IACtD,IAAID,GAAG,CAACE,MAAM,IAAID,MAAM,EAAE,MAAM,IAAIE,KAAK,CAAC,qCAAqC,CAAC;IAChF,OAAOJ,IAAI;EACb,CAAE,CAAC,CAAC;EACN,IAAMK,KAAK,GAAG,SAARA,KAAKA,CAAItB,CAAS;IAAA,OAAK,OAAOA,CAAC,KAAK,QAAQ,IAAI3B,GAAG,GAAG2B,CAAC;EAAA,EAAC,CAAC;EAC/D,IAAMuB,OAAO,GAAG,SAAVA,OAAOA,CAAIvB,CAAS,EAAEwB,GAAW;IAAA,OAAKF,KAAK,CAACtB,CAAC,CAAC,IAAIsB,KAAK,CAACE,GAAG,CAAC,IAAIxB,CAAC,GAAGwB,GAAG;EAAA,EAAC,CAAC;EAC/E,IAAMC,YAAY,GAAG,SAAfA,YAAYA,CAAIzB,CAAS;IAAA,OAAKA,CAAC,KAAK3B,GAAG,IAAIkD,OAAO,CAACvB,CAAC,EAAEM,IAAI,CAAC;EAAA,EAAC,CAAC;EACnE,SAASoB,aAAaA,CAAC1B,CAAS,EAAEwB,GAAW;IAC3C;IACA,IAAID,OAAO,CAACvB,CAAC,EAAEwB,GAAG,CAAC,EAAE,OAAOxB,CAAC;IAC7B,MAAM,IAAIqB,KAAK,4BAAAM,MAAA,CAA4BH,GAAG,YAAAG,MAAA,CAAS,OAAO3B,CAAC,OAAA2B,MAAA,CAAI3B,CAAC,CAAE,CAAC;EACzE;EACA,SAAS4B,SAASA,CAAC5B,CAAS;IAC1B;IACA,OAAOA,CAAC,KAAK3B,GAAG,GAAG2B,CAAC,GAAG0B,aAAa,CAAC1B,CAAC,EAAED,WAAW,CAAC,CAAC,CAAC;EACxD;;EACA,IAAM8B,gBAAgB,GAAG,IAAIC,GAAG,EAAkB;EAClD,SAASC,OAAOA,CAACC,KAAc;IAC7B,IAAI,EAAEA,KAAK,YAAYC,KAAK,CAAC,EAAE,MAAM,IAAIZ,KAAK,CAAC,wBAAwB,CAAC;EAC1E;EACA;EACA;EAAA,IACMY,KAAK;IAIT,SAAAA,MACWC,EAAU,EACVC,EAAU,EACVC,EAAU,EACVC,EAAU;MAAAC,eAAA,OAAAL,KAAA;MAHV,KAAAC,EAAE,GAAFA,EAAE;MACF,KAAAC,EAAE,GAAFA,EAAE;MACF,KAAAC,EAAE,GAAFA,EAAE;MACF,KAAAC,EAAE,GAAFA,EAAE;MAEX,IAAI,CAACZ,YAAY,CAACS,EAAE,CAAC,EAAE,MAAM,IAAIb,KAAK,CAAC,YAAY,CAAC;MACpD,IAAI,CAACI,YAAY,CAACU,EAAE,CAAC,EAAE,MAAM,IAAId,KAAK,CAAC,YAAY,CAAC;MACpD,IAAI,CAACI,YAAY,CAACW,EAAE,CAAC,EAAE,MAAM,IAAIf,KAAK,CAAC,YAAY,CAAC;MACpD,IAAI,CAACI,YAAY,CAACY,EAAE,CAAC,EAAE,MAAM,IAAIhB,KAAK,CAAC,YAAY,CAAC;IACtD;IAACkB,YAAA,CAAAN,KAAA;MAAAO,GAAA;MAAAC,GAAA,EAED,SAAAA,IAAA,EAAK;QACH,OAAO,IAAI,CAACC,QAAQ,EAAE,CAACC,CAAC;MAC1B;IAAC;MAAAH,GAAA;MAAAC,GAAA,EACD,SAAAA,IAAA,EAAK;QACH,OAAO,IAAI,CAACC,QAAQ,EAAE,CAACE,CAAC;MAC1B;IAAC;MAAAJ,GAAA;MAAA5B,KAAA;MAkBD;MACA,SAAAiC,eAAeC,UAAkB;QAC/B,IAAI,CAACC,YAAY,GAAGD,UAAU;QAC9BjB,gBAAgB,CAACmB,MAAM,CAAC,IAAI,CAAC;MAC/B;MACA;MACA;IAAA;MAAAR,GAAA;MAAA5B,KAAA,EACA,SAAAqC,eAAA,EAAc;QACZ,IAAQhE,CAAC,GAAQY,KAAK,CAAdZ,CAAC;UAAEC,CAAC,GAAKW,KAAK,CAAXX,CAAC;QACZ,IAAI,IAAI,CAACgE,GAAG,EAAE,EAAE,MAAM,IAAI7B,KAAK,CAAC,iBAAiB,CAAC,CAAC,CAAC;QACpD;QACA;QACA,IAAY8B,CAAC,GAA0B,IAAI,CAAnCjB,EAAE;UAASkB,CAAC,GAAmB,IAAI,CAA5BjB,EAAE;UAASkB,CAAC,GAAY,IAAI,CAArBjB,EAAE;UAASkB,CAAC,GAAK,IAAI,CAAdjB,EAAE;QAC/B,IAAMkB,EAAE,GAAGhD,IAAI,CAAC4C,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC;QACxB,IAAMK,EAAE,GAAGjD,IAAI,CAAC6C,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC;QACxB,IAAMK,EAAE,GAAGlD,IAAI,CAAC8C,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC;QACxB,IAAMK,EAAE,GAAGnD,IAAI,CAACkD,EAAE,GAAGA,EAAE,CAAC,CAAC,CAAC;QAC1B,IAAME,GAAG,GAAGpD,IAAI,CAACgD,EAAE,GAAGtE,CAAC,CAAC,CAAC,CAAC;QAC1B,IAAM2E,IAAI,GAAGrD,IAAI,CAACkD,EAAE,GAAGlD,IAAI,CAACoD,GAAG,GAAGH,EAAE,CAAC,CAAC,CAAC,CAAC;QACxC,IAAMK,KAAK,GAAGtD,IAAI,CAACmD,EAAE,GAAGnD,IAAI,CAACrB,CAAC,GAAGqB,IAAI,CAACgD,EAAE,GAAGC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QAClD,IAAII,IAAI,KAAKC,KAAK,EAAE,MAAM,IAAIxC,KAAK,CAAC,uCAAuC,CAAC;QAC5E;QACA,IAAMyC,EAAE,GAAGvD,IAAI,CAAC4C,CAAC,GAAGC,CAAC,CAAC;QACtB,IAAMW,EAAE,GAAGxD,IAAI,CAAC8C,CAAC,GAAGC,CAAC,CAAC;QACtB,IAAIQ,EAAE,KAAKC,EAAE,EAAE,MAAM,IAAI1C,KAAK,CAAC,uCAAuC,CAAC;MACzE;MAEA;IAAA;MAAAmB,GAAA;MAAA5B,KAAA,EACA,SAAAoD,OAAOhC,KAAY;QACjBD,OAAO,CAACC,KAAK,CAAC;QACd,IAAYiC,EAAE,GAAqB,IAAI,CAA/B/B,EAAE;UAAUgC,EAAE,GAAa,IAAI,CAAvB/B,EAAE;UAAUgC,EAAE,GAAK,IAAI,CAAf/B,EAAE;QAC1B,IAAYmB,EAAE,GAAqBvB,KAAK,CAAhCE,EAAE;UAAUsB,EAAE,GAAaxB,KAAK,CAAxBG,EAAE;UAAUsB,EAAE,GAAKzB,KAAK,CAAhBI,EAAE;QAC1B,IAAMgC,IAAI,GAAG7D,IAAI,CAAC0D,EAAE,GAAGR,EAAE,CAAC;QAC1B,IAAMY,IAAI,GAAG9D,IAAI,CAACgD,EAAE,GAAGY,EAAE,CAAC;QAC1B,IAAMG,IAAI,GAAG/D,IAAI,CAAC2D,EAAE,GAAGT,EAAE,CAAC;QAC1B,IAAMc,IAAI,GAAGhE,IAAI,CAACiD,EAAE,GAAGW,EAAE,CAAC;QAC1B,OAAOC,IAAI,KAAKC,IAAI,IAAIC,IAAI,KAAKC,IAAI;MACvC;IAAC;MAAA/B,GAAA;MAAA5B,KAAA,EAES,SAAAsC,IAAA,EAAG;QACX,OAAO,IAAI,CAACc,MAAM,CAAC/B,KAAK,CAACuC,IAAI,CAAC;MAChC;IAAC;MAAAhC,GAAA;MAAA5B,KAAA,EAED,SAAA6D,OAAA,EAAM;QACJ;QACA,OAAO,IAAIxC,KAAK,CAAC1B,IAAI,CAAC,CAAC,IAAI,CAAC2B,EAAE,CAAC,EAAE,IAAI,CAACC,EAAE,EAAE,IAAI,CAACC,EAAE,EAAE7B,IAAI,CAAC,CAAC,IAAI,CAAC8B,EAAE,CAAC,CAAC;MACpE;MAEA;MACA;MACA;IAAA;MAAAG,GAAA;MAAA5B,KAAA,EACA,SAAA8D,OAAA,EAAM;QACJ,IAAQzF,CAAC,GAAKY,KAAK,CAAXZ,CAAC;QACT,IAAYgF,EAAE,GAAqB,IAAI,CAA/B/B,EAAE;UAAUgC,EAAE,GAAa,IAAI,CAAvB/B,EAAE;UAAUgC,EAAE,GAAK,IAAI,CAAf/B,EAAE;QAC1B,IAAMuC,CAAC,GAAGpE,IAAI,CAAC0D,EAAE,GAAGA,EAAE,CAAC,CAAC,CAAC;QACzB,IAAMW,CAAC,GAAGrE,IAAI,CAAC2D,EAAE,GAAGA,EAAE,CAAC,CAAC,CAAC;QACzB,IAAMW,CAAC,GAAGtE,IAAI,CAAC/B,GAAG,GAAG+B,IAAI,CAAC4D,EAAE,GAAGA,EAAE,CAAC,CAAC,CAAC,CAAC;QACrC,IAAMW,CAAC,GAAGvE,IAAI,CAACtB,CAAC,GAAG0F,CAAC,CAAC,CAAC,CAAC;QACvB,IAAMI,IAAI,GAAGd,EAAE,GAAGC,EAAE;QACpB,IAAMc,CAAC,GAAGzE,IAAI,CAACA,IAAI,CAACwE,IAAI,GAAGA,IAAI,CAAC,GAAGJ,CAAC,GAAGC,CAAC,CAAC,CAAC,CAAC;QAC3C,IAAMK,CAAC,GAAGH,CAAC,GAAGF,CAAC,CAAC,CAAC;QACjB,IAAMM,CAAC,GAAGD,CAAC,GAAGJ,CAAC,CAAC,CAAC;QACjB,IAAMM,CAAC,GAAGL,CAAC,GAAGF,CAAC,CAAC,CAAC;QACjB,IAAMQ,EAAE,GAAG7E,IAAI,CAACyE,CAAC,GAAGE,CAAC,CAAC,CAAC,CAAC;QACxB,IAAMG,EAAE,GAAG9E,IAAI,CAAC0E,CAAC,GAAGE,CAAC,CAAC,CAAC,CAAC;QACxB,IAAMG,EAAE,GAAG/E,IAAI,CAACyE,CAAC,GAAGG,CAAC,CAAC,CAAC,CAAC;QACxB,IAAMI,EAAE,GAAGhF,IAAI,CAAC2E,CAAC,GAAGD,CAAC,CAAC,CAAC,CAAC;QACxB,OAAO,IAAIhD,KAAK,CAACmD,EAAE,EAAEC,EAAE,EAAEE,EAAE,EAAED,EAAE,CAAC;MAClC;MAEA;MACA;MACA;IAAA;MAAA9C,GAAA;MAAA5B,KAAA,EACA,SAAA4E,IAAIxD,KAAY;QACdD,OAAO,CAACC,KAAK,CAAC;QACd,IAAQ/C,CAAC,GAAQY,KAAK,CAAdZ,CAAC;UAAEC,CAAC,GAAKW,KAAK,CAAXX,CAAC;QACZ,IAAY+E,EAAE,GAA6B,IAAI,CAAvC/B,EAAE;UAAUgC,EAAE,GAAqB,IAAI,CAA/B/B,EAAE;UAAUgC,EAAE,GAAa,IAAI,CAAvB/B,EAAE;UAAUqD,EAAE,GAAK,IAAI,CAAfpD,EAAE;QAClC,IAAYkB,EAAE,GAA6BvB,KAAK,CAAxCE,EAAE;UAAUsB,EAAE,GAAqBxB,KAAK,CAAhCG,EAAE;UAAUsB,EAAE,GAAazB,KAAK,CAAxBI,EAAE;UAAUsD,EAAE,GAAK1D,KAAK,CAAhBK,EAAE;QAClC;QACA;QACA;QACA;QACA,IAAIpD,CAAC,KAAKX,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;UACpB,IAAMqG,EAAC,GAAGpE,IAAI,CAAC,CAAC2D,EAAE,GAAGD,EAAE,KAAKT,EAAE,GAAGD,EAAE,CAAC,CAAC;UACrC,IAAMqB,EAAC,GAAGrE,IAAI,CAAC,CAAC2D,EAAE,GAAGD,EAAE,KAAKT,EAAE,GAAGD,EAAE,CAAC,CAAC;UACrC,IAAM2B,EAAC,GAAG3E,IAAI,CAACqE,EAAC,GAAGD,EAAC,CAAC;UACrB,IAAIO,EAAC,KAAK7G,GAAG,EAAE,OAAO,IAAI,CAACqG,MAAM,EAAE,CAAC,CAAC;UACrC,IAAMG,EAAC,GAAGtE,IAAI,CAAC4D,EAAE,GAAG3F,GAAG,GAAGkH,EAAE,CAAC;UAC7B,IAAMZ,EAAC,GAAGvE,IAAI,CAACkF,EAAE,GAAGjH,GAAG,GAAGiF,EAAE,CAAC;UAC7B,IAAMuB,EAAC,GAAGF,EAAC,GAAGD,EAAC;UACf,IAAMI,EAAC,GAAGL,EAAC,GAAGD,EAAC;UACf,IAAMQ,EAAC,GAAGL,EAAC,GAAGD,EAAC;UACf,IAAMO,EAAE,GAAG7E,IAAI,CAACyE,EAAC,GAAGE,EAAC,CAAC;UACtB,IAAMG,EAAE,GAAG9E,IAAI,CAAC0E,EAAC,GAAGE,EAAC,CAAC;UACtB,IAAMG,EAAE,GAAG/E,IAAI,CAACyE,EAAC,GAAGG,EAAC,CAAC;UACtB,IAAMI,EAAE,GAAGhF,IAAI,CAAC2E,EAAC,GAAGD,EAAC,CAAC;UACtB,OAAO,IAAIhD,KAAK,CAACmD,EAAE,EAAEC,EAAE,EAAEE,EAAE,EAAED,EAAE,CAAC;;QAElC,IAAMX,CAAC,GAAGpE,IAAI,CAAC0D,EAAE,GAAGV,EAAE,CAAC,CAAC,CAAC;QACzB,IAAMqB,CAAC,GAAGrE,IAAI,CAAC2D,EAAE,GAAGV,EAAE,CAAC,CAAC,CAAC;QACzB,IAAMqB,CAAC,GAAGtE,IAAI,CAACkF,EAAE,GAAGvG,CAAC,GAAGwG,EAAE,CAAC,CAAC,CAAC;QAC7B,IAAMZ,CAAC,GAAGvE,IAAI,CAAC4D,EAAE,GAAGV,EAAE,CAAC,CAAC,CAAC;QACzB,IAAMuB,CAAC,GAAGzE,IAAI,CAAC,CAAC0D,EAAE,GAAGC,EAAE,KAAKX,EAAE,GAAGC,EAAE,CAAC,GAAGmB,CAAC,GAAGC,CAAC,CAAC,CAAC,CAAC;QAC/C,IAAMM,CAAC,GAAGJ,CAAC,GAAGD,CAAC,CAAC,CAAC;QACjB,IAAMI,CAAC,GAAGH,CAAC,GAAGD,CAAC,CAAC,CAAC;QACjB,IAAMM,CAAC,GAAG5E,IAAI,CAACqE,CAAC,GAAG3F,CAAC,GAAG0F,CAAC,CAAC,CAAC,CAAC;QAC3B,IAAMS,EAAE,GAAG7E,IAAI,CAACyE,CAAC,GAAGE,CAAC,CAAC,CAAC,CAAC;QACxB,IAAMG,EAAE,GAAG9E,IAAI,CAAC0E,CAAC,GAAGE,CAAC,CAAC,CAAC,CAAC;QACxB,IAAMG,EAAE,GAAG/E,IAAI,CAACyE,CAAC,GAAGG,CAAC,CAAC,CAAC,CAAC;QACxB,IAAMI,EAAE,GAAGhF,IAAI,CAAC2E,CAAC,GAAGD,CAAC,CAAC,CAAC,CAAC;QAExB,OAAO,IAAIhD,KAAK,CAACmD,EAAE,EAAEC,EAAE,EAAEE,EAAE,EAAED,EAAE,CAAC;MAClC;IAAC;MAAA9C,GAAA;MAAA5B,KAAA,EAED,SAAA+E,SAAS3D,KAAY;QACnB,OAAO,IAAI,CAACwD,GAAG,CAACxD,KAAK,CAACyC,MAAM,EAAE,CAAC;MACjC;IAAC;MAAAjC,GAAA;MAAA5B,KAAA,EAEO,SAAAzC,KAAK6B,CAAS;QACpB,OAAO4F,IAAI,CAACC,UAAU,CAAC,IAAI,EAAEhE,gBAAgB,EAAE7B,CAAC,EAAEiC,KAAK,CAAC6D,UAAU,CAAC;MACrE;MAEA;IAAA;MAAAtD,GAAA;MAAA5B,KAAA,EACA,SAAAmF,SAASC,MAAc;QACrB,IAAAC,UAAA,GAAiB,IAAI,CAAC9H,IAAI,CAACuD,aAAa,CAACsE,MAAM,EAAEjG,WAAW,CAAC,CAAC;UAAtDmG,CAAC,GAAAD,UAAA,CAADC,CAAC;UAAEC,CAAC,GAAAF,UAAA,CAADE,CAAC;QACZ,OAAOlE,KAAK,CAAC6D,UAAU,CAAC,CAACI,CAAC,EAAEC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MACpC;MAEA;MACA;MACA;MACA;IAAA;MAAA3D,GAAA;MAAA5B,KAAA,EACA,SAAAwF,eAAeJ,MAAc;QAC3B,IAAIhG,CAAC,GAAG4B,SAAS,CAACoE,MAAM,CAAC,CAAC,CAAC;QAC3B,IAAIhG,CAAC,KAAK3B,GAAG,EAAE,OAAOgI,CAAC;QACvB,IAAI,IAAI,CAACrC,MAAM,CAACqC,CAAC,CAAC,IAAIrG,CAAC,KAAKzB,GAAG,EAAE,OAAO,IAAI;QAC5C,IAAI,IAAI,CAACyF,MAAM,CAACiB,CAAC,CAAC,EAAE,OAAO,IAAI,CAAC9G,IAAI,CAAC6B,CAAC,CAAC,CAACkG,CAAC;QACzC,OAAON,IAAI,CAACU,YAAY,CAAC,IAAI,EAAEtG,CAAC,CAAC;MACnC;MAEA;MACA;MACA;MACA;IAAA;MAAAwC,GAAA;MAAA5B,KAAA,EACA,SAAA2F,aAAA,EAAY;QACV,OAAO,IAAI,CAACH,cAAc,CAAChG,QAAQ,CAAC,CAAC8C,GAAG,EAAE;MAC5C;MAEA;MACA;IAAA;MAAAV,GAAA;MAAA5B,KAAA,EACA,SAAA4F,cAAA,EAAa;QACX,OAAOZ,IAAI,CAACU,YAAY,CAAC,IAAI,EAAEvG,WAAW,CAAC,CAACmD,GAAG,EAAE;MACnD;MAEA;MACA;IAAA;MAAAV,GAAA;MAAA5B,KAAA,EACA,SAAA8B,SAAS+D,EAAW;QAClB,IAAY9D,CAAC,GAAmB,IAAI,CAA5BT,EAAE;UAASU,CAAC,GAAY,IAAI,CAArBT,EAAE;UAASuE,CAAC,GAAK,IAAI,CAAdtE,EAAE;QACxB,IAAMc,GAAG,GAAG,IAAI,CAACA,GAAG,EAAE;QACtB,IAAIuD,EAAE,IAAI,IAAI,EAAEA,EAAE,GAAGvD,GAAG,GAAGzE,GAAG,GAAIqB,EAAE,CAACgB,GAAG,CAAC4F,CAAC,CAAY,CAAC,CAAC;QACxD,IAAMC,EAAE,GAAGpG,IAAI,CAACoC,CAAC,GAAG8D,EAAE,CAAC;QACvB,IAAMG,EAAE,GAAGrG,IAAI,CAACqC,CAAC,GAAG6D,EAAE,CAAC;QACvB,IAAMI,EAAE,GAAGtG,IAAI,CAACmG,CAAC,GAAGD,EAAE,CAAC;QACvB,IAAIvD,GAAG,EAAE,OAAO;UAAEP,CAAC,EAAEtE,GAAG;UAAEuE,CAAC,EAAErE;QAAG,CAAE;QAClC,IAAIsI,EAAE,KAAKtI,GAAG,EAAE,MAAM,IAAI8C,KAAK,CAAC,kBAAkB,CAAC;QACnD,OAAO;UAAEsB,CAAC,EAAEgE,EAAE;UAAE/D,CAAC,EAAEgE;QAAE,CAAE;MACzB;IAAC;MAAApE,GAAA;MAAA5B,KAAA,EAED,SAAAkG,cAAA,EAAa;QACX,IAAW1G,QAAQ,GAAKP,KAAK,CAArBQ,CAAC;QACT,IAAID,QAAQ,KAAK7B,GAAG,EAAE,OAAO,IAAI;QACjC,OAAO,IAAI,CAAC6H,cAAc,CAAChG,QAAQ,CAAC;MACtC;MAEA;MACA;IAAA;MAAAoC,GAAA;MAAA5B,KAAA,EAmCA,SAAAmG,WAAA,EAAU;QACR,IAAAC,cAAA,GAAiB,IAAI,CAACtE,QAAQ,EAAE;UAAxBC,CAAC,GAAAqE,cAAA,CAADrE,CAAC;UAAEC,CAAC,GAAAoE,cAAA,CAADpE,CAAC;QACZ,IAAM5B,KAAK,GAAG/C,EAAE,CAACgJ,eAAe,CAACrE,CAAC,EAAE9C,EAAE,CAACoH,KAAK,CAAC,CAAC,CAAC;QAC/ClG,KAAK,CAACA,KAAK,CAACI,MAAM,GAAG,CAAC,CAAC,IAAIuB,CAAC,GAAGpE,GAAG,GAAG,IAAI,GAAG,CAAC,CAAC,CAAC;QAC/C,OAAOyC,KAAK,CAAC,CAAC;MAChB;IAAC;MAAAwB,GAAA;MAAA5B,KAAA,EACD,SAAAuG,MAAA,EAAK;QACH,OAAOlJ,EAAE,CAACmJ,UAAU,CAAC,IAAI,CAACL,UAAU,EAAE,CAAC,CAAC,CAAC;MAC3C;IAAC;MAAAvE,GAAA;MAAA5B,KAAA,EA1OD,SAAAyG,WAAkBnB,CAAsB;QACtC,IAAIA,CAAC,YAAYjE,KAAK,EAAE,MAAM,IAAIZ,KAAK,CAAC,4BAA4B,CAAC;QACrE,IAAAiG,IAAA,GAAiBpB,CAAC,IAAI,EAAE;UAAhBvD,CAAC,GAAA2E,IAAA,CAAD3E,CAAC;UAAEC,CAAC,GAAA0E,IAAA,CAAD1E,CAAC;QACZ,IAAI,CAACnB,YAAY,CAACkB,CAAC,CAAC,IAAI,CAAClB,YAAY,CAACmB,CAAC,CAAC,EAAE,MAAM,IAAIvB,KAAK,CAAC,sBAAsB,CAAC;QACjF,OAAO,IAAIY,KAAK,CAACU,CAAC,EAAEC,CAAC,EAAErE,GAAG,EAAEgC,IAAI,CAACoC,CAAC,GAAGC,CAAC,CAAC,CAAC;MAC1C;IAAC;MAAAJ,GAAA;MAAA5B,KAAA,EACD,SAAAkF,WAAkByB,MAAe;QAC/B,IAAMC,KAAK,GAAG1H,EAAE,CAAC2H,WAAW,CAACF,MAAM,CAACG,GAAG,CAAC,UAACxB,CAAC;UAAA,OAAKA,CAAC,CAAC9D,EAAE;QAAA,EAAC,CAAC;QACrD,OAAOmF,MAAM,CAACG,GAAG,CAAC,UAACxB,CAAC,EAAEyB,CAAC;UAAA,OAAKzB,CAAC,CAACxD,QAAQ,CAAC8E,KAAK,CAACG,CAAC,CAAC,CAAC;QAAA,EAAC,CAACD,GAAG,CAACzF,KAAK,CAACoF,UAAU,CAAC;MACzE;IAAC;MAAA7E,GAAA;MAAA5B,KAAA,EAuLD,SAAAgH,QAAeC,GAAQ,EAAgB;QAAA,IAAdlJ,MAAM,GAAAmJ,SAAA,CAAA1G,MAAA,QAAA0G,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;QACrC,IAAQ5I,CAAC,GAAQW,KAAK,CAAdX,CAAC;UAAED,CAAC,GAAKY,KAAK,CAAXZ,CAAC;QACZ,IAAM+I,GAAG,GAAGlI,EAAE,CAACoH,KAAK;QACpBW,GAAG,GAAG3J,WAAW,CAAC,UAAU,EAAE2J,GAAG,EAAEG,GAAG,CAAC,CAAC,CAAC;QACzC,IAAMC,MAAM,GAAGJ,GAAG,CAACK,KAAK,EAAE,CAAC,CAAC;QAC5B,IAAMC,QAAQ,GAAGN,GAAG,CAACG,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;QAC/BC,MAAM,CAACD,GAAG,GAAG,CAAC,CAAC,GAAGG,QAAQ,GAAG,CAAC,IAAI,CAAC,CAAC;QACpC,IAAMvF,CAAC,GAAG3E,EAAE,CAACmK,eAAe,CAACH,MAAM,CAAC;QACpC,IAAIrF,CAAC,KAAKvE,GAAG,EAAE;UACb;QAAA,CACD,MAAM;UACL;UACA,IAAIM,MAAM,EAAE+C,aAAa,CAACkB,CAAC,EAAEtC,IAAI,CAAC,CAAC,CAAC;UAAA,KAC/BoB,aAAa,CAACkB,CAAC,EAAE9C,EAAE,CAACuI,KAAK,CAAC,CAAC,CAAC;;QAGnC;QACA;QACA,IAAMC,EAAE,GAAG/H,IAAI,CAACqC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC;QACxB,IAAMnC,CAAC,GAAGF,IAAI,CAAC+H,EAAE,GAAG/J,GAAG,CAAC,CAAC,CAAC;QAC1B,IAAMmC,CAAC,GAAGH,IAAI,CAACrB,CAAC,GAAGoJ,EAAE,GAAGrJ,CAAC,CAAC,CAAC,CAAC;QAC5B,IAAAsJ,QAAA,GAA4BjJ,OAAO,CAACmB,CAAC,EAAEC,CAAC,CAAC;UAAnCC,OAAO,GAAA4H,QAAA,CAAP5H,OAAO;UAASgC,CAAC,GAAA4F,QAAA,CAAR3H,KAAK,CAAsB,CAAC;QAC3C,IAAI,CAACD,OAAO,EAAE,MAAM,IAAIU,KAAK,CAAC,qCAAqC,CAAC;QACpE,IAAMmH,MAAM,GAAG,CAAC7F,CAAC,GAAGpE,GAAG,MAAMA,GAAG,CAAC,CAAC;QAClC,IAAMkK,aAAa,GAAG,CAACN,QAAQ,GAAG,IAAI,MAAM,CAAC,CAAC,CAAC;QAC/C,IAAI,CAACxJ,MAAM,IAAIgE,CAAC,KAAKtE,GAAG,IAAIoK,aAAa;UACvC;UACA,MAAM,IAAIpH,KAAK,CAAC,8BAA8B,CAAC;QACjD,IAAIoH,aAAa,KAAKD,MAAM,EAAE7F,CAAC,GAAGpC,IAAI,CAAC,CAACoC,CAAC,CAAC,CAAC,CAAC;QAC5C,OAAOV,KAAK,CAACoF,UAAU,CAAC;UAAE1E,CAAC,EAADA,CAAC;UAAEC,CAAC,EAADA;QAAC,CAAE,CAAC;MACnC;IAAC;MAAAJ,GAAA;MAAA5B,KAAA,EACD,SAAA8H,eAAsBC,OAAY;QAChC,OAAOC,oBAAoB,CAACD,OAAO,CAAC,CAACE,KAAK;MAC5C;IAAC;IAAA,OAAA5G,KAAA;EAAA;EAvPeA,KAAA,CAAA6G,IAAI,GAAG,IAAI7G,KAAK,CAACpC,KAAK,CAACkJ,EAAE,EAAElJ,KAAK,CAACmJ,EAAE,EAAEzK,GAAG,EAAEgC,IAAI,CAACV,KAAK,CAACkJ,EAAE,GAAGlJ,KAAK,CAACmJ,EAAE,CAAC,CAAC;EACpE/G,KAAA,CAAAuC,IAAI,GAAG,IAAIvC,KAAK,CAAC5D,GAAG,EAAEE,GAAG,EAAEA,GAAG,EAAEF,GAAG,CAAC,CAAC,CAAC;EAiQxD,IAAc4G,CAAC,GAAchD,KAAK,CAA1B6G,IAAI;IAAWzC,CAAC,GAAKpE,KAAK,CAAjBuC,IAAI;EACrB,IAAMoB,IAAI,GAAGzH,IAAI,CAAC8D,KAAK,EAAE9B,WAAW,GAAG,CAAC,CAAC;EAEzC,SAAS8I,IAAIA,CAAChK,CAAS;IACrB,OAAOjB,GAAG,CAACiB,CAAC,EAAEc,WAAW,CAAC;EAC5B;EACA;EACA,SAASmJ,OAAOA,CAAClK,IAAgB;IAC/B,OAAOiK,IAAI,CAAChL,EAAE,CAACmK,eAAe,CAACpJ,IAAI,CAAC,CAAC;EACvC;EAEA;EACA,SAAS4J,oBAAoBA,CAACpG,GAAQ;IACpC,IAAMwF,GAAG,GAAG7H,WAAW;IACvBqC,GAAG,GAAGtE,WAAW,CAAC,aAAa,EAAEsE,GAAG,EAAEwF,GAAG,CAAC;IAC1C;IACA;IACA,IAAMmB,MAAM,GAAGjL,WAAW,CAAC,oBAAoB,EAAEgC,KAAK,CAACsC,GAAG,CAAC,EAAE,CAAC,GAAGwF,GAAG,CAAC;IACrE,IAAMoB,IAAI,GAAGhK,iBAAiB,CAAC+J,MAAM,CAACjB,KAAK,CAAC,CAAC,EAAEF,GAAG,CAAC,CAAC,CAAC,CAAC;IACtD,IAAMqB,MAAM,GAAGF,MAAM,CAACjB,KAAK,CAACF,GAAG,EAAE,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC;IAC3C,IAAMhC,MAAM,GAAGkD,OAAO,CAACE,IAAI,CAAC,CAAC,CAAC;IAC9B,IAAMP,KAAK,GAAG5D,CAAC,CAACc,QAAQ,CAACC,MAAM,CAAC,CAAC,CAAC;IAClC,IAAMsD,UAAU,GAAGT,KAAK,CAAC9B,UAAU,EAAE,CAAC,CAAC;IACvC,OAAO;MAAEqC,IAAI,EAAJA,IAAI;MAAEC,MAAM,EAANA,MAAM;MAAErD,MAAM,EAANA,MAAM;MAAE6C,KAAK,EAALA,KAAK;MAAES,UAAU,EAAVA;IAAU,CAAE;EACpD;EAEA;EACA,SAASC,YAAYA,CAACZ,OAAY;IAChC,OAAOC,oBAAoB,CAACD,OAAO,CAAC,CAACW,UAAU;EACjD;EAEA;EACA,SAASE,kBAAkBA,CAAA,EAAuD;IAAA,IAAtDC,OAAA,GAAA3B,SAAA,CAAA1G,MAAA,QAAA0G,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAe,IAAI4B,UAAU,EAAE;IAAA,SAAAC,IAAA,GAAA7B,SAAA,CAAA1G,MAAA,EAAKwI,IAAkB,OAAAC,KAAA,CAAAF,IAAA,OAAAA,IAAA,WAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;MAAlBF,IAAkB,CAAAE,IAAA,QAAAhC,SAAA,CAAAgC,IAAA;IAAA;IAChF,IAAMC,GAAG,GAAG9L,EAAE,CAAC+L,WAAW,CAAAC,KAAA,CAAdhM,EAAE,EAAgB2L,IAAI,CAAC;IACnC,OAAOV,OAAO,CAAChJ,KAAK,CAACb,MAAM,CAAC0K,GAAG,EAAE7L,WAAW,CAAC,SAAS,EAAEuL,OAAO,CAAC,EAAE,CAAC,CAACxJ,OAAO,CAAC,CAAC,CAAC;EAChF;EAEA;EACA,SAASiK,IAAIA,CAACH,GAAQ,EAAEpB,OAAY,EAAiC;IAAA,IAA/BwB,OAAA,GAAArC,SAAA,CAAA1G,MAAA,QAAA0G,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAA6B,EAAE;IACnEiC,GAAG,GAAG7L,WAAW,CAAC,SAAS,EAAE6L,GAAG,CAAC;IACjC,IAAI9J,OAAO,EAAE8J,GAAG,GAAG9J,OAAO,CAAC8J,GAAG,CAAC,CAAC,CAAC;IACjC,IAAAK,qBAAA,GAAuCxB,oBAAoB,CAACD,OAAO,CAAC;MAA5DU,MAAM,GAAAe,qBAAA,CAANf,MAAM;MAAErD,MAAM,GAAAoE,qBAAA,CAANpE,MAAM;MAAEsD,UAAU,GAAAc,qBAAA,CAAVd,UAAU;IAClC,IAAMe,CAAC,GAAGb,kBAAkB,CAACW,OAAO,CAACV,OAAO,EAAEJ,MAAM,EAAEU,GAAG,CAAC,CAAC,CAAC;IAC5D,IAAMO,CAAC,GAAGrF,CAAC,CAACc,QAAQ,CAACsE,CAAC,CAAC,CAACtD,UAAU,EAAE,CAAC,CAAC;IACtC,IAAMwD,CAAC,GAAGf,kBAAkB,CAACW,OAAO,CAACV,OAAO,EAAEa,CAAC,EAAEhB,UAAU,EAAES,GAAG,CAAC,CAAC,CAAC;IACnE,IAAMS,CAAC,GAAGvB,IAAI,CAACoB,CAAC,GAAGE,CAAC,GAAGvE,MAAM,CAAC,CAAC,CAAC;IAChCpE,SAAS,CAAC4I,CAAC,CAAC,CAAC,CAAC;IACd,IAAMC,GAAG,GAAGxM,EAAE,CAAC+L,WAAW,CAACM,CAAC,EAAErM,EAAE,CAACgJ,eAAe,CAACuD,CAAC,EAAE1K,EAAE,CAACoH,KAAK,CAAC,CAAC;IAC9D,OAAOhJ,WAAW,CAAC,QAAQ,EAAEuM,GAAG,EAAEtK,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC;EACtD;;EAEA,IAAMuK,UAAU,GAAwChM,cAAc;EACtE,SAASiM,MAAMA,CAACC,GAAQ,EAAEb,GAAQ,EAAEc,SAAc,EAAsB;IAAA,IAApBV,OAAO,GAAArC,SAAA,CAAA1G,MAAA,QAAA0G,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG4C,UAAU;IACtE,IAAQjB,OAAO,GAAaU,OAAO,CAA3BV,OAAO;MAAE9K,MAAM,GAAKwL,OAAO,CAAlBxL,MAAM;IACvB,IAAMqJ,GAAG,GAAGlI,EAAE,CAACoH,KAAK,CAAC,CAAC;IACtB0D,GAAG,GAAG1M,WAAW,CAAC,WAAW,EAAE0M,GAAG,EAAE,CAAC,GAAG5C,GAAG,CAAC,CAAC,CAAC;IAC9C+B,GAAG,GAAG7L,WAAW,CAAC,SAAS,EAAE6L,GAAG,CAAC;IACjC,IAAI9J,OAAO,EAAE8J,GAAG,GAAG9J,OAAO,CAAC8J,GAAG,CAAC,CAAC,CAAC;IAEjC,IAAMS,CAAC,GAAGvM,EAAE,CAACmK,eAAe,CAACwC,GAAG,CAAC1C,KAAK,CAACF,GAAG,EAAE,CAAC,GAAGA,GAAG,CAAC,CAAC;IACrD;IACA;IACA,IAAIrD,CAAC,EAAE2F,CAAC,EAAEQ,EAAE;IACZ,IAAI;MACFnG,CAAC,GAAG1C,KAAK,CAAC2F,OAAO,CAACiD,SAAS,EAAElM,MAAM,CAAC;MACpC2L,CAAC,GAAGrI,KAAK,CAAC2F,OAAO,CAACgD,GAAG,CAAC1C,KAAK,CAAC,CAAC,EAAEF,GAAG,CAAC,EAAErJ,MAAM,CAAC;MAC5CmM,EAAE,GAAG7F,CAAC,CAACmB,cAAc,CAACoE,CAAC,CAAC,CAAC,CAAC;KAC3B,CAAC,OAAOO,KAAK,EAAE;MACd,OAAO,KAAK;;IAEd,IAAI,CAACpM,MAAM,IAAIgG,CAAC,CAAC4B,YAAY,EAAE,EAAE,OAAO,KAAK;IAE7C,IAAMgE,CAAC,GAAGf,kBAAkB,CAACC,OAAO,EAAEa,CAAC,CAACvD,UAAU,EAAE,EAAEpC,CAAC,CAACoC,UAAU,EAAE,EAAEgD,GAAG,CAAC;IAC1E,IAAMiB,GAAG,GAAGV,CAAC,CAAC9E,GAAG,CAACb,CAAC,CAACyB,cAAc,CAACmE,CAAC,CAAC,CAAC;IACtC;IACA,OAAOS,GAAG,CAACrF,QAAQ,CAACmF,EAAE,CAAC,CAAChE,aAAa,EAAE,CAAC9C,MAAM,CAAC/B,KAAK,CAACuC,IAAI,CAAC;EAC5D;EAEAS,CAAC,CAACpC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;EAErB,IAAMoI,KAAK,GAAG;IACZrC,oBAAoB,EAApBA,oBAAoB;IACpB;IACAsC,gBAAgB,EAAE,SAAAA,iBAAA;MAAA,OAAkB/L,WAAW,CAACW,EAAE,CAACoH,KAAK,CAAC;IAAA;IAEzD;;;;;;IAMAiE,UAAU,WAAAA,WAAA,EAAmC;MAAA,IAAlCrI,UAAU,GAAAgF,SAAA,CAAA1G,MAAA,QAAA0G,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC;MAAA,IAAEe,KAAK,GAAAf,SAAA,CAAA1G,MAAA,QAAA0G,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG7F,KAAK,CAAC6G,IAAI;MAC3CD,KAAK,CAAChG,cAAc,CAACC,UAAU,CAAC;MAChC+F,KAAK,CAAC9C,QAAQ,CAACzH,MAAM,CAAC,CAAC,CAAC,CAAC;MACzB,OAAOuK,KAAK;IACd;GACD;EAED,OAAO;IACLhJ,KAAK,EAALA,KAAK;IACL0J,YAAY,EAAZA,YAAY;IACZW,IAAI,EAAJA,IAAI;IACJS,MAAM,EAANA,MAAM;IACNS,aAAa,EAAEnJ,KAAK;IACpBgJ,KAAK,EAALA;GACD;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}