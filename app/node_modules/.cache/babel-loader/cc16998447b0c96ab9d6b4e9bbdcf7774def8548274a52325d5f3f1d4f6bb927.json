{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compactBytesToNibbles = exports.bytesToNibbles = exports.nibblesToCompactBytes = exports.nibblesToBytes = exports.hasTerminator = void 0;\n// Reference: https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/\n/**\n *\n * @param s byte sequence\n * @returns boolean indicating if input hex nibble sequence has terminator indicating leaf-node\n *          terminator is represented with 16 because a nibble ranges from 0 - 15(f)\n */\nconst hasTerminator = nibbles => {\n  return nibbles.length > 0 && nibbles[nibbles.length - 1] === 16;\n};\nexports.hasTerminator = hasTerminator;\nconst nibblesToBytes = (nibbles, bytes) => {\n  for (let bi = 0, ni = 0; ni < nibbles.length; bi += 1, ni += 2) {\n    bytes[bi] = nibbles[ni] << 4 | nibbles[ni + 1];\n  }\n};\nexports.nibblesToBytes = nibblesToBytes;\nconst nibblesToCompactBytes = nibbles => {\n  let terminator = 0;\n  if ((0, exports.hasTerminator)(nibbles)) {\n    terminator = 1;\n    // Remove the terminator from the sequence\n    nibbles = nibbles.subarray(0, nibbles.length - 1);\n  }\n  const buf = new Uint8Array(nibbles.length / 2 + 1);\n  // Shift the terminator info into the first nibble of buf[0]\n  buf[0] = terminator << 5;\n  // If odd length, then add that flag into the first nibble and put the odd nibble to\n  // second part of buf[0] which otherwise will be left padded with a 0\n  if ((nibbles.length & 1) === 1) {\n    buf[0] |= 1 << 4;\n    buf[0] |= nibbles[0];\n    nibbles = nibbles.subarray(1);\n  }\n  // create bytes out of the rest even nibbles\n  (0, exports.nibblesToBytes)(nibbles, buf.subarray(1));\n  return buf;\n};\nexports.nibblesToCompactBytes = nibblesToCompactBytes;\nconst bytesToNibbles = str => {\n  const l = str.length * 2 + 1;\n  const nibbles = new Uint8Array(l);\n  for (let i = 0; i < str.length; i++) {\n    const b = str[i];\n    nibbles[i * 2] = b / 16;\n    nibbles[i * 2 + 1] = b % 16;\n  }\n  // This will get removed from calling function if the first nibble\n  // indicates that terminator is not present\n  nibbles[l - 1] = 16;\n  return nibbles;\n};\nexports.bytesToNibbles = bytesToNibbles;\nconst compactBytesToNibbles = compact => {\n  if (compact.length === 0) {\n    return compact;\n  }\n  let base = (0, exports.bytesToNibbles)(compact);\n  // delete terminator flag if terminator flag was not in first nibble\n  if (base[0] < 2) {\n    base = base.subarray(0, base.length - 1);\n  }\n  // chop the terminator nibble and the even padding (if there is one)\n  // i.e.  chop 2 left nibbles when even else 1 when odd\n  const chop = 2 - (base[0] & 1);\n  return base.subarray(chop);\n};\nexports.compactBytesToNibbles = compactBytesToNibbles;\n/**\n * A test helper to generates compact path for a subset of key bytes\n *\n * TODO: Commenting the code for now as this seems to be helper function\n * (from geth codebase )\n *\n */\n//\n//\n// export const getPathTo = (tillBytes: number, key: Buffer) => {\n//   const hexNibbles = bytesToNibbles(key).subarray(0, tillBytes)\n//   // Remove the terminator if its there, although it would be there only if tillBytes >= key.length\n//   // This seems to be a test helper to generate paths so correctness of this isn't necessary\n//   hexNibbles[hexNibbles.length - 1] = 0\n//   const compactBytes = nibblesToCompactBytes(hexNibbles)\n//   return [Buffer.from(compactBytes)]\n// }","map":{"version":3,"names":["hasTerminator","nibbles","length","exports","nibblesToBytes","bytes","bi","ni","nibblesToCompactBytes","terminator","subarray","buf","Uint8Array","bytesToNibbles","str","l","i","b","compactBytesToNibbles","compact","base","chop"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@ethereumjs/util/src/encoding.ts"],"sourcesContent":["// Reference: https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/\n/**\n *\n * @param s byte sequence\n * @returns boolean indicating if input hex nibble sequence has terminator indicating leaf-node\n *          terminator is represented with 16 because a nibble ranges from 0 - 15(f)\n */\nexport const hasTerminator = (nibbles: Uint8Array) => {\n  return nibbles.length > 0 && nibbles[nibbles.length - 1] === 16\n}\n\nexport const nibblesToBytes = (nibbles: Uint8Array, bytes: Uint8Array) => {\n  for (let bi = 0, ni = 0; ni < nibbles.length; bi += 1, ni += 2) {\n    bytes[bi] = (nibbles[ni] << 4) | nibbles[ni + 1]\n  }\n}\n\nexport const nibblesToCompactBytes = (nibbles: Uint8Array) => {\n  let terminator = 0\n  if (hasTerminator(nibbles)) {\n    terminator = 1\n    // Remove the terminator from the sequence\n    nibbles = nibbles.subarray(0, nibbles.length - 1)\n  }\n  const buf = new Uint8Array(nibbles.length / 2 + 1)\n  // Shift the terminator info into the first nibble of buf[0]\n  buf[0] = terminator << 5\n  // If odd length, then add that flag into the first nibble and put the odd nibble to\n  // second part of buf[0] which otherwise will be left padded with a 0\n  if ((nibbles.length & 1) === 1) {\n    buf[0] |= 1 << 4\n    buf[0] |= nibbles[0]\n    nibbles = nibbles.subarray(1)\n  }\n  // create bytes out of the rest even nibbles\n  nibblesToBytes(nibbles, buf.subarray(1))\n  return buf\n}\n\nexport const bytesToNibbles = (str: Uint8Array) => {\n  const l = str.length * 2 + 1\n  const nibbles = new Uint8Array(l)\n  for (let i = 0; i < str.length; i++) {\n    const b = str[i]\n    nibbles[i * 2] = b / 16\n    nibbles[i * 2 + 1] = b % 16\n  }\n  // This will get removed from calling function if the first nibble\n  // indicates that terminator is not present\n  nibbles[l - 1] = 16\n  return nibbles\n}\n\nexport const compactBytesToNibbles = (compact: Uint8Array) => {\n  if (compact.length === 0) {\n    return compact\n  }\n  let base = bytesToNibbles(compact)\n  // delete terminator flag if terminator flag was not in first nibble\n  if (base[0] < 2) {\n    base = base.subarray(0, base.length - 1)\n  }\n  // chop the terminator nibble and the even padding (if there is one)\n  // i.e.  chop 2 left nibbles when even else 1 when odd\n  const chop = 2 - (base[0] & 1)\n  return base.subarray(chop)\n}\n\n/**\n * A test helper to generates compact path for a subset of key bytes\n *\n * TODO: Commenting the code for now as this seems to be helper function\n * (from geth codebase )\n *\n */\n//\n//\n// export const getPathTo = (tillBytes: number, key: Buffer) => {\n//   const hexNibbles = bytesToNibbles(key).subarray(0, tillBytes)\n//   // Remove the terminator if its there, although it would be there only if tillBytes >= key.length\n//   // This seems to be a test helper to generate paths so correctness of this isn't necessary\n//   hexNibbles[hexNibbles.length - 1] = 0\n//   const compactBytes = nibblesToCompactBytes(hexNibbles)\n//   return [Buffer.from(compactBytes)]\n// }\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}