{"ast":null,"code":"import EventEmitter from \"eventemitter3\";\nimport camelCase from \"camelcase\";\nimport { SystemProgram } from \"@solana/web3.js\";\nimport Coder, { stateDiscriminator } from \"../../coder\";\nimport { getProvider } from \"../../\";\nimport { validateAccounts, parseIdlErrors } from \"../common\";\nimport { findProgramAddressSync, createWithSeedSync } from \"../../utils/pubkey\";\nimport InstructionNamespaceFactory from \"./instruction\";\nimport RpcNamespaceFactory from \"./rpc\";\nimport TransactionNamespaceFactory from \"./transaction\";\nexport default class StateFactory {\n  static build(idl, coder, programId, provider) {\n    if (idl.state === undefined) {\n      return undefined;\n    }\n    return new StateClient(idl, programId, provider, coder);\n  }\n}\n/**\n * A client for the program state. Similar to the base [[Program]] client,\n * one can use this to send transactions and read accounts for the state\n * abstraction.\n */\nexport class StateClient {\n  constructor(idl, programId,\n  /**\n   * Returns the client's wallet and network provider.\n   */\n  provider = getProvider(),\n  /**\n   * Returns the coder.\n   */\n  coder = new Coder(idl)) {\n    this.provider = provider;\n    this.coder = coder;\n    this._idl = idl;\n    this._programId = programId;\n    this._address = programStateAddress(programId);\n    this._sub = null;\n    // Build namespaces.\n    const [instruction, transaction, rpc] = (() => {\n      var _a;\n      let instruction = {};\n      let transaction = {};\n      let rpc = {};\n      (_a = idl.state) === null || _a === void 0 ? void 0 : _a.methods.forEach(m => {\n        // Build instruction method.\n        const ixItem = InstructionNamespaceFactory.build(m, (ixName, ix) => coder.instruction.encodeState(ixName, ix), programId);\n        ixItem[\"accounts\"] = accounts => {\n          const keys = stateInstructionKeys(programId, provider, m, accounts);\n          return keys.concat(InstructionNamespaceFactory.accountsArray(accounts, m.accounts));\n        };\n        // Build transaction method.\n        const txItem = TransactionNamespaceFactory.build(m, ixItem);\n        // Build RPC method.\n        const rpcItem = RpcNamespaceFactory.build(m, txItem, parseIdlErrors(idl), provider);\n        // Attach them all to their respective namespaces.\n        const name = camelCase(m.name);\n        instruction[name] = ixItem;\n        transaction[name] = txItem;\n        rpc[name] = rpcItem;\n      });\n      return [instruction, transaction, rpc];\n    })();\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.rpc = rpc;\n  }\n  /**\n   * Returns the program ID owning the state.\n   */\n  get programId() {\n    return this._programId;\n  }\n  /**\n   * Returns the deserialized state account.\n   */\n  async fetch() {\n    const addr = this.address();\n    const accountInfo = await this.provider.connection.getAccountInfo(addr);\n    if (accountInfo === null) {\n      throw new Error(`Account does not exist ${addr.toString()}`);\n    }\n    // Assert the account discriminator is correct.\n    const state = this._idl.state;\n    if (!state) {\n      throw new Error(\"State is not specified in IDL.\");\n    }\n    const expectedDiscriminator = await stateDiscriminator(state.struct.name);\n    if (expectedDiscriminator.compare(accountInfo.data.slice(0, 8))) {\n      throw new Error(\"Invalid account discriminator\");\n    }\n    return this.coder.state.decode(accountInfo.data);\n  }\n  /**\n   * Returns the state address.\n   */\n  address() {\n    return this._address;\n  }\n  /**\n   * Returns an `EventEmitter` with a `\"change\"` event that's fired whenever\n   * the state account cahnges.\n   */\n  subscribe(commitment) {\n    if (this._sub !== null) {\n      return this._sub.ee;\n    }\n    const ee = new EventEmitter();\n    const listener = this.provider.connection.onAccountChange(this.address(), acc => {\n      const account = this.coder.state.decode(acc.data);\n      ee.emit(\"change\", account);\n    }, commitment);\n    this._sub = {\n      ee,\n      listener\n    };\n    return ee;\n  }\n  /**\n   * Unsubscribes to state changes.\n   */\n  unsubscribe() {\n    if (this._sub !== null) {\n      this.provider.connection.removeAccountChangeListener(this._sub.listener).then(async () => {\n        this._sub = null;\n      }).catch(console.error);\n    }\n  }\n}\n// Calculates the deterministic address of the program's \"state\" account.\nfunction programStateAddress(programId) {\n  let [registrySigner] = findProgramAddressSync([], programId);\n  return createWithSeedSync(registrySigner, \"unversioned\", programId);\n}\n// Returns the common keys that are prepended to all instructions targeting\n// the \"state\" of a program.\nfunction stateInstructionKeys(programId, provider, m, accounts) {\n  if (m.name === \"new\") {\n    // Ctor `new` method.\n    const [programSigner] = findProgramAddressSync([], programId);\n    return [{\n      pubkey: provider.wallet.publicKey,\n      isWritable: false,\n      isSigner: true\n    }, {\n      pubkey: programStateAddress(programId),\n      isWritable: true,\n      isSigner: false\n    }, {\n      pubkey: programSigner,\n      isWritable: false,\n      isSigner: false\n    }, {\n      pubkey: SystemProgram.programId,\n      isWritable: false,\n      isSigner: false\n    }, {\n      pubkey: programId,\n      isWritable: false,\n      isSigner: false\n    }];\n  } else {\n    validateAccounts(m.accounts, accounts);\n    return [{\n      pubkey: programStateAddress(programId),\n      isWritable: true,\n      isSigner: false\n    }];\n  }\n}","map":{"version":3,"names":["EventEmitter","camelCase","SystemProgram","Coder","stateDiscriminator","getProvider","validateAccounts","parseIdlErrors","findProgramAddressSync","createWithSeedSync","InstructionNamespaceFactory","RpcNamespaceFactory","TransactionNamespaceFactory","StateFactory","build","idl","coder","programId","provider","state","undefined","StateClient","constructor","_idl","_programId","_address","programStateAddress","_sub","instruction","transaction","rpc","_a","methods","forEach","m","ixItem","ixName","ix","encodeState","accounts","keys","stateInstructionKeys","concat","accountsArray","txItem","rpcItem","name","fetch","addr","address","accountInfo","connection","getAccountInfo","Error","toString","expectedDiscriminator","struct","compare","data","slice","decode","subscribe","commitment","ee","listener","onAccountChange","acc","account","emit","unsubscribe","removeAccountChangeListener","then","catch","console","error","registrySigner","programSigner","pubkey","wallet","publicKey","isWritable","isSigner"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/program/namespace/state.ts"],"sourcesContent":["import EventEmitter from \"eventemitter3\";\nimport camelCase from \"camelcase\";\nimport {\n  PublicKey,\n  SystemProgram,\n  Commitment,\n  AccountMeta,\n} from \"@solana/web3.js\";\nimport Provider from \"../../provider\";\nimport {\n  Idl,\n  IdlAccountItem,\n  IdlInstruction,\n  IdlStateMethod,\n  IdlTypeDef,\n} from \"../../idl\";\nimport Coder, { stateDiscriminator } from \"../../coder\";\nimport { RpcNamespace, InstructionNamespace, TransactionNamespace } from \"./\";\nimport { getProvider } from \"../../\";\nimport { Subscription, validateAccounts, parseIdlErrors } from \"../common\";\nimport { findProgramAddressSync, createWithSeedSync } from \"../../utils/pubkey\";\nimport { Accounts } from \"../context\";\nimport InstructionNamespaceFactory from \"./instruction\";\nimport RpcNamespaceFactory from \"./rpc\";\nimport TransactionNamespaceFactory from \"./transaction\";\nimport { IdlTypes, TypeDef } from \"./types\";\n\nexport default class StateFactory {\n  public static build<IDL extends Idl>(\n    idl: IDL,\n    coder: Coder,\n    programId: PublicKey,\n    provider?: Provider\n  ): StateClient<IDL> | undefined {\n    if (idl.state === undefined) {\n      return undefined;\n    }\n    return new StateClient(idl, programId, provider, coder);\n  }\n}\n\ntype NullableMethods<IDL extends Idl> = IDL[\"state\"] extends undefined\n  ? IdlInstruction[]\n  : NonNullable<IDL[\"state\"]>[\"methods\"];\n\n/**\n * A client for the program state. Similar to the base [[Program]] client,\n * one can use this to send transactions and read accounts for the state\n * abstraction.\n */\nexport class StateClient<IDL extends Idl> {\n  /**\n   * [[RpcNamespace]] for all state methods.\n   */\n  readonly rpc: RpcNamespace<IDL, NullableMethods<IDL>[number]>;\n\n  /**\n   * [[InstructionNamespace]] for all state methods.\n   */\n  readonly instruction: InstructionNamespace<IDL, NullableMethods<IDL>[number]>;\n\n  /**\n   * [[TransactionNamespace]] for all state methods.\n   */\n  readonly transaction: TransactionNamespace<IDL, NullableMethods<IDL>[number]>;\n\n  /**\n   * Returns the program ID owning the state.\n   */\n  get programId(): PublicKey {\n    return this._programId;\n  }\n  private _programId: PublicKey;\n\n  private _address: PublicKey;\n  private _coder: Coder;\n  private _idl: IDL;\n  private _sub: Subscription | null;\n\n  constructor(\n    idl: IDL,\n    programId: PublicKey,\n    /**\n     * Returns the client's wallet and network provider.\n     */\n    public readonly provider: Provider = getProvider(),\n    /**\n     * Returns the coder.\n     */\n    public readonly coder: Coder = new Coder(idl)\n  ) {\n    this._idl = idl;\n    this._programId = programId;\n    this._address = programStateAddress(programId);\n    this._sub = null;\n\n    // Build namespaces.\n    const [instruction, transaction, rpc] = ((): [\n      InstructionNamespace<IDL, NullableMethods<IDL>[number]>,\n      TransactionNamespace<IDL, NullableMethods<IDL>[number]>,\n      RpcNamespace<IDL, NullableMethods<IDL>[number]>\n    ] => {\n      let instruction: InstructionNamespace = {};\n      let transaction: TransactionNamespace = {};\n      let rpc: RpcNamespace = {};\n\n      idl.state?.methods.forEach(\n        <I extends NullableMethods<IDL>[number]>(m: I) => {\n          // Build instruction method.\n          const ixItem = InstructionNamespaceFactory.build<IDL, I>(\n            m,\n            (ixName, ix) => coder.instruction.encodeState(ixName, ix),\n            programId\n          );\n          ixItem[\"accounts\"] = (accounts) => {\n            const keys = stateInstructionKeys(programId, provider, m, accounts);\n            return keys.concat(\n              InstructionNamespaceFactory.accountsArray(accounts, m.accounts)\n            );\n          };\n          // Build transaction method.\n          const txItem = TransactionNamespaceFactory.build(m, ixItem);\n          // Build RPC method.\n          const rpcItem = RpcNamespaceFactory.build(\n            m,\n            txItem,\n            parseIdlErrors(idl),\n            provider\n          );\n\n          // Attach them all to their respective namespaces.\n          const name = camelCase(m.name);\n          instruction[name] = ixItem;\n          transaction[name] = txItem;\n          rpc[name] = rpcItem;\n        }\n      );\n\n      return [\n        instruction as InstructionNamespace<IDL, NullableMethods<IDL>[number]>,\n        transaction as TransactionNamespace<IDL, NullableMethods<IDL>[number]>,\n        rpc as RpcNamespace<IDL, NullableMethods<IDL>[number]>,\n      ];\n    })();\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.rpc = rpc;\n  }\n\n  /**\n   * Returns the deserialized state account.\n   */\n  async fetch(): Promise<\n    TypeDef<\n      IDL[\"state\"] extends undefined\n        ? IdlTypeDef\n        : NonNullable<IDL[\"state\"]>[\"struct\"],\n      IdlTypes<IDL>\n    >\n  > {\n    const addr = this.address();\n    const accountInfo = await this.provider.connection.getAccountInfo(addr);\n    if (accountInfo === null) {\n      throw new Error(`Account does not exist ${addr.toString()}`);\n    }\n    // Assert the account discriminator is correct.\n    const state = this._idl.state;\n    if (!state) {\n      throw new Error(\"State is not specified in IDL.\");\n    }\n    const expectedDiscriminator = await stateDiscriminator(state.struct.name);\n    if (expectedDiscriminator.compare(accountInfo.data.slice(0, 8))) {\n      throw new Error(\"Invalid account discriminator\");\n    }\n    return this.coder.state.decode(accountInfo.data);\n  }\n\n  /**\n   * Returns the state address.\n   */\n  address(): PublicKey {\n    return this._address;\n  }\n\n  /**\n   * Returns an `EventEmitter` with a `\"change\"` event that's fired whenever\n   * the state account cahnges.\n   */\n  subscribe(commitment?: Commitment): EventEmitter {\n    if (this._sub !== null) {\n      return this._sub.ee;\n    }\n    const ee = new EventEmitter();\n\n    const listener = this.provider.connection.onAccountChange(\n      this.address(),\n      (acc) => {\n        const account = this.coder.state.decode(acc.data);\n        ee.emit(\"change\", account);\n      },\n      commitment\n    );\n\n    this._sub = {\n      ee,\n      listener,\n    };\n\n    return ee;\n  }\n\n  /**\n   * Unsubscribes to state changes.\n   */\n  unsubscribe() {\n    if (this._sub !== null) {\n      this.provider.connection\n        .removeAccountChangeListener(this._sub.listener)\n        .then(async () => {\n          this._sub = null;\n        })\n        .catch(console.error);\n    }\n  }\n}\n\n// Calculates the deterministic address of the program's \"state\" account.\nfunction programStateAddress(programId: PublicKey): PublicKey {\n  let [registrySigner] = findProgramAddressSync([], programId);\n  return createWithSeedSync(registrySigner, \"unversioned\", programId);\n}\n\n// Returns the common keys that are prepended to all instructions targeting\n// the \"state\" of a program.\nfunction stateInstructionKeys<M extends IdlStateMethod>(\n  programId: PublicKey,\n  provider: Provider,\n  m: M,\n  accounts: Accounts<M[\"accounts\"][number]>\n): AccountMeta[] {\n  if (m.name === \"new\") {\n    // Ctor `new` method.\n    const [programSigner] = findProgramAddressSync([], programId);\n    return [\n      {\n        pubkey: provider.wallet.publicKey,\n        isWritable: false,\n        isSigner: true,\n      },\n      {\n        pubkey: programStateAddress(programId),\n        isWritable: true,\n        isSigner: false,\n      },\n      { pubkey: programSigner, isWritable: false, isSigner: false },\n      {\n        pubkey: SystemProgram.programId,\n        isWritable: false,\n        isSigner: false,\n      },\n\n      { pubkey: programId, isWritable: false, isSigner: false },\n    ];\n  } else {\n    validateAccounts(m.accounts, accounts);\n    return [\n      {\n        pubkey: programStateAddress(programId),\n        isWritable: true,\n        isSigner: false,\n      },\n    ];\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}