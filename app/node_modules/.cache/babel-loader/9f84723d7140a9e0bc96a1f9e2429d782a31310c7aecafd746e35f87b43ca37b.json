{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeIdlAccount = exports.decodeIdlAccount = exports.seed = exports.idlAddress = void 0;\nvar buffer_1 = require(\"buffer\");\nvar web3_js_1 = require(\"@solana/web3.js\");\nvar borsh = __importStar(require(\"@project-serum/borsh\"));\n// Deterministic IDL address as a function of the program id.\nfunction idlAddress(_x) {\n  return _idlAddress.apply(this, arguments);\n}\nfunction _idlAddress() {\n  _idlAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(programId) {\n    var base;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return web3_js_1.PublicKey.findProgramAddress([], programId);\n        case 2:\n          base = _context.sent[0];\n          _context.next = 5;\n          return web3_js_1.PublicKey.createWithSeed(base, seed(), programId);\n        case 5:\n          return _context.abrupt(\"return\", _context.sent);\n        case 6:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _idlAddress.apply(this, arguments);\n}\nexports.idlAddress = idlAddress;\n// Seed for generating the idlAddress.\nfunction seed() {\n  return \"anchor:idl\";\n}\nexports.seed = seed;\nvar IDL_ACCOUNT_LAYOUT = borsh.struct([borsh.publicKey(\"authority\"), borsh.vecU8(\"data\")]);\nfunction decodeIdlAccount(data) {\n  return IDL_ACCOUNT_LAYOUT.decode(data);\n}\nexports.decodeIdlAccount = decodeIdlAccount;\nfunction encodeIdlAccount(acc) {\n  var buffer = buffer_1.Buffer.alloc(1000); // TODO: use a tighter buffer.\n  var len = IDL_ACCOUNT_LAYOUT.encode(acc, buffer);\n  return buffer.slice(0, len);\n}\nexports.encodeIdlAccount = encodeIdlAccount;","map":{"version":3,"names":["buffer_1","require","web3_js_1","borsh","__importStar","idlAddress","_x","_idlAddress","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","programId","base","wrap","_callee$","_context","prev","next","PublicKey","findProgramAddress","sent","createWithSeed","seed","abrupt","stop","exports","IDL_ACCOUNT_LAYOUT","struct","publicKey","vecU8","decodeIdlAccount","data","decode","encodeIdlAccount","acc","buffer","Buffer","alloc","len","encode","slice"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/idl.ts"],"sourcesContent":["import { Buffer } from \"buffer\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport * as borsh from \"@project-serum/borsh\";\n\nexport type Idl = {\n  version: string;\n  name: string;\n  instructions: IdlInstruction[];\n  state?: IdlState;\n  accounts?: IdlAccountDef[];\n  types?: IdlTypeDef[];\n  events?: IdlEvent[];\n  errors?: IdlErrorCode[];\n  constants?: IdlConstant[];\n  metadata?: IdlMetadata;\n};\n\nexport type IdlMetadata = any;\n\nexport type IdlConstant = {\n  name: string;\n  type: IdlType;\n  value: string;\n};\n\nexport type IdlEvent = {\n  name: string;\n  fields: IdlEventField[];\n};\n\nexport type IdlEventField = {\n  name: string;\n  type: IdlType;\n  index: boolean;\n};\n\nexport type IdlInstruction = {\n  name: string;\n  accounts: IdlAccountItem[];\n  args: IdlField[];\n  returns?: IdlType;\n};\n\nexport type IdlState = {\n  struct: IdlTypeDef;\n  methods: IdlStateMethod[];\n};\n\nexport type IdlStateMethod = IdlInstruction;\n\nexport type IdlAccountItem = IdlAccount | IdlAccounts;\n\nexport type IdlAccount = {\n  name: string;\n  isMut: boolean;\n  isSigner: boolean;\n  pda?: IdlPda;\n};\n\nexport type IdlPda = {\n  seeds: IdlSeed[];\n  programId?: IdlSeed;\n};\n\nexport type IdlSeed = any; // TODO\n\n// A nested/recursive version of IdlAccount.\nexport type IdlAccounts = {\n  name: string;\n  accounts: IdlAccountItem[];\n};\n\nexport type IdlField = {\n  name: string;\n  type: IdlType;\n};\n\nexport type IdlTypeDef = {\n  name: string;\n  type: IdlTypeDefTy;\n};\n\nexport type IdlAccountDef = {\n  name: string;\n  type: IdlTypeDefTyStruct;\n};\n\nexport type IdlTypeDefTyStruct = {\n  kind: \"struct\";\n  fields: IdlTypeDefStruct;\n};\n\nexport type IdlTypeDefTyEnum = {\n  kind: \"enum\";\n  variants: IdlEnumVariant[];\n};\n\ntype IdlTypeDefTy = IdlTypeDefTyEnum | IdlTypeDefTyStruct;\n\ntype IdlTypeDefStruct = Array<IdlField>;\n\nexport type IdlType =\n  | \"bool\"\n  | \"u8\"\n  | \"i8\"\n  | \"u16\"\n  | \"i16\"\n  | \"u32\"\n  | \"i32\"\n  | \"f32\"\n  | \"u64\"\n  | \"i64\"\n  | \"f64\"\n  | \"u128\"\n  | \"i128\"\n  | \"bytes\"\n  | \"string\"\n  | \"publicKey\"\n  | IdlTypeDefined\n  | IdlTypeOption\n  | IdlTypeCOption\n  | IdlTypeVec\n  | IdlTypeArray;\n\n// User defined type.\nexport type IdlTypeDefined = {\n  defined: string;\n};\n\nexport type IdlTypeOption = {\n  option: IdlType;\n};\n\nexport type IdlTypeCOption = {\n  coption: IdlType;\n};\n\nexport type IdlTypeVec = {\n  vec: IdlType;\n};\n\nexport type IdlTypeArray = {\n  array: [idlType: IdlType, size: number];\n};\n\nexport type IdlEnumVariant = {\n  name: string;\n  fields?: IdlEnumFields;\n};\n\ntype IdlEnumFields = IdlEnumFieldsNamed | IdlEnumFieldsTuple;\n\ntype IdlEnumFieldsNamed = IdlField[];\n\ntype IdlEnumFieldsTuple = IdlType[];\n\nexport type IdlErrorCode = {\n  code: number;\n  name: string;\n  msg?: string;\n};\n\n// Deterministic IDL address as a function of the program id.\nexport async function idlAddress(programId: PublicKey): Promise<PublicKey> {\n  const base = (await PublicKey.findProgramAddress([], programId))[0];\n  return await PublicKey.createWithSeed(base, seed(), programId);\n}\n\n// Seed for generating the idlAddress.\nexport function seed(): string {\n  return \"anchor:idl\";\n}\n\n// The on-chain account of the IDL.\nexport interface IdlProgramAccount {\n  authority: PublicKey;\n  data: Buffer;\n}\n\nconst IDL_ACCOUNT_LAYOUT: borsh.Layout<IdlProgramAccount> = borsh.struct([\n  borsh.publicKey(\"authority\"),\n  borsh.vecU8(\"data\"),\n]);\n\nexport function decodeIdlAccount(data: Buffer): IdlProgramAccount {\n  return IDL_ACCOUNT_LAYOUT.decode(data);\n}\n\nexport function encodeIdlAccount(acc: IdlProgramAccount): Buffer {\n  const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n  const len = IDL_ACCOUNT_LAYOUT.encode(acc, buffer);\n  return buffer.slice(0, len);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAAA,QAAA,GAAAC,OAAA;AACA,IAAAC,SAAA,GAAAD,OAAA;AACA,IAAAE,KAAA,GAAAC,YAAA,CAAAH,OAAA;AAgKA;AAAA,SACsBI,UAAUA,CAAAC,EAAA;EAAA,OAAAC,WAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAF,YAAA;EAAAA,WAAA,GAAAG,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAzB,SAAAC,QAA0BC,SAAoB;IAAA,IAAAC,IAAA;IAAA,OAAAJ,mBAAA,GAAAK,IAAA,UAAAC,SAAAC,QAAA;MAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;QAAA;UAAAF,QAAA,CAAAE,IAAA;UAAA,OAC/BlB,SAAA,CAAAmB,SAAS,CAACC,kBAAkB,CAAC,EAAE,EAAER,SAAS,CAAC;QAAA;UAAzDC,IAAI,GAAAG,QAAA,CAAAK,IAAA,CAAuD,CAAC;UAAAL,QAAA,CAAAE,IAAA;UAAA,OACrDlB,SAAA,CAAAmB,SAAS,CAACG,cAAc,CAACT,IAAI,EAAEU,IAAI,EAAE,EAAEX,SAAS,CAAC;QAAA;UAAA,OAAAI,QAAA,CAAAQ,MAAA,WAAAR,QAAA,CAAAK,IAAA;QAAA;QAAA;UAAA,OAAAL,QAAA,CAAAS,IAAA;MAAA;IAAA,GAAAd,OAAA;EAAA,CAC/D;EAAA,OAAAN,WAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAHDmB,OAAA,CAAAvB,UAAA,GAAAA,UAAA;AAKA;AACA,SAAgBoB,IAAIA,CAAA;EAClB,OAAO,YAAY;AACrB;AAFAG,OAAA,CAAAH,IAAA,GAAAA,IAAA;AAUA,IAAMI,kBAAkB,GAAoC1B,KAAK,CAAC2B,MAAM,CAAC,CACvE3B,KAAK,CAAC4B,SAAS,CAAC,WAAW,CAAC,EAC5B5B,KAAK,CAAC6B,KAAK,CAAC,MAAM,CAAC,CACpB,CAAC;AAEF,SAAgBC,gBAAgBA,CAACC,IAAY;EAC3C,OAAOL,kBAAkB,CAACM,MAAM,CAACD,IAAI,CAAC;AACxC;AAFAN,OAAA,CAAAK,gBAAA,GAAAA,gBAAA;AAIA,SAAgBG,gBAAgBA,CAACC,GAAsB;EACrD,IAAMC,MAAM,GAAGtC,QAAA,CAAAuC,MAAM,CAACC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;EACnC,IAAMC,GAAG,GAAGZ,kBAAkB,CAACa,MAAM,CAACL,GAAG,EAAEC,MAAM,CAAC;EAClD,OAAOA,MAAM,CAACK,KAAK,CAAC,CAAC,EAAEF,GAAG,CAAC;AAC7B;AAJAb,OAAA,CAAAQ,gBAAA,GAAAA,gBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}