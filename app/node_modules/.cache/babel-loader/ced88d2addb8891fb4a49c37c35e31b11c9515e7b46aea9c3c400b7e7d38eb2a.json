{"ast":null,"code":"import { Message, PublicKey, SIGNATURE_LENGTH_IN_BYTES, Transaction } from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { EventEmitter } from \"eventemitter3\";\nconst DEFAULT_SIGNATURE_BUFFER = Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);\nexport class CensoWallet extends EventEmitter {\n  constructor() {\n    super();\n    this.url = 'https://wallet.censocustody.com';\n    this.cleanUp = () => {\n      [...this._timers].forEach(t => this.clearTimer(t));\n      const wallet = this._wallet;\n      if (wallet) {\n        wallet.close();\n      }\n      this._wallet = null;\n      this.emit('disconnected');\n    };\n    this.clearTimer = timer => {\n      this._timers = this._timers.filter(t => t != timer);\n      window.clearInterval(timer);\n    };\n    this.instructionsToSerializableInstructions = instructions => instructions.map(i => {\n      return {\n        'programId': i.programId.toBase58(),\n        'accountMetas': i.keys.map(k => {\n          return {\n            address: k.pubkey.toBase58(),\n            signer: k.isSigner,\n            writable: k.isWritable\n          };\n        }),\n        'data': window.btoa(String.fromCharCode(...i.data))\n      };\n    });\n    this.handleWalletMessage = data => {\n      var _a, _b, _c;\n      if (data.type == \"connected\") {\n        this._connecting = false;\n        if (!data.error) {\n          this.isLoggedIn = true;\n          if ((_a = data.connected) === null || _a === void 0 ? void 0 : _a.publicKey) {\n            this._publicKey = new PublicKey(data.connected.publicKey);\n          }\n        }\n      } else if ([\"sendTransaction\", \"sendFinalTransaction\"].includes(data.type)) {\n        const transactionIdentifier = (_b = data.sendTransaction) === null || _b === void 0 ? void 0 : _b.identifier;\n        if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n          if (data.error) {\n            this._pendingTransactionErrors[transactionIdentifier] = {\n              message: data.error\n            };\n          } else {\n            this._pendingTransactions[transactionIdentifier] = data.sendTransaction || null;\n          }\n        }\n      } else if (data.type == \"signTransaction\") {\n        const transactionIdentifier = (_c = data.signTransaction) === null || _c === void 0 ? void 0 : _c.identifier;\n        if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n          if (data.error) {\n            this._pendingTransactionErrors[transactionIdentifier] = {\n              message: data.error\n            };\n          } else {\n            this._pendingTransactions[transactionIdentifier] = data.signTransaction || null;\n          }\n        }\n      }\n    };\n    this.isLoggedIn = false;\n    this._pendingTransactions = {};\n    this._pendingTransactionErrors = {};\n    this._timers = [];\n    this._wallet = null;\n    this._connecting = false;\n    this._publicKey = null;\n    window.addEventListener(\"message\", e => {\n      this.handleWalletMessage(e.data);\n    });\n  }\n  async connect(url) {\n    try {\n      this.url = url || this.url;\n      const origin = encodeURIComponent(window.location.origin);\n      const connectUrl = `${this.url}/connect?origin=${origin}`;\n      this._connecting = true;\n      this._wallet = window.open(connectUrl, `censo-custody-${origin}`, \"height=900,width=800,menubar=no,status=no,toolbar=no\");\n      if (!this._wallet) {\n        this._connecting = false;\n        throw new Error(\"Unable to connect to wallet\");\n      }\n      this._timers.push(window.setInterval(() => {\n        if (this._wallet.closed) {\n          this.cleanUp();\n        } else if (this._wallet) {\n          this._wallet.postMessage({\n            type: 'heartbeat'\n          }, this.url);\n        }\n      }, 100));\n      return new Promise((resolve, reject) => {\n        const timer = window.setInterval(() => {\n          if (this.isLoggedIn && this._publicKey) {\n            this.clearTimer(timer);\n            resolve(this._publicKey);\n          } else if (!this.isLoggedIn && !this._connecting) {\n            this.clearTimer(timer);\n            reject(new Error(\"Unable to connect to Censo\"));\n          }\n        }, 100);\n        this._timers.push(timer);\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n  async signTransaction(transaction) {\n    this.verifyCanSignRequests([transaction]);\n    try {\n      return this.signOneTransaction(transaction);\n    } catch (error) {\n      throw error;\n    }\n  }\n  async signAllTransactions(transactions) {\n    this.verifyCanSignRequests(transactions);\n    try {\n      return this.signMultipleTransactions(transactions);\n    } catch (error) {\n      throw error;\n    }\n  }\n  async sendTransaction(transaction, connection, options) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new Error(\"Not Connected\");\n      const transactionIdentifier = uuidv4();\n      this._pendingTransactions[transactionIdentifier] = null;\n      const signers = options ? options.signers : undefined;\n      if (signers && signers.length > 0) {\n        return new Promise((resolve, reject) => {\n          this.signOneTransaction(transaction, transactionIdentifier).then(walletTransaction => {\n            this._pendingTransactions[transactionIdentifier] = null;\n            (signers === null || signers === void 0 ? void 0 : signers.length) && walletTransaction.partialSign(...signers);\n            wallet.postMessage({\n              type: \"sendFinalTransaction\",\n              sendFinalTransaction: {\n                transactionIdentifier,\n                signaturePubkeyPairs: walletTransaction.signatures.filter(sp => sp.signature != null).map(sp => {\n                  return {\n                    'pubkey': sp.publicKey.toBase58(),\n                    'signature': sp.signature.toString('base64')\n                  };\n                })\n              }\n            }, this.url);\n            const timer = window.setInterval(() => {\n              const pendingTransaction = this._pendingTransactions[transactionIdentifier];\n              const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier];\n              if (pendingTransaction != null || pendingTransactionError != null) {\n                this.clearTimer(timer);\n                pendingTransaction && resolve(pendingTransaction.signature);\n                pendingTransactionError && reject(pendingTransactionError);\n              }\n            }, 100);\n            this._timers.push(timer);\n          }).catch(error => {\n            reject(error);\n            throw error;\n          });\n        });\n      } else {\n        const instructions = this.instructionsToSerializableInstructions(transaction.instructions);\n        return new Promise((resolve, reject) => {\n          wallet.postMessage({\n            type: \"sendTransaction\",\n            sendTransaction: {\n              instructions,\n              transactionIdentifier\n            }\n          }, this.url);\n          const timer = window.setInterval(() => {\n            const pendingTransaction = this._pendingTransactions[transactionIdentifier];\n            const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier];\n            if (pendingTransaction != null || pendingTransactionError != null) {\n              this.clearTimer(timer);\n              pendingTransaction && resolve(pendingTransaction.signature);\n              pendingTransactionError && reject(pendingTransactionError);\n            }\n          }, 100);\n          this._timers.push(timer);\n        });\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n  buildTransaction(pendingTransaction) {\n    let message = Message.from(Buffer.from(Uint8Array.from(window.atob(pendingTransaction.message), c => c.charCodeAt(0))));\n    return Transaction.populate(message, Array.from({\n      length: message.header.numRequiredSignatures\n    }, (_v, i) => {\n      let sigPubkeyPair = pendingTransaction.signatures.find(s => s.pubkey == message.accountKeys[i].toBase58());\n      return bs58.encode(sigPubkeyPair ? Buffer.from(Uint8Array.from(window.atob(sigPubkeyPair.signature), c => c.charCodeAt(0))) : DEFAULT_SIGNATURE_BUFFER);\n    }));\n  }\n  verifyCanSignRequests(transactions) {\n    transactions.forEach(transaction => {\n      if (transaction.signatures.some(s => s.signature != null)) {\n        throw new Error(\"Censo does not support this signing mode\");\n      }\n    });\n  }\n  signOneTransaction(transaction, transactionIdentifier = uuidv4()) {\n    const wallet = this._wallet;\n    if (!wallet) throw new Error(\"Not Connected\");\n    const instructions = this.instructionsToSerializableInstructions(transaction.instructions);\n    this._pendingTransactions[transactionIdentifier] = null;\n    return new Promise((resolve, reject) => {\n      wallet.postMessage({\n        type: \"signTransaction\",\n        signTransaction: {\n          instructions,\n          transactionIdentifier\n        }\n      }, this.url);\n      const timer = window.setInterval(() => {\n        const pendingTransaction = this._pendingTransactions[transactionIdentifier];\n        const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier];\n        if (pendingTransaction != null || pendingTransactionError != null) {\n          this.clearTimer(timer);\n          pendingTransaction && resolve(this.buildTransaction(pendingTransaction));\n          pendingTransactionError && reject(pendingTransactionError);\n        }\n      }, 100);\n      this._timers.push(timer);\n    });\n  }\n  signMultipleTransactions(transactions) {\n    const wallet = this._wallet;\n    if (!wallet) throw new Error(\"Not Connected\");\n    const serializedTransactions = transactions.map(t => {\n      return {\n        instructions: this.instructionsToSerializableInstructions(t.instructions),\n        transactionIdentifier: uuidv4()\n      };\n    });\n    const transactionIdentifiers = serializedTransactions.map(t => t.transactionIdentifier);\n    transactionIdentifiers.forEach(transactionIdentifier => this._pendingTransactions[transactionIdentifier] = null);\n    return new Promise((resolve, reject) => {\n      wallet.postMessage({\n        type: \"signAllTransactions\",\n        signAllTransactions: {\n          transactions: serializedTransactions\n        }\n      }, this.url);\n      const timer = window.setInterval(() => {\n        const pendingTransactions = transactionIdentifiers.map(txId => this._pendingTransactions[txId]);\n        const pendingTransactionErrors = transactionIdentifiers.map(txId => this._pendingTransactionErrors[txId]);\n        if (pendingTransactions.every(t => t != null)) {\n          this.clearTimer(timer);\n          resolve(pendingTransactions.map(pt => this.buildTransaction(pt)));\n        } else if (pendingTransactionErrors.some(e => e != null)) {\n          this.clearTimer(timer);\n          reject(pendingTransactionErrors.find(e => e != null));\n        }\n      }, 100);\n      this._timers.push(timer);\n    });\n  }\n}","map":{"version":3,"names":["Message","PublicKey","SIGNATURE_LENGTH_IN_BYTES","Transaction","bs58","v4","uuidv4","EventEmitter","DEFAULT_SIGNATURE_BUFFER","Buffer","alloc","fill","CensoWallet","constructor","url","cleanUp","_timers","forEach","t","clearTimer","wallet","_wallet","close","emit","timer","filter","window","clearInterval","instructionsToSerializableInstructions","instructions","map","i","programId","toBase58","keys","k","address","pubkey","signer","isSigner","writable","isWritable","btoa","String","fromCharCode","data","handleWalletMessage","type","_connecting","error","isLoggedIn","_a","connected","publicKey","_publicKey","includes","transactionIdentifier","_b","sendTransaction","identifier","_pendingTransactions","_pendingTransactionErrors","message","_c","signTransaction","addEventListener","e","connect","origin","encodeURIComponent","location","connectUrl","open","Error","push","setInterval","closed","postMessage","Promise","resolve","reject","transaction","verifyCanSignRequests","signOneTransaction","signAllTransactions","transactions","signMultipleTransactions","connection","options","signers","undefined","length","then","walletTransaction","partialSign","sendFinalTransaction","signaturePubkeyPairs","signatures","sp","signature","toString","pendingTransaction","pendingTransactionError","catch","buildTransaction","from","Uint8Array","atob","c","charCodeAt","populate","Array","header","numRequiredSignatures","_v","sigPubkeyPair","find","s","accountKeys","encode","some","serializedTransactions","transactionIdentifiers","pendingTransactions","txId","pendingTransactionErrors","every","pt"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@censo-custody/solana-wallet-adapter/src/censocustody.ts"],"sourcesContent":["\nimport {\n    Blockhash, Connection, Message,\n    PublicKey,\n    SIGNATURE_LENGTH_IN_BYTES, Signer, Transaction,\n    TransactionInstruction,\n    TransactionSignature\n} from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\nimport {v4 as uuidv4} from \"uuid\";\nimport { EventEmitter } from \"eventemitter3\";\n\n\ninterface Connected {\n    publicKey: PublicKey;\n}\n\ninterface SendTransaction {\n    identifier: string;\n    signature: TransactionSignature;\n}\n\ninterface SerializableSignaturePubkeyPair {\n    signature: string;\n    pubkey: string;\n}\n\ninterface SignTransaction {\n    identifier: string;\n    signatures: SerializableSignaturePubkeyPair[];\n    feePayer: string;\n    recentBlockhash: Blockhash;\n    message: string;\n}\n\ninterface CensoWalletMessage {\n    type: 'connected' | 'sendTransaction' | 'signTransaction';\n    error?: string;\n    connected?: Connected;\n    sendTransaction?: SendTransaction;\n    signTransaction?: SignTransaction;\n}\n\ninterface TransactionError {\n    message: string\n}\n\ninterface PendingTransactions {\n    [hash: string]: SendTransaction | SignTransaction | null\n}\n\ninterface PendingTransactionErrors {\n    [hash: string]: TransactionError | null\n}\n\ninterface SerializableInstruction {\n    data: string,\n    accountMetas: {address: string, signer: boolean, writable: boolean}[],\n    programId: string\n}\n\nconst DEFAULT_SIGNATURE_BUFFER = Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0)\n\nexport interface SignerOptions {\n    signers?: Signer[];\n}\n\nexport class CensoWallet extends EventEmitter {\n    isLoggedIn: boolean;\n    url = 'https://wallet.censocustody.com';\n    private _pendingTransactions: PendingTransactions;\n    private _pendingTransactionErrors: PendingTransactionErrors;\n    private _timers: number[];\n    private _wallet: Window | null;\n    private _connecting: boolean;\n    private _publicKey: PublicKey | null;\n\n    constructor() {\n        super()\n        this.isLoggedIn = false\n        this._pendingTransactions = {}\n        this._pendingTransactionErrors = {}\n        this._timers = []\n        this._wallet = null;\n        this._connecting = false\n        this._publicKey = null\n\n        window.addEventListener(\"message\", (e) => {\n            this.handleWalletMessage(e.data as CensoWalletMessage)\n        })\n    }\n\n    async connect(url: string | null): Promise<PublicKey> {\n        try {\n            this.url = url || this.url\n            const origin = encodeURIComponent(window.location.origin);\n            const connectUrl = `${this.url}/connect?origin=${origin}`;\n            this._connecting = true\n            this._wallet = window.open(connectUrl, `censo-custody-${origin}`, \"height=900,width=800,menubar=no,status=no,toolbar=no\");\n            if (!this._wallet) {\n                this._connecting = false\n                throw new Error(\"Unable to connect to wallet\")\n            }\n            this._timers.push(window.setInterval(() => {\n                if (this._wallet!.closed) {\n                    this.cleanUp();\n                } else if (this._wallet) {\n                    this._wallet.postMessage({type: 'heartbeat'}, this.url)\n                }\n            }, 100));\n            return new Promise<PublicKey>((resolve, reject) => {\n                const timer = window.setInterval(() => {\n                    if (this.isLoggedIn && this._publicKey) {\n                        this.clearTimer(timer);\n                        resolve(this._publicKey!)\n                    } else if (!this.isLoggedIn && !this._connecting) {\n                        this.clearTimer(timer);\n                        reject(new Error(\"Unable to connect to Censo\"))\n                    }\n                }, 100);\n                this._timers.push(timer)\n            })\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public cleanUp = () => {\n        [...this._timers].forEach(t => this.clearTimer(t));\n        const wallet = this._wallet;\n        if (wallet) {\n            wallet.close()\n        }\n        this._wallet = null\n        this.emit('disconnected')\n    }\n\n    public async signTransaction(transaction: Transaction): Promise<Transaction> {\n        this.verifyCanSignRequests([transaction])\n        try {\n            return this.signOneTransaction(transaction);\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public async signAllTransactions(transactions: Transaction[]): Promise<Transaction[]> {\n        this.verifyCanSignRequests(transactions)\n        try {\n            return this.signMultipleTransactions(transactions);\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public async sendTransaction(\n        transaction: Transaction,\n        connection: Connection,\n        options?: SignerOptions,\n    ): Promise<TransactionSignature> {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new Error(\"Not Connected\");\n\n            const transactionIdentifier = uuidv4()\n            this._pendingTransactions[transactionIdentifier] = null;\n            const signers = options ? options.signers : undefined;\n\n            if (signers && signers!.length > 0) {\n                return new Promise<TransactionSignature>((resolve, reject) => {\n                    this.signOneTransaction(transaction, transactionIdentifier).then(walletTransaction => {\n                        this._pendingTransactions[transactionIdentifier] = null\n                        signers?.length && walletTransaction.partialSign(...signers);\n                        wallet.postMessage({\n                            type: \"sendFinalTransaction\", sendFinalTransaction: {\n                                transactionIdentifier,\n                                signaturePubkeyPairs: walletTransaction.signatures.filter(sp => sp.signature != null).map(sp => {\n                                    return {\n                                        'pubkey': sp.publicKey.toBase58(),\n                                        'signature': sp.signature!.toString('base64')\n                                    }\n                                })\n                            }\n                        }, this.url);\n                        const timer = window.setInterval(() => {\n                            const pendingTransaction = this._pendingTransactions[transactionIdentifier] as SendTransaction\n                            const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier]\n                            if (pendingTransaction != null || pendingTransactionError != null) {\n                                this.clearTimer(timer);\n                                pendingTransaction && resolve(pendingTransaction.signature)\n                                pendingTransactionError && reject(pendingTransactionError)\n                            }\n                        }, 100);\n                        this._timers.push(timer)\n                    }).catch((error) => {\n                        reject(error)\n                        throw error;\n                    })\n                })\n            } else {\n                const instructions = this.instructionsToSerializableInstructions(transaction.instructions)\n                return new Promise<TransactionSignature>((resolve, reject) => {\n                    wallet.postMessage({\n                        type: \"sendTransaction\",\n                        sendTransaction: { instructions, transactionIdentifier }\n                    }, this.url);\n                    const timer = window.setInterval(() => {\n                        const pendingTransaction = this._pendingTransactions[transactionIdentifier] as SendTransaction\n                        const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier]\n                        if (pendingTransaction != null || pendingTransactionError != null) {\n                            this.clearTimer(timer);\n                            pendingTransaction && resolve(pendingTransaction.signature)\n                            pendingTransactionError && reject(pendingTransactionError)\n                        }\n                    }, 100);\n                    this._timers.push(timer)\n                })\n            }\n        } catch (error) {\n            throw error;\n        }\n    }\n\n\n    private clearTimer = (timer: number) => {\n        this._timers = this._timers.filter(t => t != timer)\n        window.clearInterval(timer);\n    }\n\n    private instructionsToSerializableInstructions = (instructions: TransactionInstruction[]): SerializableInstruction[] => instructions.map(i => {\n        return {\n            'programId': i.programId.toBase58(),\n            'accountMetas': i.keys.map(k => {\n                return {\n                    address: k.pubkey.toBase58(),\n                    signer: k.isSigner,\n                    writable: k.isWritable,\n                }\n            }),\n            'data': window.btoa(String.fromCharCode(...i.data)),\n        }\n    })\n\n    private buildTransaction(pendingTransaction: SignTransaction): Transaction {\n        let message = Message.from(Buffer.from(Uint8Array.from(window.atob(pendingTransaction.message!), c => c.charCodeAt(0))))\n        return Transaction.populate(\n            message,\n            Array.from({length: message.header.numRequiredSignatures}, (_v, i) => {\n                let sigPubkeyPair = pendingTransaction.signatures.find(s => s.pubkey == message.accountKeys[i].toBase58())\n                return bs58.encode(sigPubkeyPair\n                    ? Buffer.from(Uint8Array.from(window.atob(sigPubkeyPair.signature), c => c.charCodeAt(0)))\n                    : DEFAULT_SIGNATURE_BUFFER\n                )\n            })\n        )\n    }\n\n    private verifyCanSignRequests(transactions: Transaction[]) {\n        transactions.forEach(transaction => {\n            if (transaction.signatures.some(s => s.signature != null)) {\n                throw new Error(\"Censo does not support this signing mode\")\n            }\n        })\n    }\n\n    private signOneTransaction(transaction: Transaction, transactionIdentifier = uuidv4()): Promise<Transaction> {\n        const wallet = this._wallet;\n        if (!wallet) throw new Error(\"Not Connected\");\n\n        const instructions = this.instructionsToSerializableInstructions(transaction.instructions)\n        this._pendingTransactions[transactionIdentifier] = null;\n        return new Promise<Transaction>((resolve, reject) => {\n            wallet.postMessage({type: \"signTransaction\", signTransaction: { instructions, transactionIdentifier }}, this.url);\n            const timer = window.setInterval(() => {\n                const pendingTransaction = this._pendingTransactions[transactionIdentifier] as SignTransaction\n                const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier]\n                if (pendingTransaction != null || pendingTransactionError != null) {\n                    this.clearTimer(timer)\n                    pendingTransaction && resolve(this.buildTransaction(pendingTransaction))\n                    pendingTransactionError &&  reject(pendingTransactionError)\n                }\n            }, 100);\n            this._timers.push(timer)\n        });\n    }\n\n    private signMultipleTransactions(transactions: Transaction[]): Promise<Transaction[]> {\n        const wallet = this._wallet;\n        if (!wallet) throw new Error(\"Not Connected\");\n\n        const serializedTransactions = transactions.map((t) => {\n            return {\n                instructions: this.instructionsToSerializableInstructions(t.instructions),\n                transactionIdentifier: uuidv4()\n            }\n        })\n        const transactionIdentifiers = serializedTransactions.map((t) => t.transactionIdentifier)\n        transactionIdentifiers.forEach((transactionIdentifier) => this._pendingTransactions[transactionIdentifier] = null)\n        return new Promise<Transaction[]>((resolve, reject) => {\n            wallet.postMessage({type: \"signAllTransactions\", signAllTransactions: {transactions: serializedTransactions}}, this.url);\n            const timer = window.setInterval(() => {\n                const pendingTransactions = transactionIdentifiers.map((txId) => this._pendingTransactions[txId] as SignTransaction)\n                const pendingTransactionErrors = transactionIdentifiers.map((txId) => this._pendingTransactionErrors[txId])\n                if (pendingTransactions.every((t) => t != null)) {\n                    this.clearTimer(timer)\n                    resolve(pendingTransactions.map((pt) => this.buildTransaction(pt)))\n                } else if (pendingTransactionErrors.some((e) => e != null)) {\n                    this.clearTimer(timer)\n                    reject(pendingTransactionErrors.find((e) => e != null))\n                }\n            }, 100);\n            this._timers.push(timer)\n        });\n    }\n\n    private handleWalletMessage = (data: CensoWalletMessage) => {\n        if (data.type == \"connected\") {\n            this._connecting = false;\n            if (!data.error) {\n                this.isLoggedIn = true;\n                if (data.connected?.publicKey) {\n                    this._publicKey = new PublicKey(data.connected.publicKey);\n                }\n            }\n        } else if ([\"sendTransaction\", \"sendFinalTransaction\"].includes(data.type)) {\n            const transactionIdentifier = data.sendTransaction?.identifier\n            if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n                if (data.error) {\n                    this._pendingTransactionErrors[transactionIdentifier] = {message: data.error};\n                } else {\n                    this._pendingTransactions[transactionIdentifier] = data.sendTransaction || null\n                }\n            }\n        } else if (data.type == \"signTransaction\") {\n            const transactionIdentifier = data.signTransaction?.identifier\n            if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n                if (data.error) {\n                    this._pendingTransactionErrors[transactionIdentifier] = {message: data.error}\n                } else {\n                    this._pendingTransactions[transactionIdentifier] = data.signTransaction || null\n                }\n            }\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}