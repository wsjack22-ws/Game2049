{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Address = void 0;\nconst account_1 = require(\"./account\");\nconst bytes_1 = require(\"./bytes\");\n/**\n * Handling and generating Ethereum addresses\n */\nclass Address {\n  constructor(buf) {\n    if (buf.length !== 20) {\n      throw new Error('Invalid address length');\n    }\n    this.buf = buf;\n  }\n  /**\n   * Returns the zero address.\n   */\n  static zero() {\n    return new Address((0, bytes_1.zeros)(20));\n  }\n  /**\n   * Returns an Address object from a hex-encoded string.\n   * @param str - Hex-encoded address\n   */\n  static fromString(str) {\n    if (!(0, account_1.isValidAddress)(str)) {\n      throw new Error('Invalid address');\n    }\n    return new Address((0, bytes_1.toBuffer)(str));\n  }\n  /**\n   * Returns an address for a given public key.\n   * @param pubKey The two points of an uncompressed key\n   */\n  static fromPublicKey(pubKey) {\n    if (!Buffer.isBuffer(pubKey)) {\n      throw new Error('Public key should be Buffer');\n    }\n    const buf = (0, account_1.pubToAddress)(pubKey);\n    return new Address(buf);\n  }\n  /**\n   * Returns an address for a given private key.\n   * @param privateKey A private key must be 256 bits wide\n   */\n  static fromPrivateKey(privateKey) {\n    if (!Buffer.isBuffer(privateKey)) {\n      throw new Error('Private key should be Buffer');\n    }\n    const buf = (0, account_1.privateToAddress)(privateKey);\n    return new Address(buf);\n  }\n  /**\n   * Generates an address for a newly created contract.\n   * @param from The address which is creating this new address\n   * @param nonce The nonce of the from account\n   */\n  static generate(from, nonce) {\n    if (typeof nonce !== 'bigint') {\n      throw new Error('Expected nonce to be a bigint');\n    }\n    return new Address((0, account_1.generateAddress)(from.buf, (0, bytes_1.bigIntToBuffer)(nonce)));\n  }\n  /**\n   * Generates an address for a contract created using CREATE2.\n   * @param from The address which is creating this new address\n   * @param salt A salt\n   * @param initCode The init code of the contract being created\n   */\n  static generate2(from, salt, initCode) {\n    if (!Buffer.isBuffer(salt)) {\n      throw new Error('Expected salt to be a Buffer');\n    }\n    if (!Buffer.isBuffer(initCode)) {\n      throw new Error('Expected initCode to be a Buffer');\n    }\n    return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n  }\n  /**\n   * Is address equal to another.\n   */\n  equals(address) {\n    return this.buf.equals(address.buf);\n  }\n  /**\n   * Is address zero.\n   */\n  isZero() {\n    return this.equals(Address.zero());\n  }\n  /**\n   * True if address is in the address range defined\n   * by EIP-1352\n   */\n  isPrecompileOrSystemAddress() {\n    const address = (0, bytes_1.bufferToBigInt)(this.buf);\n    const rangeMin = BigInt(0);\n    const rangeMax = BigInt('0xffff');\n    return address >= rangeMin && address <= rangeMax;\n  }\n  /**\n   * Returns hex encoding of address.\n   */\n  toString() {\n    return '0x' + this.buf.toString('hex');\n  }\n  /**\n   * Returns Buffer representation of address.\n   */\n  toBuffer() {\n    return Buffer.from(this.buf);\n  }\n}\nexports.Address = Address;","map":{"version":3,"names":["account_1","require","bytes_1","Address","constructor","buf","length","Error","zero","zeros","fromString","str","isValidAddress","toBuffer","fromPublicKey","pubKey","Buffer","isBuffer","pubToAddress","fromPrivateKey","privateKey","privateToAddress","generate","from","nonce","generateAddress","bigIntToBuffer","generate2","salt","initCode","generateAddress2","equals","address","isZero","isPrecompileOrSystemAddress","bufferToBigInt","rangeMin","BigInt","rangeMax","toString","exports"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@ethereumjs/util/src/address.ts"],"sourcesContent":["import {\n  generateAddress,\n  generateAddress2,\n  isValidAddress,\n  privateToAddress,\n  pubToAddress,\n} from './account'\nimport { bigIntToBuffer, bufferToBigInt, toBuffer, zeros } from './bytes'\n\n/**\n * Handling and generating Ethereum addresses\n */\nexport class Address {\n  public readonly buf: Buffer\n\n  constructor(buf: Buffer) {\n    if (buf.length !== 20) {\n      throw new Error('Invalid address length')\n    }\n    this.buf = buf\n  }\n\n  /**\n   * Returns the zero address.\n   */\n  static zero(): Address {\n    return new Address(zeros(20))\n  }\n\n  /**\n   * Returns an Address object from a hex-encoded string.\n   * @param str - Hex-encoded address\n   */\n  static fromString(str: string): Address {\n    if (!isValidAddress(str)) {\n      throw new Error('Invalid address')\n    }\n    return new Address(toBuffer(str))\n  }\n\n  /**\n   * Returns an address for a given public key.\n   * @param pubKey The two points of an uncompressed key\n   */\n  static fromPublicKey(pubKey: Buffer): Address {\n    if (!Buffer.isBuffer(pubKey)) {\n      throw new Error('Public key should be Buffer')\n    }\n    const buf = pubToAddress(pubKey)\n    return new Address(buf)\n  }\n\n  /**\n   * Returns an address for a given private key.\n   * @param privateKey A private key must be 256 bits wide\n   */\n  static fromPrivateKey(privateKey: Buffer): Address {\n    if (!Buffer.isBuffer(privateKey)) {\n      throw new Error('Private key should be Buffer')\n    }\n    const buf = privateToAddress(privateKey)\n    return new Address(buf)\n  }\n\n  /**\n   * Generates an address for a newly created contract.\n   * @param from The address which is creating this new address\n   * @param nonce The nonce of the from account\n   */\n  static generate(from: Address, nonce: bigint): Address {\n    if (typeof nonce !== 'bigint') {\n      throw new Error('Expected nonce to be a bigint')\n    }\n    return new Address(generateAddress(from.buf, bigIntToBuffer(nonce)))\n  }\n\n  /**\n   * Generates an address for a contract created using CREATE2.\n   * @param from The address which is creating this new address\n   * @param salt A salt\n   * @param initCode The init code of the contract being created\n   */\n  static generate2(from: Address, salt: Buffer, initCode: Buffer): Address {\n    if (!Buffer.isBuffer(salt)) {\n      throw new Error('Expected salt to be a Buffer')\n    }\n    if (!Buffer.isBuffer(initCode)) {\n      throw new Error('Expected initCode to be a Buffer')\n    }\n    return new Address(generateAddress2(from.buf, salt, initCode))\n  }\n\n  /**\n   * Is address equal to another.\n   */\n  equals(address: Address): boolean {\n    return this.buf.equals(address.buf)\n  }\n\n  /**\n   * Is address zero.\n   */\n  isZero(): boolean {\n    return this.equals(Address.zero())\n  }\n\n  /**\n   * True if address is in the address range defined\n   * by EIP-1352\n   */\n  isPrecompileOrSystemAddress(): boolean {\n    const address = bufferToBigInt(this.buf)\n    const rangeMin = BigInt(0)\n    const rangeMax = BigInt('0xffff')\n    return address >= rangeMin && address <= rangeMax\n  }\n\n  /**\n   * Returns hex encoding of address.\n   */\n  toString(): string {\n    return '0x' + this.buf.toString('hex')\n  }\n\n  /**\n   * Returns Buffer representation of address.\n   */\n  toBuffer(): Buffer {\n    return Buffer.from(this.buf)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}