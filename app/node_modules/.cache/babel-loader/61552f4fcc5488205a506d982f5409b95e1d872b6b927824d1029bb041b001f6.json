{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.remove0x = exports.add0x = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isStrictHexString = exports.isHexString = exports.StrictHexStruct = exports.HexStruct = void 0;\nconst superstruct_1 = require(\"superstruct\");\nconst assert_1 = require(\"./assert\");\nexports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:0x)?[0-9a-f]+$/iu);\nexports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]+$/iu);\n/**\n * Check if a string is a valid hex string.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nfunction isHexString(value) {\n  return (0, superstruct_1.is)(value, exports.HexStruct);\n}\nexports.isHexString = isHexString;\n/**\n * Strictly check if a string is a valid hex string. A valid hex string must\n * start with the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nfunction isStrictHexString(value) {\n  return (0, superstruct_1.is)(value, exports.StrictHexStruct);\n}\nexports.isStrictHexString = isStrictHexString;\n/**\n * Assert that a value is a valid hex string.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nfunction assertIsHexString(value) {\n  (0, assert_1.assert)(isHexString(value), 'Value must be a hexadecimal string.');\n}\nexports.assertIsHexString = assertIsHexString;\n/**\n * Assert that a value is a valid hex string. A valid hex string must start with\n * the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nfunction assertIsStrictHexString(value) {\n  (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with \"0x\".');\n}\nexports.assertIsStrictHexString = assertIsStrictHexString;\n/**\n * Add the `0x`-prefix to a hexadecimal string. If the string already has the\n * prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to add the prefix to.\n * @returns The prefixed hexadecimal string.\n */\nfunction add0x(hexadecimal) {\n  if (hexadecimal.startsWith('0x')) {\n    return hexadecimal;\n  }\n  if (hexadecimal.startsWith('0X')) {\n    return `0x${hexadecimal.substring(2)}`;\n  }\n  return `0x${hexadecimal}`;\n}\nexports.add0x = add0x;\n/**\n * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have\n * the prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to remove the prefix from.\n * @returns The un-prefixed hexadecimal string.\n */\nfunction remove0x(hexadecimal) {\n  if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {\n    return hexadecimal.substring(2);\n  }\n  return hexadecimal;\n}\nexports.remove0x = remove0x;","map":{"version":3,"names":["superstruct_1","require","assert_1","exports","HexStruct","pattern","string","StrictHexStruct","isHexString","value","is","isStrictHexString","assertIsHexString","assert","assertIsStrictHexString","add0x","hexadecimal","startsWith","substring","remove0x"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@metamask/utils/src/hex.ts"],"sourcesContent":["import { is, pattern, string, Struct } from 'superstruct';\n\nimport { assert } from './assert';\n\nexport type Hex = `0x${string}`;\n\nexport const HexStruct = pattern(string(), /^(?:0x)?[0-9a-f]+$/iu);\nexport const StrictHexStruct = pattern(string(), /^0x[0-9a-f]+$/iu) as Struct<\n  Hex,\n  null\n>;\n\n/**\n * Check if a string is a valid hex string.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nexport function isHexString(value: unknown): value is string {\n  return is(value, HexStruct);\n}\n\n/**\n * Strictly check if a string is a valid hex string. A valid hex string must\n * start with the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nexport function isStrictHexString(value: unknown): value is Hex {\n  return is(value, StrictHexStruct);\n}\n\n/**\n * Assert that a value is a valid hex string.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nexport function assertIsHexString(value: unknown): asserts value is string {\n  assert(isHexString(value), 'Value must be a hexadecimal string.');\n}\n\n/**\n * Assert that a value is a valid hex string. A valid hex string must start with\n * the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nexport function assertIsStrictHexString(value: unknown): asserts value is Hex {\n  assert(\n    isStrictHexString(value),\n    'Value must be a hexadecimal string, starting with \"0x\".',\n  );\n}\n\n/**\n * Add the `0x`-prefix to a hexadecimal string. If the string already has the\n * prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to add the prefix to.\n * @returns The prefixed hexadecimal string.\n */\nexport function add0x(hexadecimal: string): Hex {\n  if (hexadecimal.startsWith('0x')) {\n    return hexadecimal as Hex;\n  }\n\n  if (hexadecimal.startsWith('0X')) {\n    return `0x${hexadecimal.substring(2)}`;\n  }\n\n  return `0x${hexadecimal}`;\n}\n\n/**\n * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have\n * the prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to remove the prefix from.\n * @returns The un-prefixed hexadecimal string.\n */\nexport function remove0x(hexadecimal: string): string {\n  if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {\n    return hexadecimal.substring(2);\n  }\n\n  return hexadecimal;\n}\n"],"mappings":";;;;;;AAAA,MAAAA,aAAA,GAAAC,OAAA;AAEA,MAAAC,QAAA,GAAAD,OAAA;AAIaE,OAAA,CAAAC,SAAS,GAAG,IAAAJ,aAAA,CAAAK,OAAO,EAAC,IAAAL,aAAA,CAAAM,MAAM,GAAE,EAAE,sBAAsB,CAAC;AACrDH,OAAA,CAAAI,eAAe,GAAG,IAAAP,aAAA,CAAAK,OAAO,EAAC,IAAAL,aAAA,CAAAM,MAAM,GAAE,EAAE,iBAAiB,CAGjE;AAED;;;;;;AAMA,SAAgBE,WAAWA,CAACC,KAAc;EACxC,OAAO,IAAAT,aAAA,CAAAU,EAAE,EAACD,KAAK,EAAEN,OAAA,CAAAC,SAAS,CAAC;AAC7B;AAFAD,OAAA,CAAAK,WAAA,GAAAA,WAAA;AAIA;;;;;;;AAOA,SAAgBG,iBAAiBA,CAACF,KAAc;EAC9C,OAAO,IAAAT,aAAA,CAAAU,EAAE,EAACD,KAAK,EAAEN,OAAA,CAAAI,eAAe,CAAC;AACnC;AAFAJ,OAAA,CAAAQ,iBAAA,GAAAA,iBAAA;AAIA;;;;;;AAMA,SAAgBC,iBAAiBA,CAACH,KAAc;EAC9C,IAAAP,QAAA,CAAAW,MAAM,EAACL,WAAW,CAACC,KAAK,CAAC,EAAE,qCAAqC,CAAC;AACnE;AAFAN,OAAA,CAAAS,iBAAA,GAAAA,iBAAA;AAIA;;;;;;;AAOA,SAAgBE,uBAAuBA,CAACL,KAAc;EACpD,IAAAP,QAAA,CAAAW,MAAM,EACJF,iBAAiB,CAACF,KAAK,CAAC,EACxB,yDAAyD,CAC1D;AACH;AALAN,OAAA,CAAAW,uBAAA,GAAAA,uBAAA;AAOA;;;;;;;AAOA,SAAgBC,KAAKA,CAACC,WAAmB;EACvC,IAAIA,WAAW,CAACC,UAAU,CAAC,IAAI,CAAC,EAAE;IAChC,OAAOD,WAAkB;;EAG3B,IAAIA,WAAW,CAACC,UAAU,CAAC,IAAI,CAAC,EAAE;IAChC,OAAO,KAAKD,WAAW,CAACE,SAAS,CAAC,CAAC,CAAC,EAAE;;EAGxC,OAAO,KAAKF,WAAW,EAAE;AAC3B;AAVAb,OAAA,CAAAY,KAAA,GAAAA,KAAA;AAYA;;;;;;;AAOA,SAAgBI,QAAQA,CAACH,WAAmB;EAC1C,IAAIA,WAAW,CAACC,UAAU,CAAC,IAAI,CAAC,IAAID,WAAW,CAACC,UAAU,CAAC,IAAI,CAAC,EAAE;IAChE,OAAOD,WAAW,CAACE,SAAS,CAAC,CAAC,CAAC;;EAGjC,OAAOF,WAAW;AACpB;AANAb,OAAA,CAAAgB,QAAA,GAAAA,QAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}