{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AccountClient = void 0;\nconst camelcase_1 = __importDefault(require(\"camelcase\"));\nconst eventemitter3_1 = __importDefault(require(\"eventemitter3\"));\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst provider_js_1 = require(\"../../provider.js\");\nconst index_js_1 = require(\"../../coder/index.js\");\nconst common_js_1 = require(\"../common.js\");\nconst pubkeyUtil = __importStar(require(\"../../utils/pubkey.js\"));\nconst rpcUtil = __importStar(require(\"../../utils/rpc.js\"));\nclass AccountFactory {\n  static build(idl, coder, programId, provider) {\n    var _a;\n    const accountFns = {};\n    (_a = idl.accounts) === null || _a === void 0 ? void 0 : _a.forEach(idlAccount => {\n      const name = (0, camelcase_1.default)(idlAccount.name);\n      accountFns[name] = new AccountClient(idl, idlAccount, programId, provider, coder);\n    });\n    return accountFns;\n  }\n}\nexports.default = AccountFactory;\nclass AccountClient {\n  constructor(idl, idlAccount, programId, provider, coder) {\n    this._idlAccount = idlAccount;\n    this._programId = programId;\n    this._provider = provider !== null && provider !== void 0 ? provider : (0, provider_js_1.getProvider)();\n    this._coder = coder !== null && coder !== void 0 ? coder : new index_js_1.BorshCoder(idl);\n    this._size = this._coder.accounts.size(idlAccount);\n  }\n  /**\n   * Returns the number of bytes in this account.\n   */\n  get size() {\n    return this._size;\n  }\n  /**\n   * Returns the program ID owning all accounts.\n   */\n  get programId() {\n    return this._programId;\n  }\n  /**\n   * Returns the client's wallet and network provider.\n   */\n  get provider() {\n    return this._provider;\n  }\n  /**\n   * Returns the coder.\n   */\n  get coder() {\n    return this._coder;\n  }\n  /**\n   * Returns a deserialized account, returning null if it doesn't exist.\n   *\n   * @param address The address of the account to fetch.\n   */\n  async fetchNullable(address, commitment) {\n    const accountInfo = await this.getAccountInfo(address, commitment);\n    if (accountInfo === null) {\n      return null;\n    }\n    return this._coder.accounts.decode(this._idlAccount.name, accountInfo.data);\n  }\n  /**\n   * Returns a deserialized account.\n   *\n   * @param address The address of the account to fetch.\n   */\n  async fetch(address, commitment) {\n    const data = await this.fetchNullable(address, commitment);\n    if (data === null) {\n      throw new Error(`Account does not exist ${address.toString()}`);\n    }\n    return data;\n  }\n  /**\n   * Returns multiple deserialized accounts.\n   * Accounts not found or with wrong discriminator are returned as null.\n   *\n   * @param addresses The addresses of the accounts to fetch.\n   */\n  async fetchMultiple(addresses, commitment) {\n    const accounts = await rpcUtil.getMultipleAccounts(this._provider.connection, addresses.map(address => (0, common_js_1.translateAddress)(address)), commitment);\n    // Decode accounts where discriminator is correct, null otherwise\n    return accounts.map(account => {\n      if (account == null) {\n        return null;\n      }\n      return this._coder.accounts.decode(this._idlAccount.name, account === null || account === void 0 ? void 0 : account.account.data);\n    });\n  }\n  /**\n   * Returns all instances of this account type for the program.\n   *\n   * @param filters User-provided filters to narrow the results from `connection.getProgramAccounts`.\n   *\n   *                When filters are not defined this method returns all\n   *                the account instances.\n   *\n   *                When filters are of type `Buffer`, the filters are appended\n   *                after the discriminator.\n   *\n   *                When filters are of type `GetProgramAccountsFilter[]`,\n   *                filters are appended after the discriminator filter.\n   */\n  async all(filters) {\n    let resp = await this._provider.connection.getProgramAccounts(this._programId, {\n      commitment: this._provider.connection.commitment,\n      filters: [{\n        memcmp: this.coder.accounts.memcmp(this._idlAccount.name, filters instanceof Buffer ? filters : undefined)\n      }, ...(Array.isArray(filters) ? filters : [])]\n    });\n    return resp.map(({\n      pubkey,\n      account\n    }) => {\n      return {\n        publicKey: pubkey,\n        account: this._coder.accounts.decode(this._idlAccount.name, account.data)\n      };\n    });\n  }\n  /**\n   * Returns an `EventEmitter` emitting a \"change\" event whenever the account\n   * changes.\n   */\n  subscribe(address, commitment) {\n    const sub = subscriptions.get(address.toString());\n    if (sub) {\n      return sub.ee;\n    }\n    const ee = new eventemitter3_1.default();\n    address = (0, common_js_1.translateAddress)(address);\n    const listener = this._provider.connection.onAccountChange(address, acc => {\n      const account = this._coder.accounts.decode(this._idlAccount.name, acc.data);\n      ee.emit(\"change\", account);\n    }, commitment);\n    subscriptions.set(address.toString(), {\n      ee,\n      listener\n    });\n    return ee;\n  }\n  /**\n   * Unsubscribes from the account at the given address.\n   */\n  async unsubscribe(address) {\n    let sub = subscriptions.get(address.toString());\n    if (!sub) {\n      console.warn(\"Address is not subscribed\");\n      return;\n    }\n    if (subscriptions) {\n      await this._provider.connection.removeAccountChangeListener(sub.listener).then(() => {\n        subscriptions.delete(address.toString());\n      }).catch(console.error);\n    }\n  }\n  /**\n   * Returns an instruction for creating this account.\n   */\n  async createInstruction(signer, sizeOverride) {\n    const size = this.size;\n    // @ts-expect-error\n    if (this._provider.wallet === undefined) {\n      throw new Error(\"This function requires the Provider interface implementor to have a 'wallet' field.\");\n    }\n    return web3_js_1.SystemProgram.createAccount({\n      // @ts-expect-error\n      fromPubkey: this._provider.wallet.publicKey,\n      newAccountPubkey: signer.publicKey,\n      space: sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size,\n      lamports: await this._provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size),\n      programId: this._programId\n    });\n  }\n  /**\n   * @deprecated since version 14.0.\n   *\n   * Function returning the associated account. Args are keys to associate.\n   * Order matters.\n   */\n  async associated(...args) {\n    const addr = await this.associatedAddress(...args);\n    return await this.fetch(addr);\n  }\n  /**\n   * @deprecated since version 14.0.\n   *\n   * Function returning the associated address. Args are keys to associate.\n   * Order matters.\n   */\n  async associatedAddress(...args) {\n    return await pubkeyUtil.associated(this._programId, ...args);\n  }\n  async getAccountInfo(address, commitment) {\n    return await this._provider.connection.getAccountInfo((0, common_js_1.translateAddress)(address), commitment);\n  }\n}\nexports.AccountClient = AccountClient;\n// Tracks all subscriptions.\nconst subscriptions = new Map();","map":{"version":3,"names":["camelcase_1","__importDefault","require","eventemitter3_1","web3_js_1","provider_js_1","index_js_1","common_js_1","pubkeyUtil","__importStar","rpcUtil","AccountFactory","build","idl","coder","programId","provider","accountFns","_a","accounts","forEach","idlAccount","name","default","AccountClient","exports","constructor","_idlAccount","_programId","_provider","getProvider","_coder","BorshCoder","_size","size","fetchNullable","address","commitment","accountInfo","getAccountInfo","decode","data","fetch","Error","toString","fetchMultiple","addresses","getMultipleAccounts","connection","map","translateAddress","account","all","filters","resp","getProgramAccounts","memcmp","Buffer","undefined","Array","isArray","pubkey","publicKey","subscribe","sub","subscriptions","get","ee","listener","onAccountChange","acc","emit","set","unsubscribe","console","warn","removeAccountChangeListener","then","delete","catch","error","createInstruction","signer","sizeOverride","wallet","SystemProgram","createAccount","fromPubkey","newAccountPubkey","space","lamports","getMinimumBalanceForRentExemption","associated","args","addr","associatedAddress","Map"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/program/namespace/account.ts"],"sourcesContent":["import camelCase from \"camelcase\";\nimport EventEmitter from \"eventemitter3\";\nimport {\n  Signer,\n  PublicKey,\n  SystemProgram,\n  TransactionInstruction,\n  Commitment,\n  GetProgramAccountsFilter,\n  AccountInfo,\n} from \"@solana/web3.js\";\nimport Provider, { getProvider } from \"../../provider.js\";\nimport { Idl, IdlAccountDef } from \"../../idl.js\";\nimport { Coder, BorshCoder } from \"../../coder/index.js\";\nimport { Subscription, Address, translateAddress } from \"../common.js\";\nimport { AllAccountsMap, IdlTypes, TypeDef } from \"./types.js\";\nimport * as pubkeyUtil from \"../../utils/pubkey.js\";\nimport * as rpcUtil from \"../../utils/rpc.js\";\n\nexport default class AccountFactory {\n  public static build<IDL extends Idl>(\n    idl: IDL,\n    coder: Coder,\n    programId: PublicKey,\n    provider?: Provider\n  ): AccountNamespace<IDL> {\n    const accountFns: AccountNamespace = {};\n\n    idl.accounts?.forEach((idlAccount) => {\n      const name = camelCase(idlAccount.name);\n      accountFns[name] = new AccountClient<IDL>(\n        idl,\n        idlAccount,\n        programId,\n        provider,\n        coder\n      );\n    });\n\n    return accountFns as AccountNamespace<IDL>;\n  }\n}\n\ntype NullableIdlAccount<IDL extends Idl> = IDL[\"accounts\"] extends undefined\n  ? IdlAccountDef\n  : NonNullable<IDL[\"accounts\"]>[number];\n\n/**\n * The namespace provides handles to an [[AccountClient]] object for each\n * account in a program.\n *\n * ## Usage\n *\n * ```javascript\n * account.<account-client>\n * ```\n *\n * ## Example\n *\n * To fetch a `Counter` account from the above example,\n *\n * ```javascript\n * const counter = await program.account.counter.fetch(address);\n * ```\n *\n * For the full API, see the [[AccountClient]] reference.\n */\nexport type AccountNamespace<IDL extends Idl = Idl> = {\n  [M in keyof AllAccountsMap<IDL>]: AccountClient<IDL>;\n};\n\nexport class AccountClient<\n  IDL extends Idl = Idl,\n  A extends NullableIdlAccount<IDL> = IDL[\"accounts\"] extends undefined\n    ? IdlAccountDef\n    : NonNullable<IDL[\"accounts\"]>[number],\n  T = TypeDef<A, IdlTypes<IDL>>\n> {\n  /**\n   * Returns the number of bytes in this account.\n   */\n  get size(): number {\n    return this._size;\n  }\n  private _size: number;\n\n  /**\n   * Returns the program ID owning all accounts.\n   */\n  get programId(): PublicKey {\n    return this._programId;\n  }\n  private _programId: PublicKey;\n\n  /**\n   * Returns the client's wallet and network provider.\n   */\n  get provider(): Provider {\n    return this._provider;\n  }\n  private _provider: Provider;\n\n  /**\n   * Returns the coder.\n   */\n  get coder(): Coder {\n    return this._coder;\n  }\n  private _coder: Coder;\n\n  private _idlAccount: A;\n\n  constructor(\n    idl: IDL,\n    idlAccount: A,\n    programId: PublicKey,\n    provider?: Provider,\n    coder?: Coder\n  ) {\n    this._idlAccount = idlAccount;\n    this._programId = programId;\n    this._provider = provider ?? getProvider();\n    this._coder = coder ?? new BorshCoder(idl);\n    this._size = this._coder.accounts.size(idlAccount);\n  }\n\n  /**\n   * Returns a deserialized account, returning null if it doesn't exist.\n   *\n   * @param address The address of the account to fetch.\n   */\n  async fetchNullable(\n    address: Address,\n    commitment?: Commitment\n  ): Promise<T | null> {\n    const accountInfo = await this.getAccountInfo(address, commitment);\n    if (accountInfo === null) {\n      return null;\n    }\n    return this._coder.accounts.decode<T>(\n      this._idlAccount.name,\n      accountInfo.data\n    );\n  }\n\n  /**\n   * Returns a deserialized account.\n   *\n   * @param address The address of the account to fetch.\n   */\n  async fetch(address: Address, commitment?: Commitment): Promise<T> {\n    const data = await this.fetchNullable(address, commitment);\n    if (data === null) {\n      throw new Error(`Account does not exist ${address.toString()}`);\n    }\n    return data;\n  }\n\n  /**\n   * Returns multiple deserialized accounts.\n   * Accounts not found or with wrong discriminator are returned as null.\n   *\n   * @param addresses The addresses of the accounts to fetch.\n   */\n  async fetchMultiple(\n    addresses: Address[],\n    commitment?: Commitment\n  ): Promise<(Object | null)[]> {\n    const accounts = await rpcUtil.getMultipleAccounts(\n      this._provider.connection,\n      addresses.map((address) => translateAddress(address)),\n      commitment\n    );\n\n    // Decode accounts where discriminator is correct, null otherwise\n    return accounts.map((account) => {\n      if (account == null) {\n        return null;\n      }\n      return this._coder.accounts.decode(\n        this._idlAccount.name,\n        account?.account.data\n      );\n    });\n  }\n\n  /**\n   * Returns all instances of this account type for the program.\n   *\n   * @param filters User-provided filters to narrow the results from `connection.getProgramAccounts`.\n   *\n   *                When filters are not defined this method returns all\n   *                the account instances.\n   *\n   *                When filters are of type `Buffer`, the filters are appended\n   *                after the discriminator.\n   *\n   *                When filters are of type `GetProgramAccountsFilter[]`,\n   *                filters are appended after the discriminator filter.\n   */\n  async all(\n    filters?: Buffer | GetProgramAccountsFilter[]\n  ): Promise<ProgramAccount<T>[]> {\n    let resp = await this._provider.connection.getProgramAccounts(\n      this._programId,\n      {\n        commitment: this._provider.connection.commitment,\n        filters: [\n          {\n            memcmp: this.coder.accounts.memcmp(\n              this._idlAccount.name,\n              filters instanceof Buffer ? filters : undefined\n            ),\n          },\n          ...(Array.isArray(filters) ? filters : []),\n        ],\n      }\n    );\n    return resp.map(({ pubkey, account }) => {\n      return {\n        publicKey: pubkey,\n        account: this._coder.accounts.decode(\n          this._idlAccount.name,\n          account.data\n        ),\n      };\n    });\n  }\n\n  /**\n   * Returns an `EventEmitter` emitting a \"change\" event whenever the account\n   * changes.\n   */\n  subscribe(address: Address, commitment?: Commitment): EventEmitter {\n    const sub = subscriptions.get(address.toString());\n    if (sub) {\n      return sub.ee;\n    }\n\n    const ee = new EventEmitter();\n    address = translateAddress(address);\n    const listener = this._provider.connection.onAccountChange(\n      address,\n      (acc) => {\n        const account = this._coder.accounts.decode(\n          this._idlAccount.name,\n          acc.data\n        );\n        ee.emit(\"change\", account);\n      },\n      commitment\n    );\n\n    subscriptions.set(address.toString(), {\n      ee,\n      listener,\n    });\n\n    return ee;\n  }\n\n  /**\n   * Unsubscribes from the account at the given address.\n   */\n  async unsubscribe(address: Address) {\n    let sub = subscriptions.get(address.toString());\n    if (!sub) {\n      console.warn(\"Address is not subscribed\");\n      return;\n    }\n    if (subscriptions) {\n      await this._provider.connection\n        .removeAccountChangeListener(sub.listener)\n        .then(() => {\n          subscriptions.delete(address.toString());\n        })\n        .catch(console.error);\n    }\n  }\n\n  /**\n   * Returns an instruction for creating this account.\n   */\n  async createInstruction(\n    signer: Signer,\n    sizeOverride?: number\n  ): Promise<TransactionInstruction> {\n    const size = this.size;\n\n    // @ts-expect-error\n    if (this._provider.wallet === undefined) {\n      throw new Error(\n        \"This function requires the Provider interface implementor to have a 'wallet' field.\"\n      );\n    }\n\n    return SystemProgram.createAccount({\n      // @ts-expect-error\n      fromPubkey: this._provider.wallet.publicKey,\n      newAccountPubkey: signer.publicKey,\n      space: sizeOverride ?? size,\n      lamports:\n        await this._provider.connection.getMinimumBalanceForRentExemption(\n          sizeOverride ?? size\n        ),\n      programId: this._programId,\n    });\n  }\n\n  /**\n   * @deprecated since version 14.0.\n   *\n   * Function returning the associated account. Args are keys to associate.\n   * Order matters.\n   */\n  async associated(...args: Array<PublicKey | Buffer>): Promise<T> {\n    const addr = await this.associatedAddress(...args);\n    return await this.fetch(addr);\n  }\n\n  /**\n   * @deprecated since version 14.0.\n   *\n   * Function returning the associated address. Args are keys to associate.\n   * Order matters.\n   */\n  async associatedAddress(\n    ...args: Array<PublicKey | Buffer>\n  ): Promise<PublicKey> {\n    return await pubkeyUtil.associated(this._programId, ...args);\n  }\n\n  async getAccountInfo(\n    address: Address,\n    commitment?: Commitment\n  ): Promise<AccountInfo<Buffer> | null> {\n    return await this._provider.connection.getAccountInfo(\n      translateAddress(address),\n      commitment\n    );\n  }\n}\n\n/**\n * @hidden\n *\n * Deserialized account owned by a program.\n */\nexport type ProgramAccount<T = any> = {\n  publicKey: PublicKey;\n  account: T;\n};\n\n// Tracks all subscriptions.\nconst subscriptions: Map<string, Subscription> = new Map();\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}