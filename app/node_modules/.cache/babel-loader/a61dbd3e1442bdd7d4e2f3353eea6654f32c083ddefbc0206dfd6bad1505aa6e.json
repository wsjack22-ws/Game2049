{"ast":null,"code":"\"use strict\";\n\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Package hmac implements HMAC algorithm.\n */\nvar hash_1 = require(\"@stablelib/hash\");\nvar constant_time_1 = require(\"@stablelib/constant-time\");\nvar wipe_1 = require(\"@stablelib/wipe\");\n/**\n *  HMAC implements hash-based message authentication algorithm.\n */\nvar HMAC = /** @class */function () {\n  /**\n   * Constructs a new HMAC with the given Hash and secret key.\n   */\n  function HMAC(hash, key) {\n    this._finished = false; // true if HMAC was finalized\n    // Initialize inner and outer hashes.\n    this._inner = new hash();\n    this._outer = new hash();\n    // Set block and digest sizes for this HMAC\n    // instance to values from the hash.\n    this.blockSize = this._outer.blockSize;\n    this.digestLength = this._outer.digestLength;\n    // Pad temporary stores a key (or its hash) padded with zeroes.\n    var pad = new Uint8Array(this.blockSize);\n    if (key.length > this.blockSize) {\n      // If key is bigger than hash block size, it must be\n      // hashed and this hash is used as a key instead.\n      this._inner.update(key).finish(pad).clean();\n    } else {\n      // Otherwise, copy the key into pad.\n      pad.set(key);\n    }\n    // Now two different keys are derived from padded key\n    // by xoring a different byte value to each.\n    // To make inner hash key, xor byte 0x36 into pad.\n    for (var i = 0; i < pad.length; i++) {\n      pad[i] ^= 0x36;\n    }\n    // Update inner hash with the result.\n    this._inner.update(pad);\n    // To make outer hash key, xor byte 0x5c into pad.\n    // But since we already xored 0x36 there, we must\n    // first undo this by xoring it again.\n    for (var i = 0; i < pad.length; i++) {\n      pad[i] ^= 0x36 ^ 0x5c;\n    }\n    // Update outer hash with the result.\n    this._outer.update(pad);\n    // Save states of both hashes, so that we can quickly restore\n    // them later in reset() without the need to remember the actual\n    // key and perform this initialization again.\n    if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {\n      this._innerKeyedState = this._inner.saveState();\n      this._outerKeyedState = this._outer.saveState();\n    }\n    // Clean pad.\n    wipe_1.wipe(pad);\n  }\n  /**\n   * Returns HMAC state to the state initialized with key\n   * to make it possible to run HMAC over the other data with the same\n   * key without creating a new instance.\n   */\n  HMAC.prototype.reset = function () {\n    if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n      throw new Error(\"hmac: can't reset() because hash doesn't implement restoreState()\");\n    }\n    // Restore keyed states of inner and outer hashes.\n    this._inner.restoreState(this._innerKeyedState);\n    this._outer.restoreState(this._outerKeyedState);\n    this._finished = false;\n    return this;\n  };\n  /**\n   * Cleans HMAC state.\n   */\n  HMAC.prototype.clean = function () {\n    if (hash_1.isSerializableHash(this._inner)) {\n      this._inner.cleanSavedState(this._innerKeyedState);\n    }\n    if (hash_1.isSerializableHash(this._outer)) {\n      this._outer.cleanSavedState(this._outerKeyedState);\n    }\n    this._inner.clean();\n    this._outer.clean();\n  };\n  /**\n   * Updates state with provided data.\n   */\n  HMAC.prototype.update = function (data) {\n    this._inner.update(data);\n    return this;\n  };\n  /**\n   * Finalizes HMAC and puts the result in out.\n   */\n  HMAC.prototype.finish = function (out) {\n    if (this._finished) {\n      // If HMAC was finalized, outer hash is also finalized,\n      // so it produces the same digest it produced when it\n      // was finalized.\n      this._outer.finish(out);\n      return this;\n    }\n    // Finalize inner hash and store the result temporarily.\n    this._inner.finish(out);\n    // Update outer hash with digest of inner hash and and finalize it.\n    this._outer.update(out.subarray(0, this.digestLength)).finish(out);\n    this._finished = true;\n    return this;\n  };\n  /**\n   * Returns the computed message authentication code.\n   */\n  HMAC.prototype.digest = function () {\n    var out = new Uint8Array(this.digestLength);\n    this.finish(out);\n    return out;\n  };\n  /**\n   * Saves HMAC state.\n   * This function is needed for PBKDF2 optimization.\n   */\n  HMAC.prototype.saveState = function () {\n    if (!hash_1.isSerializableHash(this._inner)) {\n      throw new Error(\"hmac: can't saveState() because hash doesn't implement it\");\n    }\n    return this._inner.saveState();\n  };\n  HMAC.prototype.restoreState = function (savedState) {\n    if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n      throw new Error(\"hmac: can't restoreState() because hash doesn't implement it\");\n    }\n    this._inner.restoreState(savedState);\n    this._outer.restoreState(this._outerKeyedState);\n    this._finished = false;\n    return this;\n  };\n  HMAC.prototype.cleanSavedState = function (savedState) {\n    if (!hash_1.isSerializableHash(this._inner)) {\n      throw new Error(\"hmac: can't cleanSavedState() because hash doesn't implement it\");\n    }\n    this._inner.cleanSavedState(savedState);\n  };\n  return HMAC;\n}();\nexports.HMAC = HMAC;\n/**\n * Returns HMAC using the given hash constructor for the key over data.\n */\nfunction hmac(hash, key, data) {\n  var h = new HMAC(hash, key);\n  h.update(data);\n  var digest = h.digest();\n  h.clean();\n  return digest;\n}\nexports.hmac = hmac;\n/**\n * Returns true if two HMAC digests are equal.\n * Uses constant-time comparison to avoid leaking timing information.\n *\n * Example:\n *\n *    const receivedDigest = ...\n *    const realDigest = hmac(SHA256, key, data);\n *    if (!equal(receivedDigest, realDigest)) {\n *        throw new Error(\"Authentication error\");\n *    }\n */\nexports.equal = constant_time_1.equal;","map":{"version":3,"names":["hash_1","require","constant_time_1","wipe_1","HMAC","hash","key","_finished","_inner","_outer","blockSize","digestLength","pad","Uint8Array","length","update","finish","clean","set","i","isSerializableHash","_innerKeyedState","saveState","_outerKeyedState","wipe","prototype","reset","Error","restoreState","cleanSavedState","data","out","subarray","digest","savedState","exports","hmac","h","equal"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@stablelib/hmac/hmac.ts"],"sourcesContent":["// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\n/**\n * Package hmac implements HMAC algorithm.\n */\n\nimport { Hash, SerializableHash, isSerializableHash } from \"@stablelib/hash\";\nimport { equal as constantTimeEqual } from \"@stablelib/constant-time\";\nimport { wipe } from \"@stablelib/wipe\";\n\n/**\n *  HMAC implements hash-based message authentication algorithm.\n */\nexport class HMAC implements SerializableHash {\n    readonly blockSize: number;\n    readonly digestLength: number;\n\n    private _inner: Hash; // inner hash\n    private _outer: Hash; // outer hash\n\n    private _finished = false; // true if HMAC was finalized\n\n    // Copies of hash states after keying.\n    // Need for quick reset without hashing the key again.\n    private _innerKeyedState: any | undefined;\n    private _outerKeyedState: any | undefined;\n\n    /**\n     * Constructs a new HMAC with the given Hash and secret key.\n     */\n    constructor(hash: new () => Hash | SerializableHash, key: Uint8Array) {\n        // Initialize inner and outer hashes.\n        this._inner = new hash();\n        this._outer = new hash();\n\n        // Set block and digest sizes for this HMAC\n        // instance to values from the hash.\n        this.blockSize = this._outer.blockSize;\n        this.digestLength = this._outer.digestLength;\n\n        // Pad temporary stores a key (or its hash) padded with zeroes.\n        const pad = new Uint8Array(this.blockSize);\n\n        if (key.length > this.blockSize) {\n            // If key is bigger than hash block size, it must be\n            // hashed and this hash is used as a key instead.\n            this._inner.update(key).finish(pad).clean();\n        } else {\n            // Otherwise, copy the key into pad.\n            pad.set(key);\n        }\n\n        // Now two different keys are derived from padded key\n        // by xoring a different byte value to each.\n\n        // To make inner hash key, xor byte 0x36 into pad.\n        for (let i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36;\n        }\n        // Update inner hash with the result.\n        this._inner.update(pad);\n\n        // To make outer hash key, xor byte 0x5c into pad.\n        // But since we already xored 0x36 there, we must\n        // first undo this by xoring it again.\n        for (let i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36 ^ 0x5c;\n        }\n        // Update outer hash with the result.\n        this._outer.update(pad);\n\n        // Save states of both hashes, so that we can quickly restore\n        // them later in reset() without the need to remember the actual\n        // key and perform this initialization again.\n        if (isSerializableHash(this._inner) && isSerializableHash(this._outer)) {\n            this._innerKeyedState = this._inner.saveState();\n            this._outerKeyedState = this._outer.saveState();\n        }\n\n        // Clean pad.\n        wipe(pad);\n    }\n\n    /**\n     * Returns HMAC state to the state initialized with key\n     * to make it possible to run HMAC over the other data with the same\n     * key without creating a new instance.\n     */\n    reset(): this {\n        if (!isSerializableHash(this._inner) || !isSerializableHash(this._outer)) {\n            throw new Error(\"hmac: can't reset() because hash doesn't implement restoreState()\");\n        }\n        // Restore keyed states of inner and outer hashes.\n        this._inner.restoreState(this._innerKeyedState);\n        this._outer.restoreState(this._outerKeyedState);\n        this._finished = false;\n        return this;\n    }\n\n    /**\n     * Cleans HMAC state.\n     */\n    clean() {\n        if (isSerializableHash(this._inner)) {\n            this._inner.cleanSavedState(this._innerKeyedState);\n        }\n        if (isSerializableHash(this._outer)) {\n            this._outer.cleanSavedState(this._outerKeyedState);\n        }\n        this._inner.clean();\n        this._outer.clean();\n    }\n\n    /**\n     * Updates state with provided data.\n     */\n    update(data: Uint8Array): this {\n        this._inner.update(data);\n        return this;\n    }\n\n    /**\n     * Finalizes HMAC and puts the result in out.\n     */\n    finish(out: Uint8Array): this {\n        if (this._finished) {\n            // If HMAC was finalized, outer hash is also finalized,\n            // so it produces the same digest it produced when it\n            // was finalized.\n            this._outer.finish(out);\n            return this;\n        }\n\n        // Finalize inner hash and store the result temporarily.\n        this._inner.finish(out);\n\n        // Update outer hash with digest of inner hash and and finalize it.\n        this._outer.update(out.subarray(0, this.digestLength)).finish(out);\n        this._finished = true;\n\n        return this;\n    }\n\n    /**\n     * Returns the computed message authentication code.\n     */\n    digest(): Uint8Array {\n        const out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    }\n\n    /**\n     * Saves HMAC state.\n     * This function is needed for PBKDF2 optimization.\n     */\n    saveState(): any {\n        if (!isSerializableHash(this._inner)) {\n            throw new Error(\"hmac: can't saveState() because hash doesn't implement it\");\n        }\n        return this._inner.saveState();\n    }\n\n    restoreState(savedState: any): this {\n        if (!isSerializableHash(this._inner) || !isSerializableHash(this._outer)) {\n            throw new Error(\"hmac: can't restoreState() because hash doesn't implement it\");\n        }\n        this._inner.restoreState(savedState);\n        this._outer.restoreState(this._outerKeyedState);\n        this._finished = false;\n        return this;\n    }\n\n    cleanSavedState(savedState: any) {\n        if (!isSerializableHash(this._inner)) {\n            throw new Error(\"hmac: can't cleanSavedState() because hash doesn't implement it\");\n        }\n        this._inner.cleanSavedState(savedState);\n    }\n}\n\n/**\n * Returns HMAC using the given hash constructor for the key over data.\n */\nexport function hmac(hash: new () => Hash, key: Uint8Array, data: Uint8Array): Uint8Array {\n    const h = new HMAC(hash, key);\n    h.update(data);\n    const digest = h.digest();\n    h.clean();\n    return digest;\n}\n\n/**\n * Returns true if two HMAC digests are equal.\n * Uses constant-time comparison to avoid leaking timing information.\n *\n * Example:\n *\n *    const receivedDigest = ...\n *    const realDigest = hmac(SHA256, key, data);\n *    if (!equal(receivedDigest, realDigest)) {\n *        throw new Error(\"Authentication error\");\n *    }\n */\nexport const equal = constantTimeEqual;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}