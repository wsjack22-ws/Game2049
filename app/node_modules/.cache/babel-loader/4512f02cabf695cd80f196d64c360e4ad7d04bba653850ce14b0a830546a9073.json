{"ast":null,"code":"\"use strict\";\n\n/*\nThe MIT License\n\nCopyright (c) 2016 Nick Dodson. nickdodson.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;\n/**\n * Returns a `Boolean` on whether or not the a `String` starts with '0x'\n * @param str the string input value\n * @return a boolean if it is or is not hex prefixed\n * @throws if the str input is not a string\n */\nfunction isHexPrefixed(str) {\n  if (typeof str !== 'string') {\n    throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);\n  }\n  return str[0] === '0' && str[1] === 'x';\n}\nexports.isHexPrefixed = isHexPrefixed;\n/**\n * Removes '0x' from a given `String` if present\n * @param str the string value\n * @returns the string without 0x prefix\n */\nconst stripHexPrefix = str => {\n  if (typeof str !== 'string') throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);\n  return isHexPrefixed(str) ? str.slice(2) : str;\n};\nexports.stripHexPrefix = stripHexPrefix;\n/**\n * Pads a `String` to have an even length\n * @param value\n * @return output\n */\nfunction padToEven(value) {\n  let a = value;\n  if (typeof a !== 'string') {\n    throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);\n  }\n  if (a.length % 2) a = `0${a}`;\n  return a;\n}\nexports.padToEven = padToEven;\n/**\n * Get the binary size of a string\n * @param str\n * @returns the number of bytes contained within the string\n */\nfunction getBinarySize(str) {\n  if (typeof str !== 'string') {\n    throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof str}`);\n  }\n  return Buffer.byteLength(str, 'utf8');\n}\nexports.getBinarySize = getBinarySize;\n/**\n * Returns TRUE if the first specified array contains all elements\n * from the second one. FALSE otherwise.\n *\n * @param superset\n * @param subset\n *\n */\nfunction arrayContainsArray(superset, subset, some) {\n  if (Array.isArray(superset) !== true) {\n    throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`);\n  }\n  if (Array.isArray(subset) !== true) {\n    throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`);\n  }\n  return subset[some === true ? 'some' : 'every'](value => superset.indexOf(value) >= 0);\n}\nexports.arrayContainsArray = arrayContainsArray;\n/**\n * Should be called to get ascii from its hex representation\n *\n * @param string in hex\n * @returns ascii string representation of hex value\n */\nfunction toAscii(hex) {\n  let str = '';\n  let i = 0;\n  const l = hex.length;\n  if (hex.substring(0, 2) === '0x') i = 2;\n  for (; i < l; i += 2) {\n    const code = parseInt(hex.substr(i, 2), 16);\n    str += String.fromCharCode(code);\n  }\n  return str;\n}\nexports.toAscii = toAscii;\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n *\n * @param string\n * @param optional padding\n * @returns hex representation of input string\n */\nfunction fromUtf8(stringValue) {\n  const str = Buffer.from(stringValue, 'utf8');\n  return `0x${padToEven(str.toString('hex')).replace(/^0+|0+$/g, '')}`;\n}\nexports.fromUtf8 = fromUtf8;\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n *\n * @param  string\n * @param  optional padding\n * @returns  hex representation of input string\n */\nfunction fromAscii(stringValue) {\n  let hex = '';\n  for (let i = 0; i < stringValue.length; i++) {\n    const code = stringValue.charCodeAt(i);\n    const n = code.toString(16);\n    hex += n.length < 2 ? `0${n}` : n;\n  }\n  return `0x${hex}`;\n}\nexports.fromAscii = fromAscii;\n/**\n * Returns the keys from an array of objects.\n * @example\n * ```js\n * getKeys([{a: '1', b: '2'}, {a: '3', b: '4'}], 'a') => ['1', '3']\n *````\n * @param  params\n * @param  key\n * @param  allowEmpty\n * @returns output just a simple array of output keys\n */\nfunction getKeys(params, key, allowEmpty) {\n  if (!Array.isArray(params)) {\n    throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof params}`);\n  }\n  if (typeof key !== 'string') {\n    throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`);\n  }\n  const result = [];\n  for (let i = 0; i < params.length; i++) {\n    let value = params[i][key];\n    if (allowEmpty === true && !value) {\n      value = '';\n    } else if (typeof value !== 'string') {\n      throw new Error(`invalid abi - expected type 'string', received ${typeof value}`);\n    }\n    result.push(value);\n  }\n  return result;\n}\nexports.getKeys = getKeys;\n/**\n * Is the string a hex string.\n *\n * @param  value\n * @param  length\n * @returns  output the string is a hex string\n */\nfunction isHexString(value, length) {\n  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) return false;\n  if (typeof length !== 'undefined' && length > 0 && value.length !== 2 + 2 * length) return false;\n  return true;\n}\nexports.isHexString = isHexString;","map":{"version":3,"names":["isHexPrefixed","str","Error","exports","stripHexPrefix","slice","padToEven","value","a","length","getBinarySize","Buffer","byteLength","arrayContainsArray","superset","subset","some","Array","isArray","indexOf","toAscii","hex","i","l","substring","code","parseInt","substr","String","fromCharCode","fromUtf8","stringValue","from","toString","replace","fromAscii","charCodeAt","n","getKeys","params","key","allowEmpty","result","push","isHexString","match"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@ethereumjs/util/src/internal.ts"],"sourcesContent":["/*\nThe MIT License\n\nCopyright (c) 2016 Nick Dodson. nickdodson.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE\n */\n\n/**\n * Returns a `Boolean` on whether or not the a `String` starts with '0x'\n * @param str the string input value\n * @return a boolean if it is or is not hex prefixed\n * @throws if the str input is not a string\n */\nexport function isHexPrefixed(str: string): boolean {\n  if (typeof str !== 'string') {\n    throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`)\n  }\n\n  return str[0] === '0' && str[1] === 'x'\n}\n\n/**\n * Removes '0x' from a given `String` if present\n * @param str the string value\n * @returns the string without 0x prefix\n */\nexport const stripHexPrefix = (str: string): string => {\n  if (typeof str !== 'string')\n    throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`)\n\n  return isHexPrefixed(str) ? str.slice(2) : str\n}\n\n/**\n * Pads a `String` to have an even length\n * @param value\n * @return output\n */\nexport function padToEven(value: string): string {\n  let a = value\n\n  if (typeof a !== 'string') {\n    throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`)\n  }\n\n  if (a.length % 2) a = `0${a}`\n\n  return a\n}\n\n/**\n * Get the binary size of a string\n * @param str\n * @returns the number of bytes contained within the string\n */\nexport function getBinarySize(str: string) {\n  if (typeof str !== 'string') {\n    throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof str}`)\n  }\n\n  return Buffer.byteLength(str, 'utf8')\n}\n\n/**\n * Returns TRUE if the first specified array contains all elements\n * from the second one. FALSE otherwise.\n *\n * @param superset\n * @param subset\n *\n */\nexport function arrayContainsArray(\n  superset: unknown[],\n  subset: unknown[],\n  some?: boolean\n): boolean {\n  if (Array.isArray(superset) !== true) {\n    throw new Error(\n      `[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`\n    )\n  }\n  if (Array.isArray(subset) !== true) {\n    throw new Error(\n      `[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`\n    )\n  }\n\n  return subset[some === true ? 'some' : 'every']((value) => superset.indexOf(value) >= 0)\n}\n\n/**\n * Should be called to get ascii from its hex representation\n *\n * @param string in hex\n * @returns ascii string representation of hex value\n */\nexport function toAscii(hex: string): string {\n  let str = ''\n  let i = 0\n  const l = hex.length\n\n  if (hex.substring(0, 2) === '0x') i = 2\n\n  for (; i < l; i += 2) {\n    const code = parseInt(hex.substr(i, 2), 16)\n    str += String.fromCharCode(code)\n  }\n\n  return str\n}\n\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n *\n * @param string\n * @param optional padding\n * @returns hex representation of input string\n */\nexport function fromUtf8(stringValue: string) {\n  const str = Buffer.from(stringValue, 'utf8')\n\n  return `0x${padToEven(str.toString('hex')).replace(/^0+|0+$/g, '')}`\n}\n\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n *\n * @param  string\n * @param  optional padding\n * @returns  hex representation of input string\n */\nexport function fromAscii(stringValue: string) {\n  let hex = ''\n  for (let i = 0; i < stringValue.length; i++) {\n    const code = stringValue.charCodeAt(i)\n    const n = code.toString(16)\n    hex += n.length < 2 ? `0${n}` : n\n  }\n\n  return `0x${hex}`\n}\n\n/**\n * Returns the keys from an array of objects.\n * @example\n * ```js\n * getKeys([{a: '1', b: '2'}, {a: '3', b: '4'}], 'a') => ['1', '3']\n *````\n * @param  params\n * @param  key\n * @param  allowEmpty\n * @returns output just a simple array of output keys\n */\nexport function getKeys(params: Record<string, string>[], key: string, allowEmpty?: boolean) {\n  if (!Array.isArray(params)) {\n    throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof params}`)\n  }\n  if (typeof key !== 'string') {\n    throw new Error(\n      `[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`\n    )\n  }\n\n  const result = []\n\n  for (let i = 0; i < params.length; i++) {\n    let value = params[i][key]\n    if (allowEmpty === true && !value) {\n      value = ''\n    } else if (typeof value !== 'string') {\n      throw new Error(`invalid abi - expected type 'string', received ${typeof value}`)\n    }\n    result.push(value)\n  }\n\n  return result\n}\n\n/**\n * Is the string a hex string.\n *\n * @param  value\n * @param  length\n * @returns  output the string is a hex string\n */\nexport function isHexString(value: string, length?: number): boolean {\n  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) return false\n\n  if (typeof length !== 'undefined' && length > 0 && value.length !== 2 + 2 * length) return false\n\n  return true\n}\n"],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;;;;;;AAMA,SAAgBA,aAAaA,CAACC,GAAW;EACvC,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IAC3B,MAAM,IAAIC,KAAK,CAAC,8DAA8D,OAAOD,GAAG,EAAE,CAAC;;EAG7F,OAAOA,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIA,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG;AACzC;AANAE,OAAA,CAAAH,aAAA,GAAAA,aAAA;AAQA;;;;;AAKO,MAAMI,cAAc,GAAIH,GAAW,IAAY;EACpD,IAAI,OAAOA,GAAG,KAAK,QAAQ,EACzB,MAAM,IAAIC,KAAK,CAAC,0DAA0D,OAAOD,GAAG,EAAE,CAAC;EAEzF,OAAOD,aAAa,CAACC,GAAG,CAAC,GAAGA,GAAG,CAACI,KAAK,CAAC,CAAC,CAAC,GAAGJ,GAAG;AAChD,CAAC;AALYE,OAAA,CAAAC,cAAc,GAAAA,cAAA;AAO3B;;;;;AAKA,SAAgBE,SAASA,CAACC,KAAa;EACrC,IAAIC,CAAC,GAAGD,KAAK;EAEb,IAAI,OAAOC,CAAC,KAAK,QAAQ,EAAE;IACzB,MAAM,IAAIN,KAAK,CAAC,qDAAqD,OAAOM,CAAC,EAAE,CAAC;;EAGlF,IAAIA,CAAC,CAACC,MAAM,GAAG,CAAC,EAAED,CAAC,GAAG,IAAIA,CAAC,EAAE;EAE7B,OAAOA,CAAC;AACV;AAVAL,OAAA,CAAAG,SAAA,GAAAA,SAAA;AAYA;;;;;AAKA,SAAgBI,aAAaA,CAACT,GAAW;EACvC,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IAC3B,MAAM,IAAIC,KAAK,CAAC,iEAAiE,OAAOD,GAAG,EAAE,CAAC;;EAGhG,OAAOU,MAAM,CAACC,UAAU,CAACX,GAAG,EAAE,MAAM,CAAC;AACvC;AANAE,OAAA,CAAAO,aAAA,GAAAA,aAAA;AAQA;;;;;;;;AAQA,SAAgBG,kBAAkBA,CAChCC,QAAmB,EACnBC,MAAiB,EACjBC,IAAc;EAEd,IAAIC,KAAK,CAACC,OAAO,CAACJ,QAAQ,CAAC,KAAK,IAAI,EAAE;IACpC,MAAM,IAAIZ,KAAK,CACb,mFAAmF,OAAOY,QAAQ,GAAG,CACtG;;EAEH,IAAIG,KAAK,CAACC,OAAO,CAACH,MAAM,CAAC,KAAK,IAAI,EAAE;IAClC,MAAM,IAAIb,KAAK,CACb,iFAAiF,OAAOa,MAAM,GAAG,CAClG;;EAGH,OAAOA,MAAM,CAACC,IAAI,KAAK,IAAI,GAAG,MAAM,GAAG,OAAO,CAAC,CAAET,KAAK,IAAKO,QAAQ,CAACK,OAAO,CAACZ,KAAK,CAAC,IAAI,CAAC,CAAC;AAC1F;AAjBAJ,OAAA,CAAAU,kBAAA,GAAAA,kBAAA;AAmBA;;;;;;AAMA,SAAgBO,OAAOA,CAACC,GAAW;EACjC,IAAIpB,GAAG,GAAG,EAAE;EACZ,IAAIqB,CAAC,GAAG,CAAC;EACT,MAAMC,CAAC,GAAGF,GAAG,CAACZ,MAAM;EAEpB,IAAIY,GAAG,CAACG,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,EAAEF,CAAC,GAAG,CAAC;EAEvC,OAAOA,CAAC,GAAGC,CAAC,EAAED,CAAC,IAAI,CAAC,EAAE;IACpB,MAAMG,IAAI,GAAGC,QAAQ,CAACL,GAAG,CAACM,MAAM,CAACL,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC;IAC3CrB,GAAG,IAAI2B,MAAM,CAACC,YAAY,CAACJ,IAAI,CAAC;;EAGlC,OAAOxB,GAAG;AACZ;AAbAE,OAAA,CAAAiB,OAAA,GAAAA,OAAA;AAeA;;;;;;;AAOA,SAAgBU,QAAQA,CAACC,WAAmB;EAC1C,MAAM9B,GAAG,GAAGU,MAAM,CAACqB,IAAI,CAACD,WAAW,EAAE,MAAM,CAAC;EAE5C,OAAO,KAAKzB,SAAS,CAACL,GAAG,CAACgC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAACC,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC,EAAE;AACtE;AAJA/B,OAAA,CAAA2B,QAAA,GAAAA,QAAA;AAMA;;;;;;;AAOA,SAAgBK,SAASA,CAACJ,WAAmB;EAC3C,IAAIV,GAAG,GAAG,EAAE;EACZ,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGS,WAAW,CAACtB,MAAM,EAAEa,CAAC,EAAE,EAAE;IAC3C,MAAMG,IAAI,GAAGM,WAAW,CAACK,UAAU,CAACd,CAAC,CAAC;IACtC,MAAMe,CAAC,GAAGZ,IAAI,CAACQ,QAAQ,CAAC,EAAE,CAAC;IAC3BZ,GAAG,IAAIgB,CAAC,CAAC5B,MAAM,GAAG,CAAC,GAAG,IAAI4B,CAAC,EAAE,GAAGA,CAAC;;EAGnC,OAAO,KAAKhB,GAAG,EAAE;AACnB;AATAlB,OAAA,CAAAgC,SAAA,GAAAA,SAAA;AAWA;;;;;;;;;;;AAWA,SAAgBG,OAAOA,CAACC,MAAgC,EAAEC,GAAW,EAAEC,UAAoB;EACzF,IAAI,CAACxB,KAAK,CAACC,OAAO,CAACqB,MAAM,CAAC,EAAE;IAC1B,MAAM,IAAIrC,KAAK,CAAC,+DAA+D,OAAOqC,MAAM,EAAE,CAAC;;EAEjG,IAAI,OAAOC,GAAG,KAAK,QAAQ,EAAE;IAC3B,MAAM,IAAItC,KAAK,CACb,iEAAiE,OAAOqC,MAAM,EAAE,CACjF;;EAGH,MAAMG,MAAM,GAAG,EAAE;EAEjB,KAAK,IAAIpB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,MAAM,CAAC9B,MAAM,EAAEa,CAAC,EAAE,EAAE;IACtC,IAAIf,KAAK,GAAGgC,MAAM,CAACjB,CAAC,CAAC,CAACkB,GAAG,CAAC;IAC1B,IAAIC,UAAU,KAAK,IAAI,IAAI,CAAClC,KAAK,EAAE;MACjCA,KAAK,GAAG,EAAE;KACX,MAAM,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MACpC,MAAM,IAAIL,KAAK,CAAC,kDAAkD,OAAOK,KAAK,EAAE,CAAC;;IAEnFmC,MAAM,CAACC,IAAI,CAACpC,KAAK,CAAC;;EAGpB,OAAOmC,MAAM;AACf;AAvBAvC,OAAA,CAAAmC,OAAA,GAAAA,OAAA;AAyBA;;;;;;;AAOA,SAAgBM,WAAWA,CAACrC,KAAa,EAAEE,MAAe;EACxD,IAAI,OAAOF,KAAK,KAAK,QAAQ,IAAI,CAACA,KAAK,CAACsC,KAAK,CAAC,kBAAkB,CAAC,EAAE,OAAO,KAAK;EAE/E,IAAI,OAAOpC,MAAM,KAAK,WAAW,IAAIA,MAAM,GAAG,CAAC,IAAIF,KAAK,CAACE,MAAM,KAAK,CAAC,GAAG,CAAC,GAAGA,MAAM,EAAE,OAAO,KAAK;EAEhG,OAAO,IAAI;AACb;AANAN,OAAA,CAAAyC,WAAA,GAAAA,WAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}