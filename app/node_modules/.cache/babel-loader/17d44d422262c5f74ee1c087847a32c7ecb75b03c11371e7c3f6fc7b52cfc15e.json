{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _slicedToArray = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar web3_js_1 = require(\"@solana/web3.js\");\nvar error_js_1 = require(\"../../error.js\");\nvar common_js_1 = require(\"../common.js\");\nvar context_js_1 = require(\"../context.js\");\nvar features = __importStar(require(\"../../utils/features.js\"));\nvar InstructionNamespaceFactory = /*#__PURE__*/function () {\n  function InstructionNamespaceFactory() {\n    _classCallCheck(this, InstructionNamespaceFactory);\n  }\n  _createClass(InstructionNamespaceFactory, null, [{\n    key: \"build\",\n    value: function build(idlIx, encodeFn, programId) {\n      if (idlIx.name === \"_inner\") {\n        throw new error_js_1.IdlError(\"the _inner name is reserved\");\n      }\n      var ix = function ix() {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        var _ref = (0, context_js_1.splitArgsAndCtx)(idlIx, [].concat(args)),\n          _ref2 = _slicedToArray(_ref, 2),\n          ixArgs = _ref2[0],\n          ctx = _ref2[1];\n        (0, common_js_1.validateAccounts)(idlIx.accounts, ctx.accounts);\n        validateInstruction.apply(void 0, [idlIx].concat(args));\n        var keys = ix.accounts(ctx.accounts);\n        if (ctx.remainingAccounts !== undefined) {\n          keys.push.apply(keys, _toConsumableArray(ctx.remainingAccounts));\n        }\n        if (features.isSet(\"debug-logs\")) {\n          console.log(\"Outgoing account metas:\", keys);\n        }\n        return new web3_js_1.TransactionInstruction({\n          keys: keys,\n          programId: programId,\n          data: encodeFn(idlIx.name, (0, common_js_1.toInstruction).apply(void 0, [idlIx].concat(_toConsumableArray(ixArgs))))\n        });\n      };\n      // Utility fn for ordering the accounts for this instruction.\n      ix[\"accounts\"] = function (accs) {\n        return InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts, idlIx.name);\n      };\n      return ix;\n    }\n  }, {\n    key: \"accountsArray\",\n    value: function accountsArray(ctx, accounts, ixName) {\n      if (!ctx) {\n        return [];\n      }\n      return accounts.map(function (acc) {\n        // Nested accounts.\n        var nestedAccounts = \"accounts\" in acc ? acc.accounts : undefined;\n        if (nestedAccounts !== undefined) {\n          var rpcAccs = ctx[acc.name];\n          return InstructionNamespaceFactory.accountsArray(rpcAccs, acc.accounts, ixName).flat();\n        } else {\n          var account = acc;\n          var pubkey;\n          try {\n            pubkey = (0, common_js_1.translateAddress)(ctx[acc.name]);\n          } catch (err) {\n            throw new Error(\"Wrong input type for account \\\"\".concat(acc.name, \"\\\" in the instruction accounts object\").concat(ixName !== undefined ? ' for instruction \"' + ixName + '\"' : \"\", \". Expected PublicKey or string.\"));\n          }\n          return {\n            pubkey: pubkey,\n            isWritable: account.isMut,\n            isSigner: account.isSigner\n          };\n        }\n      }).flat();\n    }\n  }]);\n  return InstructionNamespaceFactory;\n}();\nexports.default = InstructionNamespaceFactory;\n// Throws error if any argument required for the `ix` is not given.\nfunction validateInstruction(ix) {\n  // todo\n}","map":{"version":3,"names":["web3_js_1","require","error_js_1","common_js_1","context_js_1","features","__importStar","InstructionNamespaceFactory","_classCallCheck","_createClass","key","value","build","idlIx","encodeFn","programId","name","IdlError","ix","_len","arguments","length","args","Array","_key","_ref","splitArgsAndCtx","concat","_ref2","_slicedToArray","ixArgs","ctx","validateAccounts","accounts","validateInstruction","apply","keys","remainingAccounts","undefined","push","_toConsumableArray","isSet","console","log","TransactionInstruction","data","toInstruction","accs","accountsArray","ixName","map","acc","nestedAccounts","rpcAccs","flat","account","pubkey","translateAddress","err","Error","isWritable","isMut","isSigner","exports","default"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/program/namespace/instruction.ts"],"sourcesContent":["import {\n  AccountMeta,\n  PublicKey,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport {\n  Idl,\n  IdlAccount,\n  IdlAccountItem,\n  IdlAccounts,\n  IdlInstruction,\n} from \"../../idl.js\";\nimport { IdlError } from \"../../error.js\";\nimport {\n  toInstruction,\n  validateAccounts,\n  translateAddress,\n  Address,\n} from \"../common.js\";\nimport { Accounts, splitArgsAndCtx } from \"../context.js\";\nimport * as features from \"../../utils/features.js\";\nimport {\n  AllInstructions,\n  AllInstructionsMap,\n  InstructionContextFn,\n  InstructionContextFnArgs,\n  MakeInstructionsNamespace,\n} from \"./types.js\";\n\nexport default class InstructionNamespaceFactory {\n  public static build<IDL extends Idl, I extends AllInstructions<IDL>>(\n    idlIx: I,\n    encodeFn: InstructionEncodeFn<I>,\n    programId: PublicKey\n  ): InstructionFn<IDL, I> {\n    if (idlIx.name === \"_inner\") {\n      throw new IdlError(\"the _inner name is reserved\");\n    }\n\n    const ix = (\n      ...args: InstructionContextFnArgs<IDL, I>\n    ): TransactionInstruction => {\n      const [ixArgs, ctx] = splitArgsAndCtx(idlIx, [...args]);\n      validateAccounts(idlIx.accounts, ctx.accounts);\n      validateInstruction(idlIx, ...args);\n\n      const keys = ix.accounts(ctx.accounts);\n\n      if (ctx.remainingAccounts !== undefined) {\n        keys.push(...ctx.remainingAccounts);\n      }\n\n      if (features.isSet(\"debug-logs\")) {\n        console.log(\"Outgoing account metas:\", keys);\n      }\n\n      return new TransactionInstruction({\n        keys,\n        programId,\n        data: encodeFn(idlIx.name, toInstruction(idlIx, ...ixArgs)),\n      });\n    };\n\n    // Utility fn for ordering the accounts for this instruction.\n    ix[\"accounts\"] = (accs: Accounts<I[\"accounts\"][number]> | undefined) => {\n      return InstructionNamespaceFactory.accountsArray(\n        accs,\n        idlIx.accounts,\n        idlIx.name\n      );\n    };\n\n    return ix;\n  }\n\n  public static accountsArray(\n    ctx: Accounts | undefined,\n    accounts: readonly IdlAccountItem[],\n    ixName?: string\n  ): AccountMeta[] {\n    if (!ctx) {\n      return [];\n    }\n\n    return accounts\n      .map((acc: IdlAccountItem) => {\n        // Nested accounts.\n        const nestedAccounts: IdlAccountItem[] | undefined =\n          \"accounts\" in acc ? acc.accounts : undefined;\n        if (nestedAccounts !== undefined) {\n          const rpcAccs = ctx[acc.name] as Accounts;\n          return InstructionNamespaceFactory.accountsArray(\n            rpcAccs,\n            (acc as IdlAccounts).accounts,\n            ixName\n          ).flat();\n        } else {\n          const account: IdlAccount = acc as IdlAccount;\n          let pubkey;\n          try {\n            pubkey = translateAddress(ctx[acc.name] as Address);\n          } catch (err) {\n            throw new Error(\n              `Wrong input type for account \"${\n                acc.name\n              }\" in the instruction accounts object${\n                ixName !== undefined ? ' for instruction \"' + ixName + '\"' : \"\"\n              }. Expected PublicKey or string.`\n            );\n          }\n          return {\n            pubkey,\n            isWritable: account.isMut,\n            isSigner: account.isSigner,\n          };\n        }\n      })\n      .flat();\n  }\n}\n\n/**\n * The namespace provides functions to build [[TransactionInstruction]]\n * objects for each method of a program.\n *\n * ## Usage\n *\n * ```javascript\n * instruction.<method>(...args, ctx);\n * ```\n *\n * ## Parameters\n *\n * 1. `args` - The positional arguments for the program. The type and number\n *    of these arguments depend on the program being used.\n * 2. `ctx`  - [[Context]] non-argument parameters to pass to the method.\n *    Always the last parameter in the method call.\n *\n * ## Example\n *\n * To create an instruction for the `increment` method above,\n *\n * ```javascript\n * const tx = await program.instruction.increment({\n *   accounts: {\n *     counter,\n *   },\n * });\n * ```\n */\nexport type InstructionNamespace<\n  IDL extends Idl = Idl,\n  I extends IdlInstruction = IDL[\"instructions\"][number]\n> = MakeInstructionsNamespace<\n  IDL,\n  I,\n  TransactionInstruction,\n  {\n    [M in keyof AllInstructionsMap<IDL>]: {\n      accounts: (\n        ctx: Accounts<AllInstructionsMap<IDL>[M][\"accounts\"][number]>\n      ) => unknown;\n    };\n  }\n>;\n\n/**\n * Function to create a `TransactionInstruction` generated from an IDL.\n * Additionally it provides an `accounts` utility method, returning a list\n * of ordered accounts for the instruction.\n */\nexport type InstructionFn<\n  IDL extends Idl = Idl,\n  I extends AllInstructions<IDL> = AllInstructions<IDL>\n> = InstructionContextFn<IDL, I, TransactionInstruction> &\n  IxProps<Accounts<I[\"accounts\"][number]>>;\n\ntype IxProps<A extends Accounts> = {\n  /**\n   * Returns an ordered list of accounts associated with the instruction.\n   */\n  accounts: (ctx: A) => AccountMeta[];\n};\n\nexport type InstructionEncodeFn<I extends IdlInstruction = IdlInstruction> = (\n  ixName: I[\"name\"],\n  ix: any\n) => Buffer;\n\n// Throws error if any argument required for the `ix` is not given.\nfunction validateInstruction(ix: IdlInstruction, ...args: any[]) {\n  // todo\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}