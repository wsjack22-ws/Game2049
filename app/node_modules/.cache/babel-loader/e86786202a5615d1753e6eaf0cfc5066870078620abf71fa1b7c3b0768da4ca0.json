{"ast":null,"code":"import _objectSpread from \"/Users/wuhuan/gif-portal-starter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { mod, pow } from './modular.js';\nimport { bytesToNumberLE, ensureBytes, numberToBytesLE, validateObject } from './utils.js';\nvar _0n = BigInt(0);\nvar _1n = BigInt(1);\nfunction validateOpts(curve) {\n  validateObject(curve, {\n    a: 'bigint'\n  }, {\n    montgomeryBits: 'isSafeInteger',\n    nByteLength: 'isSafeInteger',\n    adjustScalarBytes: 'function',\n    domain: 'function',\n    powPminus2: 'function',\n    Gu: 'bigint'\n  });\n  // Set defaults\n  return Object.freeze(_objectSpread({}, curve));\n}\n// NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)\n// Uses only one coordinate instead of two\nexport function montgomery(curveDef) {\n  var CURVE = validateOpts(curveDef);\n  var P = CURVE.P;\n  var modP = function modP(n) {\n    return mod(n, P);\n  };\n  var montgomeryBits = CURVE.montgomeryBits;\n  var montgomeryBytes = Math.ceil(montgomeryBits / 8);\n  var fieldLen = CURVE.nByteLength;\n  var adjustScalarBytes = CURVE.adjustScalarBytes || function (bytes) {\n    return bytes;\n  };\n  var powPminus2 = CURVE.powPminus2 || function (x) {\n    return pow(x, P - BigInt(2), P);\n  };\n  // cswap from RFC7748. But it is not from RFC7748!\n  /*\n    cswap(swap, x_2, x_3):\n         dummy = mask(swap) AND (x_2 XOR x_3)\n         x_2 = x_2 XOR dummy\n         x_3 = x_3 XOR dummy\n         Return (x_2, x_3)\n  Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n   and x_3, computed, e.g., as mask(swap) = 0 - swap.\n  */\n  function cswap(swap, x_2, x_3) {\n    var dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy);\n    x_3 = modP(x_3 + dummy);\n    return [x_2, x_3];\n  }\n  // Accepts 0 as well\n  function assertFieldElement(n) {\n    if (typeof n === 'bigint' && _0n <= n && n < P) return n;\n    throw new Error('Expected valid scalar 0 < scalar < CURVE.P');\n  }\n  // x25519 from 4\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n  var a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n  /**\n   *\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\n   * @param scalar by which the point would be multiplied\n   * @returns new Point on Montgomery curve\n   */\n  function montgomeryLadder(pointU, scalar) {\n    var u = assertFieldElement(pointU);\n    // Section 5: Implementations MUST accept non-canonical values and process them as\n    // if they had been reduced modulo the field prime.\n    var k = assertFieldElement(scalar);\n    var x_1 = u;\n    var x_2 = _1n;\n    var z_2 = _0n;\n    var x_3 = u;\n    var z_3 = _1n;\n    var swap = _0n;\n    var sw;\n    for (var t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n      var k_t = k >> t & _1n;\n      swap ^= k_t;\n      sw = cswap(swap, x_2, x_3);\n      x_2 = sw[0];\n      x_3 = sw[1];\n      sw = cswap(swap, z_2, z_3);\n      z_2 = sw[0];\n      z_3 = sw[1];\n      swap = k_t;\n      var A = x_2 + z_2;\n      var AA = modP(A * A);\n      var B = x_2 - z_2;\n      var BB = modP(B * B);\n      var E = AA - BB;\n      var C = x_3 + z_3;\n      var D = x_3 - z_3;\n      var DA = modP(D * A);\n      var CB = modP(C * B);\n      var dacb = DA + CB;\n      var da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    // (x_2, x_3) = cswap(swap, x_2, x_3)\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    // (z_2, z_3) = cswap(swap, z_2, z_3)\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    // z_2^(p - 2)\n    var z2 = powPminus2(z_2);\n    // Return x_2 * (z_2^(p - 2))\n    return modP(x_2 * z2);\n  }\n  function encodeUCoordinate(u) {\n    return numberToBytesLE(modP(u), montgomeryBytes);\n  }\n  function decodeUCoordinate(uEnc) {\n    // Section 5: When receiving such an array, implementations of X25519\n    // MUST mask the most significant bit in the final byte.\n    // This is very ugly way, but it works because fieldLen-1 is outside of bounds for X448, so this becomes NOOP\n    // fieldLen - scalaryBytes = 1 for X448 and = 0 for X25519\n    var u = ensureBytes('u coordinate', uEnc, montgomeryBytes);\n    // u[fieldLen-1] crashes QuickJS (TypeError: out-of-bound numeric index)\n    if (fieldLen === montgomeryBytes) u[fieldLen - 1] &= 127; // 0b0111_1111\n    return bytesToNumberLE(u);\n  }\n  function decodeScalar(n) {\n    var bytes = ensureBytes('scalar', n);\n    if (bytes.length !== montgomeryBytes && bytes.length !== fieldLen) throw new Error(\"Expected \".concat(montgomeryBytes, \" or \").concat(fieldLen, \" bytes, got \").concat(bytes.length));\n    return bytesToNumberLE(adjustScalarBytes(bytes));\n  }\n  function scalarMult(scalar, u) {\n    var pointU = decodeUCoordinate(u);\n    var _scalar = decodeScalar(scalar);\n    var pu = montgomeryLadder(pointU, _scalar);\n    // The result was not contributory\n    // https://cr.yp.to/ecdh.html#validate\n    if (pu === _0n) throw new Error('Invalid private or public key received');\n    return encodeUCoordinate(pu);\n  }\n  // Computes public key from private. By doing scalar multiplication of base point.\n  var GuBytes = encodeUCoordinate(CURVE.Gu);\n  function scalarMultBase(scalar) {\n    return scalarMult(scalar, GuBytes);\n  }\n  return {\n    scalarMult: scalarMult,\n    scalarMultBase: scalarMultBase,\n    getSharedSecret: function getSharedSecret(privateKey, publicKey) {\n      return scalarMult(privateKey, publicKey);\n    },\n    getPublicKey: function getPublicKey(privateKey) {\n      return scalarMultBase(privateKey);\n    },\n    utils: {\n      randomPrivateKey: function randomPrivateKey() {\n        return CURVE.randomBytes(CURVE.nByteLength);\n      }\n    },\n    GuBytes: GuBytes\n  };\n}","map":{"version":3,"names":["mod","pow","bytesToNumberLE","ensureBytes","numberToBytesLE","validateObject","_0n","BigInt","_1n","validateOpts","curve","a","montgomeryBits","nByteLength","adjustScalarBytes","domain","powPminus2","Gu","Object","freeze","_objectSpread","montgomery","curveDef","CURVE","P","modP","n","montgomeryBytes","Math","ceil","fieldLen","bytes","x","cswap","swap","x_2","x_3","dummy","assertFieldElement","Error","a24","montgomeryLadder","pointU","scalar","u","k","x_1","z_2","z_3","sw","t","k_t","A","AA","B","BB","E","C","D","DA","CB","dacb","da_cb","z2","encodeUCoordinate","decodeUCoordinate","uEnc","decodeScalar","length","concat","scalarMult","_scalar","pu","GuBytes","scalarMultBase","getSharedSecret","privateKey","publicKey","getPublicKey","utils","randomPrivateKey","randomBytes"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@noble/curves/src/abstract/montgomery.ts"],"sourcesContent":["/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { mod, pow } from './modular.js';\nimport { bytesToNumberLE, ensureBytes, numberToBytesLE, validateObject } from './utils.js';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\ntype Hex = string | Uint8Array;\n\nexport type CurveType = {\n  P: bigint; // finite field prime\n  nByteLength: number;\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array;\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array;\n  a: bigint;\n  montgomeryBits: number;\n  powPminus2?: (x: bigint) => bigint;\n  xyToU?: (x: bigint, y: bigint) => bigint;\n  Gu: bigint;\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n};\nexport type CurveFn = {\n  scalarMult: (scalar: Hex, u: Hex) => Uint8Array;\n  scalarMultBase: (scalar: Hex) => Uint8Array;\n  getSharedSecret: (privateKeyA: Hex, publicKeyB: Hex) => Uint8Array;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  utils: { randomPrivateKey: () => Uint8Array };\n  GuBytes: Uint8Array;\n};\n\nfunction validateOpts(curve: CurveType) {\n  validateObject(\n    curve,\n    {\n      a: 'bigint',\n    },\n    {\n      montgomeryBits: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n      adjustScalarBytes: 'function',\n      domain: 'function',\n      powPminus2: 'function',\n      Gu: 'bigint',\n    }\n  );\n  // Set defaults\n  return Object.freeze({ ...curve } as const);\n}\n\n// NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)\n// Uses only one coordinate instead of two\nexport function montgomery(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef);\n  const { P } = CURVE;\n  const modP = (n: bigint) => mod(n, P);\n  const montgomeryBits = CURVE.montgomeryBits;\n  const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n  const fieldLen = CURVE.nByteLength;\n  const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes: Uint8Array) => bytes);\n  const powPminus2 = CURVE.powPminus2 || ((x: bigint) => pow(x, P - BigInt(2), P));\n\n  // cswap from RFC7748. But it is not from RFC7748!\n  /*\n    cswap(swap, x_2, x_3):\n         dummy = mask(swap) AND (x_2 XOR x_3)\n         x_2 = x_2 XOR dummy\n         x_3 = x_3 XOR dummy\n         Return (x_2, x_3)\n  Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n   and x_3, computed, e.g., as mask(swap) = 0 - swap.\n  */\n  function cswap(swap: bigint, x_2: bigint, x_3: bigint): [bigint, bigint] {\n    const dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy);\n    x_3 = modP(x_3 + dummy);\n    return [x_2, x_3];\n  }\n\n  // Accepts 0 as well\n  function assertFieldElement(n: bigint): bigint {\n    if (typeof n === 'bigint' && _0n <= n && n < P) return n;\n    throw new Error('Expected valid scalar 0 < scalar < CURVE.P');\n  }\n\n  // x25519 from 4\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n  const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n  /**\n   *\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\n   * @param scalar by which the point would be multiplied\n   * @returns new Point on Montgomery curve\n   */\n  function montgomeryLadder(pointU: bigint, scalar: bigint): bigint {\n    const u = assertFieldElement(pointU);\n    // Section 5: Implementations MUST accept non-canonical values and process them as\n    // if they had been reduced modulo the field prime.\n    const k = assertFieldElement(scalar);\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw: [bigint, bigint];\n    for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n      const k_t = (k >> t) & _1n;\n      swap ^= k_t;\n      sw = cswap(swap, x_2, x_3);\n      x_2 = sw[0];\n      x_3 = sw[1];\n      sw = cswap(swap, z_2, z_3);\n      z_2 = sw[0];\n      z_3 = sw[1];\n      swap = k_t;\n\n      const A = x_2 + z_2;\n      const AA = modP(A * A);\n      const B = x_2 - z_2;\n      const BB = modP(B * B);\n      const E = AA - BB;\n      const C = x_3 + z_3;\n      const D = x_3 - z_3;\n      const DA = modP(D * A);\n      const CB = modP(C * B);\n      const dacb = DA + CB;\n      const da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    // (x_2, x_3) = cswap(swap, x_2, x_3)\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    // (z_2, z_3) = cswap(swap, z_2, z_3)\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    // z_2^(p - 2)\n    const z2 = powPminus2(z_2);\n    // Return x_2 * (z_2^(p - 2))\n    return modP(x_2 * z2);\n  }\n\n  function encodeUCoordinate(u: bigint): Uint8Array {\n    return numberToBytesLE(modP(u), montgomeryBytes);\n  }\n\n  function decodeUCoordinate(uEnc: Hex): bigint {\n    // Section 5: When receiving such an array, implementations of X25519\n    // MUST mask the most significant bit in the final byte.\n    // This is very ugly way, but it works because fieldLen-1 is outside of bounds for X448, so this becomes NOOP\n    // fieldLen - scalaryBytes = 1 for X448 and = 0 for X25519\n    const u = ensureBytes('u coordinate', uEnc, montgomeryBytes);\n    // u[fieldLen-1] crashes QuickJS (TypeError: out-of-bound numeric index)\n    if (fieldLen === montgomeryBytes) u[fieldLen - 1] &= 127; // 0b0111_1111\n    return bytesToNumberLE(u);\n  }\n  function decodeScalar(n: Hex): bigint {\n    const bytes = ensureBytes('scalar', n);\n    if (bytes.length !== montgomeryBytes && bytes.length !== fieldLen)\n      throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${bytes.length}`);\n    return bytesToNumberLE(adjustScalarBytes(bytes));\n  }\n  function scalarMult(scalar: Hex, u: Hex): Uint8Array {\n    const pointU = decodeUCoordinate(u);\n    const _scalar = decodeScalar(scalar);\n    const pu = montgomeryLadder(pointU, _scalar);\n    // The result was not contributory\n    // https://cr.yp.to/ecdh.html#validate\n    if (pu === _0n) throw new Error('Invalid private or public key received');\n    return encodeUCoordinate(pu);\n  }\n  // Computes public key from private. By doing scalar multiplication of base point.\n  const GuBytes = encodeUCoordinate(CURVE.Gu);\n  function scalarMultBase(scalar: Hex): Uint8Array {\n    return scalarMult(scalar, GuBytes);\n  }\n\n  return {\n    scalarMult,\n    scalarMultBase,\n    getSharedSecret: (privateKey: Hex, publicKey: Hex) => scalarMult(privateKey, publicKey),\n    getPublicKey: (privateKey: Hex): Uint8Array => scalarMultBase(privateKey),\n    utils: { randomPrivateKey: () => CURVE.randomBytes!(CURVE.nByteLength) },\n    GuBytes: GuBytes,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}