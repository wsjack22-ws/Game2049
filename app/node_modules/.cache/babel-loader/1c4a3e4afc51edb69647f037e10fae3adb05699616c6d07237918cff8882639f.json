{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BorshInstructionCoder = exports.SIGHASH_GLOBAL_NAMESPACE = exports.SIGHASH_STATE_NAMESPACE = void 0;\nconst bs58_1 = __importDefault(require(\"bs58\"));\nconst buffer_1 = require(\"buffer\");\nconst camelcase_1 = __importDefault(require(\"camelcase\"));\nconst snake_case_1 = require(\"snake-case\");\nconst js_sha256_1 = require(\"js-sha256\");\nconst borsh = __importStar(require(\"@project-serum/borsh\"));\nconst idl_js_1 = require(\"./idl.js\");\n/**\n * Namespace for state method function signatures.\n */\nexports.SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\nexports.SIGHASH_GLOBAL_NAMESPACE = \"global\";\n/**\n * Encodes and decodes program instructions.\n */\nclass BorshInstructionCoder {\n  constructor(idl) {\n    this.idl = idl;\n    this.ixLayout = BorshInstructionCoder.parseIxLayout(idl);\n    const sighashLayouts = new Map();\n    idl.instructions.forEach(ix => {\n      const sh = sighash(exports.SIGHASH_GLOBAL_NAMESPACE, ix.name);\n      sighashLayouts.set(bs58_1.default.encode(sh), {\n        layout: this.ixLayout.get(ix.name),\n        name: ix.name\n      });\n    });\n    if (idl.state) {\n      idl.state.methods.map(ix => {\n        const sh = sighash(exports.SIGHASH_STATE_NAMESPACE, ix.name);\n        sighashLayouts.set(bs58_1.default.encode(sh), {\n          layout: this.ixLayout.get(ix.name),\n          name: ix.name\n        });\n      });\n    }\n    this.sighashLayouts = sighashLayouts;\n  }\n  /**\n   * Encodes a program instruction.\n   */\n  encode(ixName, ix) {\n    return this._encode(exports.SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n  }\n  /**\n   * Encodes a program state instruction.\n   */\n  encodeState(ixName, ix) {\n    return this._encode(exports.SIGHASH_STATE_NAMESPACE, ixName, ix);\n  }\n  _encode(nameSpace, ixName, ix) {\n    const buffer = buffer_1.Buffer.alloc(1000); // TODO: use a tighter buffer.\n    const methodName = (0, camelcase_1.default)(ixName);\n    const layout = this.ixLayout.get(methodName);\n    if (!layout) {\n      throw new Error(`Unknown method: ${methodName}`);\n    }\n    const len = layout.encode(ix, buffer);\n    const data = buffer.slice(0, len);\n    return buffer_1.Buffer.concat([sighash(nameSpace, ixName), data]);\n  }\n  static parseIxLayout(idl) {\n    const stateMethods = idl.state ? idl.state.methods : [];\n    const ixLayouts = stateMethods.map(m => {\n      let fieldLayouts = m.args.map(arg => {\n        var _a, _b;\n        return idl_js_1.IdlCoder.fieldLayout(arg, Array.from([...((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), ...((_b = idl.types) !== null && _b !== void 0 ? _b : [])]));\n      });\n      const name = (0, camelcase_1.default)(m.name);\n      return [name, borsh.struct(fieldLayouts, name)];\n    }).concat(idl.instructions.map(ix => {\n      let fieldLayouts = ix.args.map(arg => {\n        var _a, _b;\n        return idl_js_1.IdlCoder.fieldLayout(arg, Array.from([...((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), ...((_b = idl.types) !== null && _b !== void 0 ? _b : [])]));\n      });\n      const name = (0, camelcase_1.default)(ix.name);\n      return [name, borsh.struct(fieldLayouts, name)];\n    }));\n    return new Map(ixLayouts);\n  }\n  /**\n   * Dewcodes a program instruction.\n   */\n  decode(ix, encoding = \"hex\") {\n    if (typeof ix === \"string\") {\n      ix = encoding === \"hex\" ? buffer_1.Buffer.from(ix, \"hex\") : bs58_1.default.decode(ix);\n    }\n    let sighash = bs58_1.default.encode(ix.slice(0, 8));\n    let data = ix.slice(8);\n    const decoder = this.sighashLayouts.get(sighash);\n    if (!decoder) {\n      return null;\n    }\n    return {\n      data: decoder.layout.decode(data),\n      name: decoder.name\n    };\n  }\n  /**\n   * Returns a formatted table of all the fields in the given instruction data.\n   */\n  format(ix, accountMetas) {\n    return InstructionFormatter.format(ix, accountMetas, this.idl);\n  }\n}\nexports.BorshInstructionCoder = BorshInstructionCoder;\nclass InstructionFormatter {\n  static format(ix, accountMetas, idl) {\n    const idlIx = idl.instructions.filter(i => ix.name === i.name)[0];\n    if (idlIx === undefined) {\n      console.error(\"Invalid instruction given\");\n      return null;\n    }\n    const args = idlIx.args.map(idlField => {\n      return {\n        name: idlField.name,\n        type: InstructionFormatter.formatIdlType(idlField.type),\n        data: InstructionFormatter.formatIdlData(idlField, ix.data[idlField.name], idl.types)\n      };\n    });\n    const flatIdlAccounts = InstructionFormatter.flattenIdlAccounts(idlIx.accounts);\n    const accounts = accountMetas.map((meta, idx) => {\n      if (idx < flatIdlAccounts.length) {\n        return {\n          name: flatIdlAccounts[idx].name,\n          ...meta\n        };\n      }\n      // \"Remaining accounts\" are unnamed in Anchor.\n      else {\n        return {\n          name: undefined,\n          ...meta\n        };\n      }\n    });\n    return {\n      args,\n      accounts\n    };\n  }\n  static formatIdlType(idlType) {\n    if (typeof idlType === \"string\") {\n      return idlType;\n    }\n    if (\"vec\" in idlType) {\n      return `Vec<${this.formatIdlType(idlType.vec)}>`;\n    }\n    if (\"option\" in idlType) {\n      return `Option<${this.formatIdlType(idlType.option)}>`;\n    }\n    if (\"defined\" in idlType) {\n      return idlType.defined;\n    }\n    if (\"array\" in idlType) {\n      return `Array<${idlType.array[0]}; ${idlType.array[1]}>`;\n    }\n    throw new Error(`Unknown IDL type: ${idlType}`);\n  }\n  static formatIdlData(idlField, data, types) {\n    if (typeof idlField.type === \"string\") {\n      return data.toString();\n    }\n    if (idlField.type.hasOwnProperty(\"vec\")) {\n      return \"[\" + data.map(d => this.formatIdlData({\n        name: \"\",\n        type: idlField.type.vec\n      }, d)).join(\", \") + \"]\";\n    }\n    if (idlField.type.hasOwnProperty(\"option\")) {\n      return data === null ? \"null\" : this.formatIdlData({\n        name: \"\",\n        type: idlField.type.option\n      }, data, types);\n    }\n    if (idlField.type.hasOwnProperty(\"defined\")) {\n      if (types === undefined) {\n        throw new Error(\"User defined types not provided\");\n      }\n      const filtered = types.filter(t => t.name === idlField.type.defined);\n      if (filtered.length !== 1) {\n        throw new Error(`Type not found: ${idlField.type.defined}`);\n      }\n      return InstructionFormatter.formatIdlDataDefined(filtered[0], data, types);\n    }\n    return \"unknown\";\n  }\n  static formatIdlDataDefined(typeDef, data, types) {\n    if (typeDef.type.kind === \"struct\") {\n      const struct = typeDef.type;\n      const fields = Object.keys(data).map(k => {\n        const f = struct.fields.filter(f => f.name === k)[0];\n        if (f === undefined) {\n          throw new Error(\"Unable to find type\");\n        }\n        return k + \": \" + InstructionFormatter.formatIdlData(f, data[k], types);\n      }).join(\", \");\n      return \"{ \" + fields + \" }\";\n    } else {\n      if (typeDef.type.variants.length === 0) {\n        return \"{}\";\n      }\n      // Struct enum.\n      if (typeDef.type.variants[0].name) {\n        const variants = typeDef.type.variants;\n        const variant = Object.keys(data)[0];\n        const enumType = data[variant];\n        const namedFields = Object.keys(enumType).map(f => {\n          var _a;\n          const fieldData = enumType[f];\n          const idlField = (_a = variants[variant]) === null || _a === void 0 ? void 0 : _a.filter(v => v.name === f)[0];\n          if (idlField === undefined) {\n            throw new Error(\"Unable to find variant\");\n          }\n          return f + \": \" + InstructionFormatter.formatIdlData(idlField, fieldData, types);\n        }).join(\", \");\n        const variantName = (0, camelcase_1.default)(variant, {\n          pascalCase: true\n        });\n        if (namedFields.length === 0) {\n          return variantName;\n        }\n        return `${variantName} { ${namedFields} }`;\n      }\n      // Tuple enum.\n      else {\n        // TODO.\n        return \"Tuple formatting not yet implemented\";\n      }\n    }\n  }\n  static flattenIdlAccounts(accounts, prefix) {\n    return accounts.map(account => {\n      const accName = sentenceCase(account.name);\n      if (account.hasOwnProperty(\"accounts\")) {\n        const newPrefix = prefix ? `${prefix} > ${accName}` : accName;\n        return InstructionFormatter.flattenIdlAccounts(account.accounts, newPrefix);\n      } else {\n        return {\n          ...account,\n          name: prefix ? `${prefix} > ${accName}` : accName\n        };\n      }\n    }).flat();\n  }\n}\nfunction sentenceCase(field) {\n  const result = field.replace(/([A-Z])/g, \" $1\");\n  return result.charAt(0).toUpperCase() + result.slice(1);\n}\n// Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\nfunction sighash(nameSpace, ixName) {\n  let name = (0, snake_case_1.snakeCase)(ixName);\n  let preimage = `${nameSpace}:${name}`;\n  return buffer_1.Buffer.from(js_sha256_1.sha256.digest(preimage)).slice(0, 8);\n}","map":{"version":3,"names":["bs58_1","__importDefault","require","buffer_1","camelcase_1","snake_case_1","js_sha256_1","borsh","__importStar","idl_js_1","exports","SIGHASH_STATE_NAMESPACE","SIGHASH_GLOBAL_NAMESPACE","BorshInstructionCoder","constructor","idl","ixLayout","parseIxLayout","sighashLayouts","Map","instructions","forEach","ix","sh","sighash","name","set","default","encode","layout","get","state","methods","map","ixName","_encode","encodeState","nameSpace","buffer","Buffer","alloc","methodName","Error","len","data","slice","concat","stateMethods","ixLayouts","m","fieldLayouts","args","arg","IdlCoder","fieldLayout","Array","from","_a","accounts","_b","types","struct","decode","encoding","decoder","format","accountMetas","InstructionFormatter","idlIx","filter","i","undefined","console","error","idlField","type","formatIdlType","formatIdlData","flatIdlAccounts","flattenIdlAccounts","meta","idx","length","idlType","vec","option","defined","array","toString","hasOwnProperty","d","join","filtered","t","formatIdlDataDefined","typeDef","kind","fields","Object","keys","k","f","variants","variant","enumType","namedFields","fieldData","v","variantName","pascalCase","prefix","account","accName","sentenceCase","newPrefix","flat","field","result","replace","charAt","toUpperCase","snakeCase","preimage","sha256","digest"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/coder/borsh/instruction.ts"],"sourcesContent":["import bs58 from \"bs58\";\nimport { Buffer } from \"buffer\";\nimport { Layout } from \"buffer-layout\";\nimport camelCase from \"camelcase\";\nimport { snakeCase } from \"snake-case\";\nimport { sha256 } from \"js-sha256\";\nimport * as borsh from \"@project-serum/borsh\";\nimport { AccountMeta, PublicKey } from \"@solana/web3.js\";\nimport {\n  Idl,\n  IdlField,\n  IdlStateMethod,\n  IdlType,\n  IdlTypeDef,\n  IdlAccount,\n  IdlAccountItem,\n  IdlTypeDefTyStruct,\n  IdlTypeVec,\n  IdlTypeOption,\n  IdlTypeDefined,\n  IdlAccounts,\n} from \"../../idl.js\";\nimport { IdlCoder } from \"./idl.js\";\nimport { InstructionCoder } from \"../index.js\";\n\n/**\n * Namespace for state method function signatures.\n */\nexport const SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\nexport const SIGHASH_GLOBAL_NAMESPACE = \"global\";\n\n/**\n * Encodes and decodes program instructions.\n */\nexport class BorshInstructionCoder implements InstructionCoder {\n  // Instruction args layout. Maps namespaced method\n  private ixLayout: Map<string, Layout>;\n\n  // Base58 encoded sighash to instruction layout.\n  private sighashLayouts: Map<string, { layout: Layout; name: string }>;\n\n  public constructor(private idl: Idl) {\n    this.ixLayout = BorshInstructionCoder.parseIxLayout(idl);\n\n    const sighashLayouts = new Map();\n    idl.instructions.forEach((ix) => {\n      const sh = sighash(SIGHASH_GLOBAL_NAMESPACE, ix.name);\n      sighashLayouts.set(bs58.encode(sh), {\n        layout: this.ixLayout.get(ix.name),\n        name: ix.name,\n      });\n    });\n\n    if (idl.state) {\n      idl.state.methods.map((ix) => {\n        const sh = sighash(SIGHASH_STATE_NAMESPACE, ix.name);\n        sighashLayouts.set(bs58.encode(sh), {\n          layout: this.ixLayout.get(ix.name) as Layout,\n          name: ix.name,\n        });\n      });\n    }\n\n    this.sighashLayouts = sighashLayouts;\n  }\n\n  /**\n   * Encodes a program instruction.\n   */\n  public encode(ixName: string, ix: any): Buffer {\n    return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n  }\n\n  /**\n   * Encodes a program state instruction.\n   */\n  public encodeState(ixName: string, ix: any): Buffer {\n    return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);\n  }\n\n  private _encode(nameSpace: string, ixName: string, ix: any): Buffer {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n    const methodName = camelCase(ixName);\n    const layout = this.ixLayout.get(methodName);\n    if (!layout) {\n      throw new Error(`Unknown method: ${methodName}`);\n    }\n    const len = layout.encode(ix, buffer);\n    const data = buffer.slice(0, len);\n    return Buffer.concat([sighash(nameSpace, ixName), data]);\n  }\n\n  private static parseIxLayout(idl: Idl): Map<string, Layout> {\n    const stateMethods = idl.state ? idl.state.methods : [];\n\n    const ixLayouts = stateMethods\n      .map((m: IdlStateMethod): [string, Layout<unknown>] => {\n        let fieldLayouts = m.args.map((arg: IdlField) => {\n          return IdlCoder.fieldLayout(\n            arg,\n            Array.from([...(idl.accounts ?? []), ...(idl.types ?? [])])\n          );\n        });\n        const name = camelCase(m.name);\n        return [name, borsh.struct(fieldLayouts, name)];\n      })\n      .concat(\n        idl.instructions.map((ix) => {\n          let fieldLayouts = ix.args.map((arg: IdlField) =>\n            IdlCoder.fieldLayout(\n              arg,\n              Array.from([...(idl.accounts ?? []), ...(idl.types ?? [])])\n            )\n          );\n          const name = camelCase(ix.name);\n          return [name, borsh.struct(fieldLayouts, name)];\n        })\n      );\n    return new Map(ixLayouts);\n  }\n\n  /**\n   * Dewcodes a program instruction.\n   */\n  public decode(\n    ix: Buffer | string,\n    encoding: \"hex\" | \"base58\" = \"hex\"\n  ): Instruction | null {\n    if (typeof ix === \"string\") {\n      ix = encoding === \"hex\" ? Buffer.from(ix, \"hex\") : bs58.decode(ix);\n    }\n    let sighash = bs58.encode(ix.slice(0, 8));\n    let data = ix.slice(8);\n    const decoder = this.sighashLayouts.get(sighash);\n    if (!decoder) {\n      return null;\n    }\n    return {\n      data: decoder.layout.decode(data),\n      name: decoder.name,\n    };\n  }\n\n  /**\n   * Returns a formatted table of all the fields in the given instruction data.\n   */\n  public format(\n    ix: Instruction,\n    accountMetas: AccountMeta[]\n  ): InstructionDisplay | null {\n    return InstructionFormatter.format(ix, accountMetas, this.idl);\n  }\n}\n\nexport type Instruction = {\n  name: string;\n  data: Object;\n};\n\nexport type InstructionDisplay = {\n  args: { name: string; type: string; data: string }[];\n  accounts: {\n    name?: string;\n    pubkey: PublicKey;\n    isSigner: boolean;\n    isWritable: boolean;\n  }[];\n};\n\nclass InstructionFormatter {\n  public static format(\n    ix: Instruction,\n    accountMetas: AccountMeta[],\n    idl: Idl\n  ): InstructionDisplay | null {\n    const idlIx = idl.instructions.filter((i) => ix.name === i.name)[0];\n    if (idlIx === undefined) {\n      console.error(\"Invalid instruction given\");\n      return null;\n    }\n\n    const args = idlIx.args.map((idlField) => {\n      return {\n        name: idlField.name,\n        type: InstructionFormatter.formatIdlType(idlField.type),\n        data: InstructionFormatter.formatIdlData(\n          idlField,\n          ix.data[idlField.name],\n          idl.types\n        ),\n      };\n    });\n\n    const flatIdlAccounts = InstructionFormatter.flattenIdlAccounts(\n      idlIx.accounts\n    );\n\n    const accounts = accountMetas.map((meta, idx) => {\n      if (idx < flatIdlAccounts.length) {\n        return {\n          name: flatIdlAccounts[idx].name,\n          ...meta,\n        };\n      }\n      // \"Remaining accounts\" are unnamed in Anchor.\n      else {\n        return {\n          name: undefined,\n          ...meta,\n        };\n      }\n    });\n\n    return {\n      args,\n      accounts,\n    };\n  }\n\n  private static formatIdlType(idlType: IdlType): string {\n    if (typeof idlType === \"string\") {\n      return idlType as string;\n    }\n\n    if (\"vec\" in idlType) {\n      return `Vec<${this.formatIdlType(idlType.vec)}>`;\n    }\n    if (\"option\" in idlType) {\n      return `Option<${this.formatIdlType(idlType.option)}>`;\n    }\n    if (\"defined\" in idlType) {\n      return idlType.defined;\n    }\n    if (\"array\" in idlType) {\n      return `Array<${idlType.array[0]}; ${idlType.array[1]}>`;\n    }\n\n    throw new Error(`Unknown IDL type: ${idlType}`);\n  }\n\n  private static formatIdlData(\n    idlField: IdlField,\n    data: Object,\n    types?: IdlTypeDef[]\n  ): string {\n    if (typeof idlField.type === \"string\") {\n      return data.toString();\n    }\n    if (idlField.type.hasOwnProperty(\"vec\")) {\n      return (\n        \"[\" +\n        (<Array<IdlField>>data)\n          .map((d: IdlField) =>\n            this.formatIdlData(\n              { name: \"\", type: (<IdlTypeVec>idlField.type).vec },\n              d\n            )\n          )\n          .join(\", \") +\n        \"]\"\n      );\n    }\n    if (idlField.type.hasOwnProperty(\"option\")) {\n      return data === null\n        ? \"null\"\n        : this.formatIdlData(\n            { name: \"\", type: (<IdlTypeOption>idlField.type).option },\n            data,\n            types\n          );\n    }\n    if (idlField.type.hasOwnProperty(\"defined\")) {\n      if (types === undefined) {\n        throw new Error(\"User defined types not provided\");\n      }\n      const filtered = types.filter(\n        (t) => t.name === (<IdlTypeDefined>idlField.type).defined\n      );\n      if (filtered.length !== 1) {\n        throw new Error(\n          `Type not found: ${(<IdlTypeDefined>idlField.type).defined}`\n        );\n      }\n      return InstructionFormatter.formatIdlDataDefined(\n        filtered[0],\n        data,\n        types\n      );\n    }\n\n    return \"unknown\";\n  }\n\n  private static formatIdlDataDefined(\n    typeDef: IdlTypeDef,\n    data: Object,\n    types: IdlTypeDef[]\n  ): string {\n    if (typeDef.type.kind === \"struct\") {\n      const struct: IdlTypeDefTyStruct = typeDef.type;\n      const fields = Object.keys(data)\n        .map((k) => {\n          const f = struct.fields.filter((f) => f.name === k)[0];\n          if (f === undefined) {\n            throw new Error(\"Unable to find type\");\n          }\n          return (\n            k + \": \" + InstructionFormatter.formatIdlData(f, data[k], types)\n          );\n        })\n        .join(\", \");\n      return \"{ \" + fields + \" }\";\n    } else {\n      if (typeDef.type.variants.length === 0) {\n        return \"{}\";\n      }\n      // Struct enum.\n      if (typeDef.type.variants[0].name) {\n        const variants = typeDef.type.variants;\n        const variant = Object.keys(data)[0];\n        const enumType = data[variant];\n        const namedFields = Object.keys(enumType)\n          .map((f) => {\n            const fieldData = enumType[f];\n            const idlField = variants[variant]?.filter(\n              (v: IdlField) => v.name === f\n            )[0];\n            if (idlField === undefined) {\n              throw new Error(\"Unable to find variant\");\n            }\n            return (\n              f +\n              \": \" +\n              InstructionFormatter.formatIdlData(idlField, fieldData, types)\n            );\n          })\n          .join(\", \");\n\n        const variantName = camelCase(variant, { pascalCase: true });\n        if (namedFields.length === 0) {\n          return variantName;\n        }\n        return `${variantName} { ${namedFields} }`;\n      }\n      // Tuple enum.\n      else {\n        // TODO.\n        return \"Tuple formatting not yet implemented\";\n      }\n    }\n  }\n\n  private static flattenIdlAccounts(\n    accounts: IdlAccountItem[],\n    prefix?: string\n  ): IdlAccount[] {\n    return accounts\n      .map((account) => {\n        const accName = sentenceCase(account.name);\n        if (account.hasOwnProperty(\"accounts\")) {\n          const newPrefix = prefix ? `${prefix} > ${accName}` : accName;\n          return InstructionFormatter.flattenIdlAccounts(\n            (<IdlAccounts>account).accounts,\n            newPrefix\n          );\n        } else {\n          return {\n            ...(<IdlAccount>account),\n            name: prefix ? `${prefix} > ${accName}` : accName,\n          };\n        }\n      })\n      .flat();\n  }\n}\n\nfunction sentenceCase(field: string): string {\n  const result = field.replace(/([A-Z])/g, \" $1\");\n  return result.charAt(0).toUpperCase() + result.slice(1);\n}\n\n// Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\nfunction sighash(nameSpace: string, ixName: string): Buffer {\n  let name = snakeCase(ixName);\n  let preimage = `${nameSpace}:${name}`;\n  return Buffer.from(sha256.digest(preimage)).slice(0, 8);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}