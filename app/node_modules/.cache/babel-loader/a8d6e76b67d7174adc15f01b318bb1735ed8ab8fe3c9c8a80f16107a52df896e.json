{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.translateAddress = exports.validateAccounts = exports.toInstruction = exports.parseIdlErrors = void 0;\nvar web3_js_1 = require(\"@solana/web3.js\");\nfunction parseIdlErrors(idl) {\n  var errors = new Map();\n  if (idl.errors) {\n    idl.errors.forEach(function (e) {\n      var _a;\n      var msg = (_a = e.msg) !== null && _a !== void 0 ? _a : e.name;\n      errors.set(e.code, msg);\n    });\n  }\n  return errors;\n}\nexports.parseIdlErrors = parseIdlErrors;\n// Allow either IdLInstruction or IdlStateMethod since the types share fields.\nfunction toInstruction(idlIx) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  if (idlIx.args.length != args.length) {\n    throw new Error(\"Invalid argument length\");\n  }\n  var ix = {};\n  var idx = 0;\n  idlIx.args.forEach(function (ixArg) {\n    ix[ixArg.name] = args[idx];\n    idx += 1;\n  });\n  return ix;\n}\nexports.toInstruction = toInstruction;\n// Throws error if any account required for the `ix` is not given.\nfunction validateAccounts(ixAccounts) {\n  var accounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  ixAccounts.forEach(function (acc) {\n    if (\"accounts\" in acc) {\n      validateAccounts(acc.accounts, accounts[acc.name]);\n    } else {\n      if (accounts[acc.name] === undefined) {\n        throw new Error(\"Invalid arguments: \".concat(acc.name, \" not provided.\"));\n      }\n    }\n  });\n}\nexports.validateAccounts = validateAccounts;\n// Translates an address to a Pubkey.\nfunction translateAddress(address) {\n  return address instanceof web3_js_1.PublicKey ? address : new web3_js_1.PublicKey(address);\n}\nexports.translateAddress = translateAddress;","map":{"version":3,"names":["web3_js_1","require","parseIdlErrors","idl","errors","Map","forEach","e","msg","_a","name","set","code","exports","toInstruction","idlIx","_len","arguments","length","args","Array","_key","Error","ix","idx","ixArg","validateAccounts","ixAccounts","accounts","undefined","acc","concat","translateAddress","address","PublicKey"],"sources":["/Users/wuhuan/gif-portal-starter/node_modules/@project-serum/anchor/src/program/common.ts"],"sourcesContent":["import EventEmitter from \"eventemitter3\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { Idl, IdlInstruction, IdlAccountItem, IdlStateMethod } from \"../idl.js\";\nimport { Accounts } from \"./context.js\";\n\nexport type Subscription = {\n  listener: number;\n  ee: EventEmitter;\n};\n\nexport function parseIdlErrors(idl: Idl): Map<number, string> {\n  const errors = new Map();\n  if (idl.errors) {\n    idl.errors.forEach((e) => {\n      let msg = e.msg ?? e.name;\n      errors.set(e.code, msg);\n    });\n  }\n  return errors;\n}\n\n// Allow either IdLInstruction or IdlStateMethod since the types share fields.\nexport function toInstruction(\n  idlIx: IdlInstruction | IdlStateMethod,\n  ...args: any[]\n) {\n  if (idlIx.args.length != args.length) {\n    throw new Error(\"Invalid argument length\");\n  }\n  const ix: { [key: string]: any } = {};\n  let idx = 0;\n  idlIx.args.forEach((ixArg) => {\n    ix[ixArg.name] = args[idx];\n    idx += 1;\n  });\n\n  return ix;\n}\n\n// Throws error if any account required for the `ix` is not given.\nexport function validateAccounts(\n  ixAccounts: IdlAccountItem[],\n  accounts: Accounts = {}\n) {\n  ixAccounts.forEach((acc) => {\n    if (\"accounts\" in acc) {\n      validateAccounts(acc.accounts, accounts[acc.name] as Accounts);\n    } else {\n      if (accounts[acc.name] === undefined) {\n        throw new Error(`Invalid arguments: ${acc.name} not provided.`);\n      }\n    }\n  });\n}\n\n// Translates an address to a Pubkey.\nexport function translateAddress(address: Address): PublicKey {\n  return address instanceof PublicKey ? address : new PublicKey(address);\n}\n\n/**\n * An address to identify an account on chain. Can be a [[PublicKey]],\n * or Base 58 encoded string.\n */\nexport type Address = PublicKey | string;\n"],"mappings":";;;;;;AACA,IAAAA,SAAA,GAAAC,OAAA;AASA,SAAgBC,cAAcA,CAACC,GAAQ;EACrC,IAAMC,MAAM,GAAG,IAAIC,GAAG,EAAE;EACxB,IAAIF,GAAG,CAACC,MAAM,EAAE;IACdD,GAAG,CAACC,MAAM,CAACE,OAAO,CAAC,UAACC,CAAC,EAAI;;MACvB,IAAIC,GAAG,GAAG,CAAAC,EAAA,GAAAF,CAAC,CAACC,GAAG,cAAAC,EAAA,cAAAA,EAAA,GAAIF,CAAC,CAACG,IAAI;MACzBN,MAAM,CAACO,GAAG,CAACJ,CAAC,CAACK,IAAI,EAAEJ,GAAG,CAAC;IACzB,CAAC,CAAC;;EAEJ,OAAOJ,MAAM;AACf;AATAS,OAAA,CAAAX,cAAA,GAAAA,cAAA;AAWA;AACA,SAAgBY,aAAaA,CAC3BC,KAAsC,EACxB;EAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAAXC,IAAW,OAAAC,KAAA,CAAAJ,IAAA,OAAAA,IAAA,WAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;IAAXF,IAAW,CAAAE,IAAA,QAAAJ,SAAA,CAAAI,IAAA;EAAA;EAEd,IAAIN,KAAK,CAACI,IAAI,CAACD,MAAM,IAAIC,IAAI,CAACD,MAAM,EAAE;IACpC,MAAM,IAAII,KAAK,CAAC,yBAAyB,CAAC;;EAE5C,IAAMC,EAAE,GAA2B,EAAE;EACrC,IAAIC,GAAG,GAAG,CAAC;EACXT,KAAK,CAACI,IAAI,CAACb,OAAO,CAAC,UAACmB,KAAK,EAAI;IAC3BF,EAAE,CAACE,KAAK,CAACf,IAAI,CAAC,GAAGS,IAAI,CAACK,GAAG,CAAC;IAC1BA,GAAG,IAAI,CAAC;EACV,CAAC,CAAC;EAEF,OAAOD,EAAE;AACX;AAfAV,OAAA,CAAAC,aAAA,GAAAA,aAAA;AAiBA;AACA,SAAgBY,gBAAgBA,CAC9BC,UAA4B,EACL;EAAA,IAAvBC,QAAA,GAAAX,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAY,SAAA,GAAAZ,SAAA,MAAqB,EAAE;EAEvBU,UAAU,CAACrB,OAAO,CAAC,UAACwB,GAAG,EAAI;IACzB,IAAI,UAAU,IAAIA,GAAG,EAAE;MACrBJ,gBAAgB,CAACI,GAAG,CAACF,QAAQ,EAAEA,QAAQ,CAACE,GAAG,CAACpB,IAAI,CAAa,CAAC;KAC/D,MAAM;MACL,IAAIkB,QAAQ,CAACE,GAAG,CAACpB,IAAI,CAAC,KAAKmB,SAAS,EAAE;QACpC,MAAM,IAAIP,KAAK,uBAAAS,MAAA,CAAuBD,GAAG,CAACpB,IAAI,mBAAgB,CAAC;;;EAGrE,CAAC,CAAC;AACJ;AAbAG,OAAA,CAAAa,gBAAA,GAAAA,gBAAA;AAeA;AACA,SAAgBM,gBAAgBA,CAACC,OAAgB;EAC/C,OAAOA,OAAO,YAAYjC,SAAA,CAAAkC,SAAS,GAAGD,OAAO,GAAG,IAAIjC,SAAA,CAAAkC,SAAS,CAACD,OAAO,CAAC;AACxE;AAFApB,OAAA,CAAAmB,gBAAA,GAAAA,gBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}