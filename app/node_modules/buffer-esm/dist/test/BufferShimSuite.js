"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("mocha");
const index_1 = require("../index");
const assert_1 = require("assert");
const crypto_1 = require("crypto");
describe('BufferShim', () => {
    it('should encode and decode strings', () => {
        const ascii = 'To infinity and beyond!';
        const unicode = 'I ♡ Wisconsin! 今日は ð Ķ';
        const base64 = 'VG8gaW5maW5pdHkgYW5kIGJleW9uZCE=';
        const hex = 'ac7e891e3b041a6149204b836e29cb4f';
        index_1.ignoreNode(true);
        assert_1.strictEqual(index_1.BufferShim.isNodeEnv, false);
        assert_1.strictEqual(index_1.BufferShim.from(ascii).toString(), Buffer.from(ascii).toString());
        assert_1.strictEqual(index_1.BufferShim.from(ascii, 'ascii').toString('utf8'), Buffer.from(ascii, 'ascii').toString('UTF8'));
        assert_1.strictEqual(index_1.BufferShim.from(ascii, 'ascii').toString('utf-8'), Buffer.from(ascii, 'ascii').toString('utf-8'));
        assert_1.strictEqual(index_1.BufferShim.from(ascii, 'ascii').toString('ascii'), Buffer.from(ascii, 'ascii').toString('ascii'));
        assert_1.strictEqual(index_1.BufferShim.from(ascii, 'hex').toString('utf8'), Buffer.from(ascii, 'hex').toString('utf8'));
        assert_1.strictEqual(index_1.BufferShim.from(ascii, 'binary').toString('utf8'), Buffer.from(ascii, 'binary').toString('utf8'));
        assert_1.strictEqual(index_1.BufferShim.from(ascii, 'utf8').toString('base64'), Buffer.from(ascii, 'utf8').toString('base64'));
        assert_1.strictEqual(index_1.BufferShim.from('T', 'utf8').toString('base64'), Buffer.from('T', 'utf8').toString('base64'));
        assert_1.strictEqual(index_1.BufferShim.from(unicode, 'utf8').toString('utf8'), Buffer.from(unicode, 'utf8').toString('utf8'));
        assert_1.strictEqual(index_1.BufferShim.from(unicode, 'ucs2').toString('ucs2'), Buffer.from(unicode, 'ucs2').toString('ucs2'));
        assert_1.strictEqual(index_1.BufferShim.from(unicode, 'ucs2').toString('ucs-2'), Buffer.from(unicode, 'ucs2').toString('ucs-2'));
        assert_1.strictEqual(index_1.BufferShim.from(base64, 'base64').toString('utf8'), Buffer.from(base64, 'base64').toString('utf8'));
        assert_1.strictEqual(index_1.BufferShim.from('VA==', 'base64').toString('utf8'), Buffer.from('VA==', 'base64').toString('utf8'));
        assert_1.strictEqual(index_1.BufferShim.from(hex, 'hex').toString('hex'), Buffer.from(hex, 'hex').toString('hex'));
        assert_1.strictEqual(index_1.BufferShim.from(hex, 'hex').toString('binary'), Buffer.from(hex, 'hex').toString('binary'));
        assert_1.strictEqual(index_1.BufferShim.from(hex, 'hex').toString('latin1'), Buffer.from(hex, 'hex').toString('latin1'));
        assert_1.throws(() => {
            index_1.BufferShim.from('', 'nope');
        });
        assert_1.throws(() => {
            index_1.BufferShim.from({});
        });
        index_1.ignoreNode(false);
        assert_1.strictEqual(index_1.BufferShim.from(ascii).toString(), Buffer.from(ascii).toString());
        assert_1.strictEqual(index_1.BufferShim.from(ascii, 'ascii').toString('utf8'), Buffer.from(ascii, 'ascii').toString('utf8'));
        assert_1.strictEqual(index_1.BufferShim.from(ascii, 'hex').toString('utf8'), Buffer.from(ascii, 'hex').toString('UTF-8'));
        assert_1.strictEqual(index_1.BufferShim.from(ascii, 'binary').toString('utf8'), Buffer.from(ascii, 'binary').toString('utf8'));
        assert_1.strictEqual(index_1.BufferShim.from(ascii, 'utf8').toString('base64'), Buffer.from(ascii, 'utf8').toString('base64'));
        assert_1.strictEqual(index_1.BufferShim.from(unicode, 'utf8').toString('utf8'), Buffer.from(unicode, 'utf8').toString('utf8'));
        assert_1.strictEqual(index_1.BufferShim.from(unicode, 'ucs2').toString('ucs2'), Buffer.from(unicode, 'ucs2').toString('ucs2'));
        assert_1.strictEqual(index_1.BufferShim.from(base64, 'base64').toString('utf8'), Buffer.from(base64, 'base64').toString('utf8'));
        assert_1.strictEqual(index_1.BufferShim.from(hex, 'hex').toString('hex'), Buffer.from(hex, 'hex').toString('hex'));
        assert_1.strictEqual(index_1.BufferShim.from(hex, 'hex').toString('binary'), Buffer.from(hex, 'hex').toString('binary'));
    });
    it('should encode and decode buffers', () => {
        const buffer = crypto_1.randomBytes(16);
        const arrayBuffer = index_1.BufferShim.toArrayBuffer(buffer);
        const sharedArrayBuffer = new SharedArrayBuffer(10);
        const array = Array.from(buffer);
        index_1.ignoreNode(true);
        assert_1.strictEqual(index_1.BufferShim.from(arrayBuffer).toString('base64'), Buffer.from(arrayBuffer).toString('base64'));
        assert_1.strictEqual(index_1.BufferShim.from(sharedArrayBuffer).toString('base64'), Buffer.from(sharedArrayBuffer).toString('base64'));
        assert_1.strictEqual(index_1.BufferShim.from(array).toString('base64'), Buffer.from(array).toString('base64'));
        index_1.ignoreNode(false);
        assert_1.strictEqual(index_1.BufferShim.from(buffer).toString('base64'), Buffer.from(buffer).toString('base64'));
    });
    it('should convert instance to other types', () => {
        const ignore = index_1.ignoreNode();
        assert_1.strictEqual(ignore, false);
        const bufferShim = index_1.BufferShim.from([0]);
        assert_1.strictEqual(bufferShim.toUint8Array() instanceof Uint8Array, true);
        assert_1.strictEqual(bufferShim.toBuffer() instanceof Buffer, true);
        index_1.ignoreNode(true);
        assert_1.strictEqual(bufferShim.toBuffer() instanceof index_1.BufferShim, true);
    });
    it('should allocate instance by size', () => {
        const size = 10;
        assert_1.strictEqual(index_1.BufferShim.alloc(size).length, size);
        assert_1.strictEqual(index_1.BufferShim.alloc(size, '13', 'utf8').length, size);
        assert_1.strictEqual(index_1.BufferShim.allocUnsafe(size).length, size);
        assert_1.strictEqual(index_1.BufferShim.allocUnsafe(size).fill('', 5, 'utf8').length, size);
        assert_1.strictEqual(index_1.BufferShim.allocUnsafe(size).fill('h', 5, 6, '').length, size);
        assert_1.strictEqual(index_1.BufferShim.allocUnsafe(size).fill('hw', 5, 6, 'utf8').length, size);
        assert_1.strictEqual(index_1.BufferShim.allocUnsafe(size).fill('h', 5, 6, 'binary').length, size);
        assert_1.throws(() => {
            index_1.BufferShim.fill(index_1.BufferShim.allocUnsafe(42), 42, 10, 2147483648);
        });
        assert_1.throws(() => {
            index_1.BufferShim.alloc(32, 'hw', 'doowop');
        });
    });
});
